# 网站开发常见问题

* [前端篇](#前端篇)
* [后端篇](#后端篇)
* [服务器篇](#服务器篇)

## 前端篇

1. unicode和utf编解码的原理和不同

    * 参考链接：

        [Unicode和UTF-8字符串编码解码原理](https://blog.csdn.net/Enl0ve/article/details/82844484)

        [Unicode 和 UTF-8、UTF-16之间的区别](https://blog.csdn.net/zengchen__acmer/article/details/75332190)

        [【编码】ASCII、Unicode、GBK和UTF-8字符编码的区别联系](https://blog.csdn.net/u010262331/article/details/46013905)

        [各种常见编码的转换算法](https://blog.csdn.net/xiaolongwang2010/article/details/10311397)

    Unicode是字符集，而UTF-8是编码规则

    字符集为每一个字符分配一个唯一的ID(学名为码位/码点/Code Point)，而「编码规则」则是将「码位」转换为字节序列的规则。

    起初Unicode规定每个字符都是用 2个字节来表示，但是由于英文字符等只需要一个字节就可以表，那就造成了在保存英文文本时，就会浪费一倍的空间。

    UTF-8是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

    ```txt
    例如「田」的码位是30000，记作U+7530(30000的16进制为0x7530)。
    U+ 0000 ~ U+ 007F: 0XXXXXXX
    U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
    U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
    U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
    
    根据上表中的编码规则，之前的「田」字的码位 U+7530 属于第三行的范围：
    
        7    5    3    0   
        0111 0101 0011 0000    二进制的 7530
    --------------------------
        0111   011111   100101 二进制的 77E5
    1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
    11100111 10010100 10110000 代入模版
    E   7    9   4    B   0
    
    这就是将 U+7530 按照 UTF-8 编码为字节序列 E794B0 的过程。反之亦然。
    ```

    UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。

2. base64和二进制的不同

    * 参考链接：

        [让你完全理解base64是怎么回事](https://www.cnblogs.com/sweeeper/p/8462077.html)

        [一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770)

        [JavaScript用btoa和atob来编码解码Base64](https://my.oschina.net/itblog/blog/1613977)

        [原生JS实现base64解码与编码](https://imweb.io/topic/5b8ea5327cd95ea86319358a)

    Base64编码可以将任意一组字节转换为较长的常见文本字符序列,将用户输入或二进制数据，打包成一种安全格式发送出去，无须担心其中包含冒号、换行符或二进制值等特殊字符。

    ```txt
    例子：输入Ow!

    (1) 字符串"Ow!"被拆分成3个8位的字节(0x4F、0x77、0x21)

    (2) 这3个字节构成了一个24为的二进制01001111 01110111 00100001

    (3) 这些为被划分为一些6位的序列010011、110111、011100、100001,(若不能正好平均分成每段6位，则按6和8的最小公倍数在末尾补0，位数为6和8的最小公倍数，000000用填充码=表示)

    (4) 每个6位值都表示了从0～63之间的数字，对应base64字母表中的64个字符之一。得到的base64编码字符串是4个字符的字符串“T3ch”。然后就可以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些移植性最好的字符(字母、数字等)。

    a:a -- 011000 010011 101001 100001 -- YTph

    a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==

    a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=

    a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 100001 -- YTphYWFh
    ```
    ```txt
    编码表：

    0　A　　17　R　　　34　i　　　51　z

    1　B　　18　S　　　35　j　　　52　0

    2　C　　19　T　　　36　k　　　53　1

    3　D　　20　U　　　37　l　　　54　2

    4　E　　21　V　　　38　m　　　55　3

    5　F　　22　W　　　39　n　　　56　4

    6　G　　23　X　　　40　o　　　57　5

    7　H　　24　Y　　　41　p　　　58　6

    8　I　　25　Z　　　42　q　　　59　7

    9　J　　26　a　　　43　r　　　60　8

    10　K　　27　b　　　44　s　　　61　9

    11　L　　28　c　　　45　t　　　62　+

    12　M　　29　d　　　46　u　　　63　/

    13　N　　30　e　　　47　v

    14　O　　31　f　　　48　w　　　

    15　P　　32　g　　　49　x

    16　Q　　33　h　　　50　y
    ```
    btoa和atob是window对象的两个函数，其中btoa是binary to ascii，用于将binary的数据用ascii码表示，即Base64的编码过程，而atob则是ascii to binary，用于将ascii码解析成binary数据
    ```js
    //方法实现
    var a = 'Hello World!';
    var encodedString = btoa(string);
    console.log(encodedString); // Outputs: "SGVsbG8gV29ybGQh"
    var decodedString = atob(encodedString);
    console.log(decodedString); // Outputs: "Hello World!"
    //涉及中文时，需要encodeURIComponent
    var b = "Hello, 中国！";
    //"SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE="
    var encodedString2 = btoa(encodeURIComponent(b));
    var decodedString2 = decodeURIComponent(atob(encodedString2));
    console.log(decodedString2); //"Hello, 中国！"
    ```

3. 绑定事件的不同种方式，执行顺序，事件委托

    * 参考链接：

        [看懂此文，不再困惑于javascript中的事件绑定、事件冒泡、事件捕获和事件执行顺序](https://blog.csdn.net/aitangyong/article/details/43231111)

        [js中的事件委托或是事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)

    3种方式：
    ```html
    <p id="btn" onclick="hello()"></p>
    <script>
        document.getElementById("btn").onclick = function(){}
        document.getElementById("btn").addEventListener("click",function(){})
    </script>
    ```
    其中addEventListener可重复绑定同一元素，先绑定先执行。

    对于层叠元素，则需要区分事件冒泡和事件捕获，冒泡：从底向面，捕获：从面向底。addEventListener((type, listener, useCapture)
    
    阻止冒泡：只执行当前元素事件，不执行层叠元素事件。event.stopPropagation()

    事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如ul下有很多li，逐一绑定事件很影响性能，且新li加入也要重新绑定事件，会十分麻烦，所以li事件需要委托其上一级ul代为执行事件。
    ```js
    window.onload = function(){
    　　var oUl = document.getElementById("ul1");
    　　oUl.onclick = function(ev){
    　　　　var ev = ev || window.event;
    　　　　var target = ev.target || ev.srcElement;
    　　　　if(target.nodeName.toLowerCase() == 'li'){
    　 　　　　　　	alert(123);
    　　　　　　　  alert(target.innerHTML);
    　　　　}
    　　}
    }
    ```

4. css旋转、拖拽、手势移动

    * 参考链接：

        [CSS3动画（360度旋转、旋转放大、放大、移动）](https://www.cnblogs.com/guozhe/p/5912664.html)

        [HTML5 CSS3 专题 : 拖放 （Drag and Drop）](https://www.cnblogs.com/wzjhoutai/p/6858022.html)

    关键词：transform,translate,scale,rotate,transition,animation,@keyframes,drag系列事件,cursor


5. http状态码和使用场景

    * 参考链接：

        [HTTP状态码（HTTP Status Code）及常用场景](https://www.cnblogs.com/QQParadise/p/5019860.html)

    ```txt
    常见状态码：
    HTTP: Status 200 – 服务器成功返回网页
    HTTP: Status 3xx - 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
    HTTP: Status 404 – 请求的网页不存在
    HTTP: Status 503 – 服务不可用
    ```

6. 前端截图上传服务器实现

    * 参考链接：

        [浅析 js 实现网页截图的两种方式](https://juejin.im/entry/58b91491570c35006c4f7fdf)

    6.1 canvas思路:(html2canvas)
    ```txt
    将dom转换成canvas图片。

    递归取出目标模版的所有DOM节点，填充到一个rederList，并附加是否为顶层元素/包含内容的容器 等信息

    通过z-index postion float等css属性和元素的层级信息将rederList排序，计算出一个canvas的renderQueue

    遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等

    将画好的canvas填充进页面
    ```
    优缺点:复杂度高，稳定性强。

    6.2 svg思路:(rasterizeHTML.js)
    ```txt
    svg的标签里有个foreignObject标签，可以加载其它命名空间的xml(xhtml)文档,只需要将要渲染的DOM扔进<foreignObject></foreignObject>，利用Blob构建svg图像。
    通过一系列的hack技巧替我们绕过了许多限制:
    1.将<img/>的url 转为 dataURI
    2.将background-color从style中取出，修改url后重新插入样式表
    3.将link的的样式通过ajax down下来然后注入<style></sytle>
    ```
    优缺点:简单，只能对已经存在的静态资源进行处理，而对js动态生成并不能实时处理。

    6.3 上传
    ```js
    var fd = new FormData();
    fd.append("img", imgBlob);
    $.ajax({
        type: "POST",
        url: "http://tmpfile.coding.io/img",
        dataType: 'json',
        data: fd,
        crossDomain: true,
        processData: false,
        contentType: false,
        success: function(data){
            if(data && data.path) {    
            console.log("http://tmpfile.coding.io/tmp" + data.path);
            }
        }
    });
    ```

7. 获取图片上传进度

    * 参考链接：

        [XHR简介](https://www.cnblogs.com/syfwhu/p/6116323.html)

        [深入理解ajax系列第一篇——XHR对象](https://www.cnblogs.com/yibutian/p/9456248.html)

        [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

        [使用原生JS 或jquery ajax 获取上传图片实时进度](https://segmentfault.com/a/1190000012871456)

        [JS、JQ实现图片上传，文件上传、带进度条上传的几种方法](https://blog.csdn.net/qq_38740171/article/details/82999793)

    * 常用只读属性：

        (1) XMLHttpRequest.readyState 返回unsigned short，状态码:
        * 0	UNSENT 代理被创建，但尚未调用 open() 方法。
        * 1	OPENED open() 方法已经被调用。
        * 2	HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。
        * 3	LOADING	下载中,responseText 属性已经包含部分数据。
        * 4	DONE 下载操作已完成。

        (2) XMLHttpRequest.response 返回ArrayBuffer、Blob、Document、DOMString，具体是哪种类型取决于XMLHttpRequest.responseType的值。其中包含响应体body。

        (3)XMLHttpRequest.responseText 返回string或null

        (4)XMLHttpRequest.responseURL 返回响应的序列化URL

        (5)XMLHttpRequest.responseXML 返回一个Document，其中包含该请求的响应
        * 如果响应的内容类型是'text/xml'或'application/xml'，这个属性中将保存着响应数据的XML DOM文档(document形式)

        (6)XMLHttpRequest.status 返回unsigned short，请求响应状态
        * UNSENT（未发送） 0
        * OPENED（已打开） 0
        * LOADING（载入中） 200
        * DONE（完成） 200

        (7)XMLHttpRequest.statusText 返回string，响应状态文本
        * UNSENT
        * OPENED
        * LOADING
        * DONE
        * OK
        * Not Found

    * 常用属性：

        (1) XMLHttpRequest.responseType 响应数据的类型：text、arraybuffer、blob、document、json

    * 常用方法：

        (1)XMLHttpRequest.abort() 中止请求

        (2)XMLHttpRequest.getAllResponseHeaders() 返回所有用CRLF分隔的响应头,string或null
        ```js
        var request = new XMLHttpRequest();
        request.open("GET", "foo.txt", true);
        request.send();

        request.onreadystatechange = function() {
        if(this.readyState == this.HEADERS_RECEIVED) {

            // Get the raw header string
            var headers = request.getAllResponseHeaders();

            // Convert the header string into an array
            // of individual headers
            var arr = headers.trim().split(/[\r\n]+/);

            // Create a map of header names to values
            var headerMap = {};
            arr.forEach(function (line) {
                var parts = line.split(': ');
                var header = parts.shift();
                var value = parts.join(': ');
                headerMap[header] = value;
            });

            var contentType = headerMap["content-type"];//text/html; charset=utf-8
        }

        /*
        date: Fri, 08 Dec 2017 21:04:30 GMT\r\n
        content-encoding: gzip\r\n
        x-content-type-options: nosniff\r\n
        server: meinheld/0.6.1\r\n
        x-frame-options: DENY\r\n
        content-type: text/html; charset=utf-8\r\n
        connection: keep-alive\r\n
        strict-transport-security: max-age=63072000\r\n
        vary: Cookie, Accept-Encoding\r\n
        content-length: 6502\r\n
        x-xss-protection: 1; mode=block\r\n
        */
        ```

        (3)XMLHttpRequest.getResponseHeader(name) 返回包含指定响应头的字符串,string或null，name如"Content-Type"

        (4)XMLHttpRequest.open(method, url, async, user, password) 初始化一个请求
        * method:get,post,put,delete
        * async:是否异步
        * user和password用于认证

        (5)XMLHttpRequest.overrideMimeType() 重写由服务器返回的MIME type,默认"text/xml"

        (6)XMLHttpRequest.send() 发送请求

        (7)XMLHttpRequest.setRequestHeader(header, value) 设置HTTP请求头的值

    * 事件：

        (1)onloadstart 开始

        (2)onprogress 数据传输进行中

        (3)onabort 终止

        (4)onerror 失败

        (5)onload 成功

        (6)ontimeout 超时

        (7)onloadend 完成（不论成功与否）

        (8)onreadystatechange readyState属性发生变化

    * 获取上传图片实时进度

    ```js
    $.ajax({
        url: 'URL',
        type: 'POST',
        data: data,
        processData: false, //用来回避jquery对formdata的默认序列化，XMLHttpRequest会对其进行正确处理  
        contentType: false, //设为false才会获得正确的conten-Type  
        xhr: function() { //用以显示上传进度  
            var xhr = $.ajaxSettings.xhr();
            if (xhr.upload) {
                xhr.upload.addEventListener('progress', function(event) {
                    var percent = Math.floor(event.loaded / event.total * 100);
                    $("#progress .progress-item").css("width",percent + "%");
                }, false);
            }
        },
        success: function(data) {

        }
    })

    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'url');
    // 上传完成后的回调函数
    xhr.onreadystatechange = function() {
        if (xhr.status === 200) {　　
            console.log(xhr.responseText);
        } else {　
            console.log('上传出错');
        }
    };
    // 获取上传进度
    xhr.upload.onprogress = function(event) {
        console.log(event.loaded)
        console.log(event.total)
        if (event.lengthComputable) {
            var percent = Math.floor(event.loaded / event.total * 100);
            document.querySelector("#progress .progress-item").style.width = percent + "%";
            // 设置进度显示
            console.log(percent)
        }
    };
    xhr.send(data);
    ```

8. 无限滚动

    * 参考链接：

        [原生js之列表优化-无限滚动实例](https://www.jianshu.com/p/f57272d4276d)

    关键词：onscroll,scrollTop

    onscroll 与 onwheel: onwheel是鼠标滚轮旋转, 而onscroll 处理的是对象内部内容区的滚动事件


9. 持久化存储

    * 参考链接：

        [持久化存储与HTTP缓存](https://www.jianshu.com/p/71163b408940)

        [理解cookie、session、localStorage、sessionStorage之不同](https://blog.csdn.net/qq_35585701/article/details/81393361)

    * LocalStorage

        关闭浏览器后，数据不会丢失
        ```js
        //1. 添加键、值
        localStorage.setItem(key, value)
        //2. 获得键、值
        localStorage.getItem(key)
        //3.清空localStorage
        localStorage.clear()
        ```
        特点：
        * LocalStorage跟HTTP无关，发送请求不会带上LocalStorage的值
        * 只有相同域名的页面才能互相读取LocalStorage
        * 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）
        * 常用场景：浏览器端储存数据（不能记录密码等敏感信息）
        * LocalStorage 永久有效，除非用户清理缓存

    * SessionStorage

        会话结束后，数据丢失
        ```js
        //1. 添加键、值
        sessionStorage.setItem(key, value)
        //2. 获得键、值
        sessionStorage.getItem(key)
        //3.清空sessionStorage
        sessionStorage.clear()
        ```
        特点同上

    * Cookie

        Cookie是存放在浏览器端的数据，每次都随请求发送给 Server。存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。

        特点：
        * 服务器通过 Set-Cookie 头给客户端一串字符串
        * 客户端每次访问相同域名的网页时，必须带上这段字符串
        * 客户端要在一段时间内保存这个Cookie
        * Cookie 默认在用户关闭页面后就失效，代码可以任意设置 Cookie 的过期时间，max-age和Expires
        * 大小大概在 4kb 以内

        ```js
        function setCookie(cname,cvalue,exdays)
        {
            var d = new Date();
            d.setTime(d.getTime()+(exdays*24*60*60*1000));
            var expires = "expires="+d.toGMTString();
            document.cookie = cname + "=" + cvalue + "; " + expires;
        }

        function getCookie(cname)
        {
            var name = cname + "=";
            var ca = document.cookie.split(';');
            for(var i=0; i<ca.length; i++) 
            {
                var c = ca[i].trim();
                if (c.indexOf(name)==0) return c.substring(name.length,c.length);
            }
            return "";
        }

        function delete(cname){ 
            var date = new Date(); 
            date.setTime(date.getTime()-10000); 
            document.cookie = cname + "=; expires =" + date.toGMTString();
        }
        ```

    * Session

        Session是基于Cookie实现的，它利用一个sessionId把用户的敏感数据隐藏起来，在Set-Cookie上，使用随机数来做sessionId,最终只是把这串随机数暴露给外界，而真正的信息却保存在了服务器端的sessions对象里面。它就像一个密码簿一样，有效的信息与sessionId一一对应,当下次用户访问该网站的其他页面的时候，就会带着登录时服务器给的这个sessionId。

        特点：
        * 将 SessionID（随机数）通过 Cookie 发给客户端
        * 客户端访问服务器时，服务器读取 SessionID
        * 服务器有一块内存（哈希表）保存了所有 session
        * 通过 SessionID 可以得到对应用户的隐私信息
        * 这块内存（哈希表）就是服务器上的所有 session

10. js数据类型与隐式转换：[]==false 和 !![]==true 和 [] == ![] == true

    * 参考链接：

        [JS的隐式转换 从 [] ==false 说起](https://www.cnblogs.com/nanchen/p/7905528.html)

        [JS中 [] == ![]结果为true，而 {} == !{}却为false， 追根刨底](https://blog.csdn.net/magic_xiang/article/details/83686224)

    * js数据类型

        原始值（primitives）：undefined， null， booleans， numbers，strings， symbol（es6）

        对象值（objects）：Object

    * 数学运算

        a+b=a的原数据类型+b的原数据类型

        有string为string，没string为number，[].toString()->""，{}.toString()->"[object Object]"

        * [] + [] = "" + "" = ""
        * [] + {} = "" + "[object Object]" = "[object Object]"

    * 比较运算

        * x===y,只有类型和值相等为true,否则为false
        * x == y
            * xy都为Null或undefined为true, null == undefined->true
            * x或y为NaN为false, NaN == NaN->false
            * 如果x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较
            * 如果存在Object，转换为原始值，比较
            * !可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余都为false

        
        |  value   |toNumber|    toString     |toBoolean|
        |----------|--------|-----------------|---------|
        |   NaN    |  NaN   |      "NaN"      |  false  |
        | Infinity |Infinity|    "Infinity"   |  true   |
        |    []    |   0    |        ""       |  true   |
        |   [1]    |   1    |       "1"       |  true   |
        |   null   |   0    |     "null"      |  false  |
        |undefined |  NaN   |   "undefined"   |  false  |
        |    {}    |  NaN   |"[object Object]"|  true   |
        |function()|  NaN   |   "function"    |  true   |

        ```txt
        []==false,[]==![],[]==0,''==0,""=="" true
        {}==false,{}==!{},{}==0,NaN==0 false
        ```

11. js事件循环机制 setTimeOut,setInterval,promise

    * 参考链接：

        [详解JavaScript中的Event Loop（事件循环）机制](https://www.cnblogs.com/cangqinglang/p/8967268.html)

        [谈谈 Event Loop（事件循环）机制](https://www.jianshu.com/p/6e9f4eb7fdbb)

        [Javascript异步编程之setTimeout与setInterval详解分析](https://www.cnblogs.com/tugenhua0707/p/4083475.html)

        [理解JavaScript 执行机制及异步回调（setTimeout/setInterval/Promise）](https://blog.csdn.net/zuggs_/article/details/82381558)

        [js 异步执行顺序](https://www.jianshu.com/p/ca480f9e7dea)

        [为什么要用setTimeout模拟setInterval?](https://blog.csdn.net/b954960630/article/details/82286486)

    * js是单线程的非阻塞语言：因为如果是多线程，一边绑定事件，一边移除元素，会引起冲突。

    * 执行栈：方法排队执行的地方，每个单元对应一个context，包含作用域中的this。

    * 事件队列：异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，再把事件放回执行栈。

    * 事件循环机制：由执行栈和事件队列构成的无限循环

    * 宏任务：setInterval()，setTimeout()
        * setTimeout：在指定的毫秒数后，将定时任务处理的函数添加到事件队列的队尾。
        * setInterval：按照指定的周期(以毫秒数计时)，将定时任务处理函数添加到事件队列的队尾。
            * 因为js是单线程的，如果处于堵塞状态计不了时，它必须依赖外部计时并触发定时，所以队列中的定时事件也是异步事件。
            * 每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。
            * setInterval有两个缺点：
                * 某些间隔会被跳过；
                * 可能多个定时器会连续执行；
            * setTimeout模拟setInterval,解决setInterval缺点
            ```js
            //每次执行的时候都会创建一个新的定时器
            var a = setTimeout(function () {
                // 任务
                setTimeout(a, interval);//获取当前函数的引用，并且为其设置另一个定时器
            }, interval)
            //在前一个定时器执行完前，不会向队列插入新的定时器
            //保证定时器间隔
            ```

    * 微任务：new Promise()
        * Promise是异步的，是指他的then()和catch()方法，Promise本身还是同步的
        * 有resolve()后，才能执行then(),有reject()，不执行then()

    * 事件优先级：同步任务>异步任务(微任务>宏任务(取决于延时时间))

    * Node.js是一个基于Chrome V8引擎的JavaScript运行环境，比js少了DOM/BOM,多了http/file system,事件执行顺序与js不同
        * 浏览器是先把一个栈以及栈中的微任务走完，才会走下一个栈。node 环境里面是把所以栈走完，才走微任务
        * setTimeout setImmediate 都是宏任务
        * nextTick和then都属于微任务
        * i/o 文件操作为宏任务

    * 例题：
    ```js
    //浏览器
    (function() {
        setTimeout(() => {
            console.log(0);
        });

        new Promise(resolve => {

            console.log(1);
            
            setTimeout(() => {
                resolve();
                Promise.resolve().then(() => {
                    console.log(2);
                    setTimeout(() => console.log(3));
                    Promise.resolve().then(() => console.log(4));
                });
            });

            Promise.resolve().then(() => console.log(5));

        }).then(() => {

            console.log(6);
            Promise.resolve().then(() => console.log(7));
            setTimeout(() => console.log(8));

        });

        console.log(9);
    })();
    //1、9、5、0、6、2、7、4、8、3
    //node.js
    console.log('1');
    setTimeout(function() {
        console.log('2');
        process.nextTick(function() {
            console.log('3');
        })
        new Promise(function(resolve) {
            console.log('4');
            resolve();
        }).then(function() {
            console.log('5')
        })
    })
    process.nextTick(function() {
        console.log('6');
    })
    new Promise(function(resolve) {
        console.log('7');
        resolve();
    }).then(function() {
        console.log('8')
    })
    setTimeout(function() {
        console.log('9');
        process.nextTick(function() {
            console.log('10');
        })
        new Promise(function(resolve) {
            console.log('11');
            resolve();
        }).then(function() {
            console.log('12')
        })
    })
    //1，7，6，8，2，4，3，5，9，11，10，12
    ```

12. c++和js区别
13. js继承
14. 闭包数据缓存
16. 页面生成过程
17. es6
18. http请求方式：get/post/put/delete
19. CMD原理
20. vue响应式原理

## 后端篇

1. 消息队列

    在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

    AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。

2. 存储过程

    * 参考链接：

        [存储过程和函数](https://www.cnblogs.com/doudouxiaoye/p/5811836.html)

    存储过程就是一条或多条SQL语句的集合，可视为批文件，但是起作用不仅限于批处理。

3. 数据库读写分离


## 服务器篇

1. linux服务器定时执行任务

    * 参考链接：

        [Centos7 利用crontab定时执行任务及配置方法](https://www.cnblogs.com/p0st/p/9482167.html)

        [CentOs 7.0实现定时任务（定时访问网页）](https://blog.csdn.net/qq_16505093/article/details/51478064)

    crond 和 crontab
    ```txt
    1、crontab -e，进入编辑界面 
    2、输入/2 * * * * curl http://www.baidu.com，表示每两分钟访问一次网页 
    3、保存退出，然后service crond start启动服务 
    4、chkconfig crond on设置开机自启动 
    5、 
    基本格式 : 
    *　　*　　*　　*　　*　　command 
    分　 时　 日　 月　 周　 命令 
    第1列表示分钟1～59 每分钟用或者 /1表示 
    第2列表示小时1～23（0表示0点） 
    第3列表示日期1～31 
    第4列表示月份1～12 
    第5列标识号星期0～6（0表示星期天）
    crond不支持精确到秒
    ```






