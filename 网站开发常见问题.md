# 网站开发常见问题

* [前端篇](#前端篇)
    * [unicode和utf编解码的原理和不同](#unicode和utf编解码的原理和不同)
    * [base64和二进制的不同](#base64和二进制的不同)
    * [绑定事件的不同种方式，执行顺序，事件委托](#绑定事件的不同种方式，执行顺序，事件委托)
    * [css旋转、拖拽、手势移动](#css旋转、拖拽、手势移动)
    * [http状态码和使用场景](#http状态码和使用场景)
    * [前端截图上传服务器实现](#前端截图上传服务器实现)
    * [获取图片上传进度](#获取图片上传进度)
    * [无限滚动](#无限滚动)
    * [持久化存储](#持久化存储)
    * [js数据类型与隐式转换](#js数据类型与隐式转换)
    * [js事件循环机制](#js事件循环机制)
    * [js继承](#js继承)
    * [闭包数据缓存](#闭包数据缓存)
    * [页面加载生成过程](#页面加载生成过程)
    * [http请求方式](#http请求方式)
    * [前端模块化](#前端模块化)
* [后端篇](#后端篇)
    * [消息队列](#消息队列)
    * [存储过程](#存储过程)
    * [数据库读写分离](#数据库读写分离)
* [服务器篇](#服务器篇)
    * [linux服务器定时执行任务](#linux服务器定时执行任务)

## 前端篇

### unicode和utf编解码的原理和不同

1. 参考链接：

    [Unicode和UTF-8字符串编码解码原理](https://blog.csdn.net/Enl0ve/article/details/82844484)

    [Unicode 和 UTF-8、UTF-16之间的区别](https://blog.csdn.net/zengchen__acmer/article/details/75332190)

    [【编码】ASCII、Unicode、GBK和UTF-8字符编码的区别联系](https://blog.csdn.net/u010262331/article/details/46013905)

    [各种常见编码的转换算法](https://blog.csdn.net/xiaolongwang2010/article/details/10311397)

2. 详解：

    Unicode是字符集，而UTF-8是编码规则

    字符集为每一个字符分配一个唯一的ID(学名为码位/码点/Code Point)，而「编码规则」则是将「码位」转换为字节序列的规则。

    起初Unicode规定每个字符都是用 2个字节来表示，但是由于英文字符等只需要一个字节就可以表，那就造成了在保存英文文本时，就会浪费一倍的空间。

    UTF-8是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

    ```txt
    例如「田」的码位是30000，记作U+7530(30000的16进制为0x7530)。
    U+ 0000 ~ U+ 007F: 0XXXXXXX
    U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
    U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
    U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
    
    根据上表中的编码规则，之前的「田」字的码位 U+7530 属于第三行的范围：
    
        7    5    3    0   
        0111 0101 0011 0000    二进制的 7530
    --------------------------
        0111   011111   100101 二进制的 77E5
    1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
    11100111 10010100 10110000 代入模版
    E   7    9   4    B   0
    
    这就是将 U+7530 按照 UTF-8 编码为字节序列 E794B0 的过程。反之亦然。
    ```

    UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。

### base64和二进制的不同

1. 参考链接：

    [让你完全理解base64是怎么回事](https://www.cnblogs.com/sweeeper/p/8462077.html)

    [一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770)

    [JavaScript用btoa和atob来编码解码Base64](https://my.oschina.net/itblog/blog/1613977)

    [原生JS实现base64解码与编码](https://imweb.io/topic/5b8ea5327cd95ea86319358a)

2. 详解：

    Base64编码可以将任意一组字节转换为较长的常见文本字符序列,将用户输入或二进制数据，打包成一种安全格式发送出去，无须担心其中包含冒号、换行符或二进制值等特殊字符。

    ```txt
    例子：输入Ow!

    (1) 字符串"Ow!"被拆分成3个8位的字节(0x4F、0x77、0x21)

    (2) 这3个字节构成了一个24为的二进制01001111 01110111 00100001

    (3) 这些为被划分为一些6位的序列010011、110111、011100、100001,(若不能正好平均分成每段6位，则按6和8的最小公倍数在末尾补0，位数为6和8的最小公倍数，000000用填充码=表示)

    (4) 每个6位值都表示了从0～63之间的数字，对应base64字母表中的64个字符之一。得到的base64编码字符串是4个字符的字符串“T3ch”。然后就可以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些移植性最好的字符(字母、数字等)。

    a:a -- 011000 010011 101001 100001 -- YTph

    a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==

    a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=

    a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 100001 -- YTphYWFh
    ```
    ```txt
    编码表：

    0　A　　17　R　　　34　i　　　51　z

    1　B　　18　S　　　35　j　　　52　0

    2　C　　19　T　　　36　k　　　53　1

    3　D　　20　U　　　37　l　　　54　2

    4　E　　21　V　　　38　m　　　55　3

    5　F　　22　W　　　39　n　　　56　4

    6　G　　23　X　　　40　o　　　57　5

    7　H　　24　Y　　　41　p　　　58　6

    8　I　　25　Z　　　42　q　　　59　7

    9　J　　26　a　　　43　r　　　60　8

    10　K　　27　b　　　44　s　　　61　9

    11　L　　28　c　　　45　t　　　62　+

    12　M　　29　d　　　46　u　　　63　/

    13　N　　30　e　　　47　v

    14　O　　31　f　　　48　w　　　

    15　P　　32　g　　　49　x

    16　Q　　33　h　　　50　y
    ```
    btoa和atob是window对象的两个函数，其中btoa是binary to ascii，用于将binary的数据用ascii码表示，即Base64的编码过程，而atob则是ascii to binary，用于将ascii码解析成binary数据
    ```js
    //方法实现
    var a = 'Hello World!';
    var encodedString = btoa(string);
    console.log(encodedString); // Outputs: "SGVsbG8gV29ybGQh"
    var decodedString = atob(encodedString);
    console.log(decodedString); // Outputs: "Hello World!"
    //涉及中文时，需要encodeURIComponent
    var b = "Hello, 中国！";
    //"SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE="
    var encodedString2 = btoa(encodeURIComponent(b));
    var decodedString2 = decodeURIComponent(atob(encodedString2));
    console.log(decodedString2); //"Hello, 中国！"
    ```

### 绑定事件的不同种方式，执行顺序，事件委托

1. 参考链接：

    [看懂此文，不再困惑于javascript中的事件绑定、事件冒泡、事件捕获和事件执行顺序](https://blog.csdn.net/aitangyong/article/details/43231111)

    [js中的事件委托或是事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)

2. 详解：

    3种方式：
    ```html
    <p id="btn" onclick="hello()"></p>
    <script>
        document.getElementById("btn").onclick = function(){}
        document.getElementById("btn").addEventListener("click",function(){})
    </script>
    ```
    其中addEventListener可重复绑定同一元素，先绑定先执行。

    对于层叠元素，则需要区分事件冒泡和事件捕获，冒泡：从底向面，捕获：从面向底。addEventListener((type, listener, useCapture)
    
    阻止冒泡：只执行当前元素事件，不执行层叠元素事件。event.stopPropagation()

    事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如ul下有很多li，逐一绑定事件很影响性能，且新li加入也要重新绑定事件，会十分麻烦，所以li事件需要委托其上一级ul代为执行事件。
    ```js
    window.onload = function(){
    　　var oUl = document.getElementById("ul1");
    　　oUl.onclick = function(ev){
    　　　　var ev = ev || window.event;
    　　　　var target = ev.target || ev.srcElement;
    　　　　if(target.nodeName.toLowerCase() == 'li'){
    　 　　　　　　	alert(123);
    　　　　　　　  alert(target.innerHTML);
    　　　　}
    　　}
    }
    ```

### css旋转、拖拽、手势移动

1. 参考链接：

    [CSS3动画（360度旋转、旋转放大、放大、移动）](https://www.cnblogs.com/guozhe/p/5912664.html)

    [HTML5 CSS3 专题 : 拖放 （Drag and Drop）](https://www.cnblogs.com/wzjhoutai/p/6858022.html)

2. 详解：

    关键词：transform,translate,scale,rotate,transition,animation,@keyframes,drag系列事件,cursor


### http状态码和使用场景

1. 参考链接：

    [HTTP状态码（HTTP Status Code）及常用场景](https://www.cnblogs.com/QQParadise/p/5019860.html)

2. 详解：
    ```txt
    常见状态码：
    HTTP: Status 200 – 服务器成功返回网页
    HTTP: Status 3xx - 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
    HTTP: Status 404 – 请求的网页不存在
    HTTP: Status 503 – 服务不可用
    ```

### 前端截图上传服务器实现

1. 参考链接：

    [浅析 js 实现网页截图的两种方式](https://juejin.im/entry/58b91491570c35006c4f7fdf)

2. 详解：

    * canvas思路:(html2canvas)
    ```txt
    将dom转换成canvas图片。

    递归取出目标模版的所有DOM节点，填充到一个rederList，并附加是否为顶层元素/包含内容的容器 等信息

    通过z-index postion float等css属性和元素的层级信息将rederList排序，计算出一个canvas的renderQueue

    遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等

    将画好的canvas填充进页面
    ```
    优缺点:复杂度高，稳定性强。

    * svg思路:(rasterizeHTML.js)
    ```txt
    svg的标签里有个foreignObject标签，可以加载其它命名空间的xml(xhtml)文档,只需要将要渲染的DOM扔进<foreignObject></foreignObject>，利用Blob构建svg图像。
    通过一系列的hack技巧替我们绕过了许多限制:
    1.将<img/>的url 转为 dataURI
    2.将background-color从style中取出，修改url后重新插入样式表
    3.将link的的样式通过ajax down下来然后注入<style></sytle>
    ```
    优缺点:简单，只能对已经存在的静态资源进行处理，而对js动态生成并不能实时处理。

    * 上传
    ```js
    var fd = new FormData();
    fd.append("img", imgBlob);
    $.ajax({
        type: "POST",
        url: "http://tmpfile.coding.io/img",
        dataType: 'json',
        data: fd,
        crossDomain: true,
        processData: false,
        contentType: false,
        success: function(data){
            if(data && data.path) {    
            console.log("http://tmpfile.coding.io/tmp" + data.path);
            }
        }
    });
    ```

### 获取图片上传进度

1. 参考链接：

    [XHR简介](https://www.cnblogs.com/syfwhu/p/6116323.html)

    [深入理解ajax系列第一篇——XHR对象](https://www.cnblogs.com/yibutian/p/9456248.html)

    [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

    [使用原生JS 或jquery ajax 获取上传图片实时进度](https://segmentfault.com/a/1190000012871456)

    [JS、JQ实现图片上传，文件上传、带进度条上传的几种方法](https://blog.csdn.net/qq_38740171/article/details/82999793)

2. 详解：

    * 常用只读属性：

        (1) XMLHttpRequest.readyState 返回unsigned short，状态码:
        * 0	UNSENT 代理被创建，但尚未调用 open() 方法。
        * 1	OPENED open() 方法已经被调用。
        * 2	HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。
        * 3	LOADING	下载中,responseText 属性已经包含部分数据。
        * 4	DONE 下载操作已完成。

        (2) XMLHttpRequest.response 返回ArrayBuffer、Blob、Document、DOMString，具体是哪种类型取决于XMLHttpRequest.responseType的值。其中包含响应体body。

        (3)XMLHttpRequest.responseText 返回string或null

        (4)XMLHttpRequest.responseURL 返回响应的序列化URL

        (5)XMLHttpRequest.responseXML 返回一个Document，其中包含该请求的响应
        * 如果响应的内容类型是'text/xml'或'application/xml'，这个属性中将保存着响应数据的XML DOM文档(document形式)

        (6)XMLHttpRequest.status 返回unsigned short，请求响应状态
        * UNSENT（未发送） 0
        * OPENED（已打开） 0
        * LOADING（载入中） 200
        * DONE（完成） 200

        (7)XMLHttpRequest.statusText 返回string，响应状态文本
        * UNSENT
        * OPENED
        * LOADING
        * DONE
        * OK
        * Not Found

    * 常用属性：

        (1) XMLHttpRequest.responseType 响应数据的类型：text、arraybuffer、blob、document、json

    * 常用方法：

        (1)XMLHttpRequest.abort() 中止请求

        (2)XMLHttpRequest.getAllResponseHeaders() 返回所有用CRLF分隔的响应头,string或null
        ```js
        var request = new XMLHttpRequest();
        request.open("GET", "foo.txt", true);
        request.send();

        request.onreadystatechange = function() {
        if(this.readyState == this.HEADERS_RECEIVED) {

            // Get the raw header string
            var headers = request.getAllResponseHeaders();

            // Convert the header string into an array
            // of individual headers
            var arr = headers.trim().split(/[\r\n]+/);

            // Create a map of header names to values
            var headerMap = {};
            arr.forEach(function (line) {
                var parts = line.split(': ');
                var header = parts.shift();
                var value = parts.join(': ');
                headerMap[header] = value;
            });

            var contentType = headerMap["content-type"];//text/html; charset=utf-8
        }

        /*
        date: Fri, 08 Dec 2017 21:04:30 GMT\r\n
        content-encoding: gzip\r\n
        x-content-type-options: nosniff\r\n
        server: meinheld/0.6.1\r\n
        x-frame-options: DENY\r\n
        content-type: text/html; charset=utf-8\r\n
        connection: keep-alive\r\n
        strict-transport-security: max-age=63072000\r\n
        vary: Cookie, Accept-Encoding\r\n
        content-length: 6502\r\n
        x-xss-protection: 1; mode=block\r\n
        */
        ```

        (3)XMLHttpRequest.getResponseHeader(name) 返回包含指定响应头的字符串,string或null，name如"Content-Type"

        (4)XMLHttpRequest.open(method, url, async, user, password) 初始化一个请求
        * method:get,post,put,delete
        * async:是否异步
        * user和password用于认证

        (5)XMLHttpRequest.overrideMimeType() 重写由服务器返回的MIME type,默认"text/xml"

        (6)XMLHttpRequest.send() 发送请求

        (7)XMLHttpRequest.setRequestHeader(header, value) 设置HTTP请求头的值

    * 事件：

        (1)onloadstart 开始

        (2)onprogress 数据传输进行中

        (3)onabort 终止

        (4)onerror 失败

        (5)onload 成功

        (6)ontimeout 超时

        (7)onloadend 完成（不论成功与否）

        (8)onreadystatechange readyState属性发生变化

    * 获取上传图片实时进度

    ```js
    $.ajax({
        url: 'URL',
        type: 'POST',
        data: data,
        processData: false, //用来回避jquery对formdata的默认序列化，XMLHttpRequest会对其进行正确处理  
        contentType: false, //设为false才会获得正确的conten-Type  
        xhr: function() { //用以显示上传进度  
            var xhr = $.ajaxSettings.xhr();
            if (xhr.upload) {
                xhr.upload.addEventListener('progress', function(event) {
                    var percent = Math.floor(event.loaded / event.total * 100);
                    $("#progress .progress-item").css("width",percent + "%");
                }, false);
            }
        },
        success: function(data) {

        }
    })

    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'url');
    // 上传完成后的回调函数
    xhr.onreadystatechange = function() {
        if (xhr.status === 200) {　　
            console.log(xhr.responseText);
        } else {　
            console.log('上传出错');
        }
    };
    // 获取上传进度
    xhr.upload.onprogress = function(event) {
        console.log(event.loaded)
        console.log(event.total)
        if (event.lengthComputable) {
            var percent = Math.floor(event.loaded / event.total * 100);
            document.querySelector("#progress .progress-item").style.width = percent + "%";
            // 设置进度显示
            console.log(percent)
        }
    };
    xhr.send(data);
    ```

### 无限滚动

1. 参考链接：

    [原生js之列表优化-无限滚动实例](https://www.jianshu.com/p/f57272d4276d)

2. 详解：

    关键词：onscroll,scrollTop

    onscroll 与 onwheel: onwheel是鼠标滚轮旋转, 而onscroll 处理的是对象内部内容区的滚动事件


### 持久化存储

1. 参考链接：

    [持久化存储与HTTP缓存](https://www.jianshu.com/p/71163b408940)

    [理解cookie、session、localStorage、sessionStorage之不同](https://blog.csdn.net/qq_35585701/article/details/81393361)

2. 详解：

    * LocalStorage

        关闭浏览器后，数据不会丢失
        ```js
        //1. 添加键、值
        localStorage.setItem(key, value)
        //2. 获得键、值
        localStorage.getItem(key)
        //3.清空localStorage
        localStorage.clear()
        ```
        特点：
        * LocalStorage跟HTTP无关，发送请求不会带上LocalStorage的值
        * 只有相同域名的页面才能互相读取LocalStorage
        * 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）
        * 常用场景：浏览器端储存数据（不能记录密码等敏感信息）
        * LocalStorage 永久有效，除非用户清理缓存

    * SessionStorage

        会话结束后，数据丢失
        ```js
        //1. 添加键、值
        sessionStorage.setItem(key, value)
        //2. 获得键、值
        sessionStorage.getItem(key)
        //3.清空sessionStorage
        sessionStorage.clear()
        ```
        特点同上

    * Cookie

        Cookie是存放在浏览器端的数据，每次都随请求发送给 Server。存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。

        特点：
        * 服务器通过 Set-Cookie 头给客户端一串字符串
        * 客户端每次访问相同域名的网页时，必须带上这段字符串
        * 客户端要在一段时间内保存这个Cookie
        * Cookie 默认在用户关闭页面后就失效，代码可以任意设置 Cookie 的过期时间，max-age和Expires
        * 大小大概在 4kb 以内

        ```js
        function setCookie(cname,cvalue,exdays)
        {
            var d = new Date();
            d.setTime(d.getTime()+(exdays*24*60*60*1000));
            var expires = "expires="+d.toGMTString();
            document.cookie = cname + "=" + cvalue + "; " + expires;
        }

        function getCookie(cname)
        {
            var name = cname + "=";
            var ca = document.cookie.split(';');
            for(var i=0; i<ca.length; i++) 
            {
                var c = ca[i].trim();
                if (c.indexOf(name)==0) return c.substring(name.length,c.length);
            }
            return "";
        }

        function delete(cname){ 
            var date = new Date(); 
            date.setTime(date.getTime()-10000); 
            document.cookie = cname + "=; expires =" + date.toGMTString();
        }
        ```

    * Session

        Session是基于Cookie实现的，它利用一个sessionId把用户的敏感数据隐藏起来，在Set-Cookie上，使用随机数来做sessionId,最终只是把这串随机数暴露给外界，而真正的信息却保存在了服务器端的sessions对象里面。它就像一个密码簿一样，有效的信息与sessionId一一对应,当下次用户访问该网站的其他页面的时候，就会带着登录时服务器给的这个sessionId。

        特点：
        * 将 SessionID（随机数）通过 Cookie 发给客户端
        * 客户端访问服务器时，服务器读取 SessionID
        * 服务器有一块内存（哈希表）保存了所有 session
        * 通过 SessionID 可以得到对应用户的隐私信息
        * 这块内存（哈希表）就是服务器上的所有 session

### js数据类型与隐式转换

1. 参考链接：

    [JS的隐式转换 从 [] ==false 说起](https://www.cnblogs.com/nanchen/p/7905528.html)

    [JS中 [] == ![]结果为true，而 {} == !{}却为false， 追根刨底](https://blog.csdn.net/magic_xiang/article/details/83686224)

2. 详解：

    * js数据类型

        原始值（primitives）：undefined， null， booleans， numbers，strings， symbol（es6）

        对象值（objects）：Object

    * 数学运算

        a+b=a的原数据类型+b的原数据类型

        有string为string，没string为number，[].toString()->""，{}.toString()->"[object Object]"

        * [] + [] = "" + "" = ""
        * [] + {} = "" + "[object Object]" = "[object Object]"

    * 比较运算

        * x===y,只有类型和值相等为true,否则为false
        * x == y
            * xy都为Null或undefined为true, null == undefined->true
            * x或y为NaN为false, NaN == NaN->false
            * 如果x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较
            * 如果存在Object，转换为原始值，比较
            * !可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余都为false

        
        |  value   |toNumber|    toString     |toBoolean|
        |----------|--------|-----------------|---------|
        |   NaN    |  NaN   |      "NaN"      |  false  |
        | Infinity |Infinity|    "Infinity"   |  true   |
        |    []    |   0    |        ""       |  true   |
        |   [1]    |   1    |       "1"       |  true   |
        |   null   |   0    |     "null"      |  false  |
        |undefined |  NaN   |   "undefined"   |  false  |
        |    {}    |  NaN   |"[object Object]"|  true   |
        |function()|  NaN   |   "function"    |  true   |

        ```txt
        []==false,[]==![],[]==0,''==0,""=="" true
        {}==false,{}==!{},{}==0,NaN==0 false
        ```

### js事件循环机制

1. 参考链接：

    [详解JavaScript中的Event Loop（事件循环）机制](https://www.cnblogs.com/cangqinglang/p/8967268.html)

    [谈谈 Event Loop（事件循环）机制](https://www.jianshu.com/p/6e9f4eb7fdbb)

    [Javascript异步编程之setTimeout与setInterval详解分析](https://www.cnblogs.com/tugenhua0707/p/4083475.html)

    [理解JavaScript 执行机制及异步回调（setTimeout/setInterval/Promise）](https://blog.csdn.net/zuggs_/article/details/82381558)

    [js 异步执行顺序](https://www.jianshu.com/p/ca480f9e7dea)

    [为什么要用setTimeout模拟setInterval?](https://blog.csdn.net/b954960630/article/details/82286486)

2. 详解：

    * js是单线程的非阻塞语言：因为如果是多线程，一边绑定事件，一边移除元素，会引起冲突。

    * 执行栈：方法排队执行的地方，每个单元对应一个context，包含作用域中的this。

    * 事件队列：异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，再把事件放回执行栈。

    * 事件循环机制：由执行栈和事件队列构成的无限循环

    * 宏任务：setInterval()，setTimeout()
        * setTimeout：在指定的毫秒数后，将定时任务处理的函数添加到事件队列的队尾。
        * setInterval：按照指定的周期(以毫秒数计时)，将定时任务处理函数添加到事件队列的队尾。
            * 因为js是单线程的，如果处于堵塞状态计不了时，它必须依赖外部计时并触发定时，所以队列中的定时事件也是异步事件。
            * 每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。
            * setInterval有两个缺点：
                * 某些间隔会被跳过；
                * 可能多个定时器会连续执行；
            * setTimeout模拟setInterval,解决setInterval缺点
            ```js
            //每次执行的时候都会创建一个新的定时器
            var a = setTimeout(function () {
                // 任务
                setTimeout(a, interval);//获取当前函数的引用，并且为其设置另一个定时器
            }, interval)
            //在前一个定时器执行完前，不会向队列插入新的定时器
            //保证定时器间隔
            ```

    * 微任务：new Promise()
        * Promise是异步的，是指他的then()和catch()方法，Promise本身还是同步的
        * 有resolve()后，才能执行then(),有reject()，不执行then()

    * 事件优先级：同步任务>异步任务(微任务>宏任务(取决于延时时间))

    * Node.js是一个基于Chrome V8引擎的JavaScript运行环境，比js少了DOM/BOM,多了http/file system,事件执行顺序与js不同
        * 浏览器是先把一个栈以及栈中的微任务走完，才会走下一个栈。node 环境里面是把所以栈走完，才走微任务
        * setTimeout setImmediate 都是宏任务
        * nextTick和then都属于微任务
        * i/o 文件操作为宏任务

    * 例题：
    ```js
    //浏览器
    (function() {
        setTimeout(() => {
            console.log(0);
        });

        new Promise(resolve => {

            console.log(1);
            
            setTimeout(() => {
                resolve();
                Promise.resolve().then(() => {
                    console.log(2);
                    setTimeout(() => console.log(3));
                    Promise.resolve().then(() => console.log(4));
                });
            });

            Promise.resolve().then(() => console.log(5));

        }).then(() => {

            console.log(6);
            Promise.resolve().then(() => console.log(7));
            setTimeout(() => console.log(8));

        });

        console.log(9);
    })();
    //1、9、5、0、6、2、7、4、8、3
    //node.js
    console.log('1');
    setTimeout(function() {
        console.log('2');
        process.nextTick(function() {
            console.log('3');
        })
        new Promise(function(resolve) {
            console.log('4');
            resolve();
        }).then(function() {
            console.log('5')
        })
    })
    process.nextTick(function() {
        console.log('6');
    })
    new Promise(function(resolve) {
        console.log('7');
        resolve();
    }).then(function() {
        console.log('8')
    })
    setTimeout(function() {
        console.log('9');
        process.nextTick(function() {
            console.log('10');
        })
        new Promise(function(resolve) {
            console.log('11');
            resolve();
        }).then(function() {
            console.log('12')
        })
    })
    //1，7，6，8，2，4，3，5，9，11，10，12
    ```

### js继承

1. 参考链接：

    [js各种继承方式和优缺点的介绍](https://www.cnblogs.com/lanyueff/p/7792009.html)

    [js中实现继承的几种方式](https://www.cnblogs.com/diligentYe/p/6413450.html)

2. 详解：

    ```js
    //父类
    function Parent(name) {
        this.name = name;
        this.color = ['pink', 'red'];
    }
    Parent.prototype.sayHi = function() {
        console.log('Hi');
    }

    //1.原型链(单例模式)
    //(1):属性被所有实例共享(单例，new多个child，数据是互通的，改动其中一个，其它数据会跟着变化)
    //(2):无法向父类种传参
    function Child() {

    }
    Child.prototype = new Parent();
    var child = new Child();
    child.sayHi();

    //2.构造函数:解决原型链的2个问题,但方法都在构造函数中定义，每次创建实例都会创建一遍方法
    function Child(name) {
        Parent.call(this, name);
        this.value = 'test';
    }
    var child = new Child('qq');

    //3.组合继承:解决原型链的2个问题,但创建一次实例时，两次调用了父类构造函数
    function Child() {
        Parent.call(this);
        this.value = 'test';
    }
    Child.prototype = new Parent();
    var child1 = new Child();
    var child2 = new Child();

    //4.寄生式继承(工厂模式)
    function createAnother(o) {
        var another = new Object(o);
        o.sayHi = function() {
            console.log('Hi');
        }
        return another;
    }

    //5.寄生组合式继承
    // 创建只继承原型对象的函数
    function inheritPrototype(parent, child) {
        var prototype = new Object(parent.prototype);
        prototype.constructor = child;
        child.prototype = prototype;
    }
    function Parent() {
        this.color = ['pink', 'red'];
    }
    Parent.prototype.sayHi = function() {
        console.log('Hi');
    }
    function Child() {
        Parent.call(this);
    }
    inheritPrototype(Parent, Child);

    //6.原型式继承
    function createAnother(o) {
        function F() {}
        F.prototype = o;
        return new F();
    }
    function prototype(child, parent) {
        var prototype = createAnother(parent.prototype);
        prototype.constructor = child;
        child.prototype = prototype;
    }
    prototype(Child, Parent);
    ```

### 闭包数据缓存

1. 参考链接：

    [JS闭包异步获取数据并缓存](https://blog.csdn.net/weixin_43820866/article/details/87107035)

    [js async await 终极异步解决方案](https://www.cnblogs.com/CandyManPing/p/9384104.html)

2. 详解：

    向接口请求数据时，数据多次使用，但不想保存在全局变量中，就需要将数据存储在缓存中。查找数据时，如果缓存找不到，则调用API，然后设置缓存，如果找到，直接返回查找到的值即可。闭包正好可以做到这一点，且不会释放外部的引用，从而函数内部的值可以得以保留。

    ```js
    const getList = (function() {
        // 闭包存储data
        let data = {};
        const getData = () => {
            return new Promise((resolve, reject) => {
                $.ajax({
                    url: '/your/api',
                    data: {
                        normal: 1
                    },
                    success: function (result) {
                        data = result.data;
                        resolve();
                    }
                });
            })
        }
        // 异步函数，当调用一个 async 函数时，会返回一个 Promise 对象。
        const result = async function (type) {
            if (JONS.stringify(data) === '{}') {
                //await 只能出现在 async 函数中。
                await getData();//等待异步操作执行完成，再执行后面的操作，相当于把后面的代码写在success里，但用await会比较简洁
                //如果 async 函数没有返回值，它会返回 Promise.resolve(undefined)。如果有返回值data，就会resolve(data),把data传入then
                //当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。
                return data;
            } else {
                return data;
            }
        }

        return result;
    })();

    // 第一次调用通过api请求数据
    getList().then(res => {
        console.log(res);

        // 第二次调用则直接拿取缓存数据
        getList().then(res => {
            console.log(res);
        }
    });
    ```

### 页面加载生成过程

1. 参考链接：

    [网页生成过程及重排和重绘](https://blog.csdn.net/qq_41635167/article/details/83932920)

    [web页面加载、解析、渲染过程](https://www.cnblogs.com/CandyManPing/p/6635008.html)

    [从输入URL到页面加载的全过程](https://www.cnblogs.com/xiaohuochai/p/9193083.html)

2. 详解：

    浏览器：
    * 输入网址
    * 浏览器通过DNS查找域名的IP地址
    * 浏览器给web服务器发送一个HTTP请求（TCP三次握手，四次挥手）
    * 服务器处理请求，响应HTML
    * 浏览器开始显示HTML
    * 页面加载时遇到CSS/JS/图片等资源会发送请求获取

    页面：
    * 解析html：HTML代码转化成DOM
    * 解析css/js：CSS代码转化成CSSOM（CSS Object Model）、js处理后产生一棵节点带CSS Style、会响应自定义事件的Styled DOM树
    * 构建render树：结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
    * 渲染排列：生成布局（layout），即将所有渲染树的所有节点进行平面合成，主要影响性能的地方
    * 渲染绘制：将布局绘制（paint）在屏幕上，主要影响性能的地方

    重排：DOM结构发生变化（js操作：事件、增减移动元素）

    重绘：DOM、CSS发生变化（js操作：事件、增减移动元素、元素样式变化）

### http请求方式

1. 参考链接：

    [HTTP请求方法详解](https://www.cnblogs.com/foodoir/p/5911099.html)

    [HTTP协议以及HTTP请求中8种请求方法](https://blog.csdn.net/qq_38191191/article/details/78671063)

    [RESTful介绍和使用教程](https://blog.csdn.net/x541211190/article/details/81141459)

2. 详解：

    * 8种请求方法

        * get

        获取资源:URL提交数据，但是不同的浏览器对于URL是有限制的,IE传输的数据量一般限制在2KB

        * post

        传输实体文本:提交的数据放置在HTTP报文实体的主体里,安全性比GET方法要高,POST数据大小无限制

        * head

        获得报文首部:用于确认URI的有效性及资源更新的日期时间

        * put

        传输文件:用来传输文件,保存在请求URI指定的位置,HTTP/1.1的PUT方法自身不带验证机制,存在安全问题

        * delete

        删除文件:按URI删除指定资源

        * options

        询问支持的方法:查询针对请求URI指定资源支持的方法（客户端询问服务器可以提交哪些请求方法）

        * trace

        追踪路径:对请求消息的传输路径进行追踪，TRACE方法是让Web服务器端将之前的请求通信还给客户端的方法

        * connect

        用隧道协议连接代理:主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输

    * restful

        基于HTTP、URI、XML、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是Web服务的一种新的架构风格。

        * 对网络上所有的资源都有一个Url（通用资源标志符）

        * 对资源的操作不会改变Url

        * 同一资源有多种表现形式
        
            xml、json

        * 所有操作都是无状态的

            基于接口：客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前的请求，不需了解请求的历史。可以更容易的释放资源，让服务器利用Pool（连接池）技术来提高稳定性和性能。

        * 资源操作
            * get->select
            * post->insert
            * put->update
            * delete->delete

### 前端模块化

1. 参考链接：

    [前端模块化（CommonJS,AMD和CMD）](https://www.jianshu.com/p/735781477d28)

    [前端模块化，AMD与CMD的区别](https://www.cnblogs.com/futai/p/5258349.html)

    [前端模块化之AMD与CMD原理](https://blog.csdn.net/weixin_33947521/article/details/88001955)

    [requireJS原理解析](https://blog.csdn.net/cde7070/article/details/65935888)

    [CommonJs、AMD、CMD、Webpack](https://blog.csdn.net/weixin_41143293/article/details/79662362)

2. 详解：

    * 模块化为了解决js相互引用产生的问题，如：

        * 顺序引入：先引入jquery，才能引入其它js
        * 同步加载：1.js加载并执行完，才加载2.js
        * window全局变量污染

    * 模块：

        * 普通函数
        * 对象
        * 立即执行函数

    * 在webpack出现前的2种前端模块化工具（代码模块化，执行上没有区别）

        * AMD：异步模块定义，使用require.js

            采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行，避免顺序引入和同步加载的问题。

            * 用法：
            ```js
            // 1.js 中（入口用require，其他用define）
            require(['2.js'], function(A) {
                // A得到的就是2.js模块的返回值
                // 主要的执行代码
                // 2.js 3.js都加载完，才执行1.js的这回调函数
            })

            // 2.js 中
            define(['3.js', 'xxxx.js'], functionA(B, C) {
                // B得到的就是3.js模块的返回值，C是xxxx.js的
                return aaaaa;    // 2.js 模块的返回值
            })

            // 3.js 中
            define([], functionA() {
                
                retrun {}   // 3.js 模块的返回值
            })
            ```

            * 原理：

                * 块依赖加载之后，如何调用回调函数

                    使用requireJs时，都是在页面上只引入一个require.js，把data-main指向我们的main.js

                    运行main.js时，执行里面的require和define方法，requireJs会把这些依赖和回调方法都用一个数据结构存起来

                    然后使用script来加载这些模块依赖，并且监听load函数，且每个script元素都会有一个自定义的属性，用来指明模块名

                    当模块加载成功之后，可以通过元素属性来获取模块名，接着通过模块名来获取模块的定义，接着对模块进行初始化，再对子模块重复操作

                    当子模块没有其他要加载的依赖的时候这个时候表明子模块已经加载完毕，调用回调函数

                * 加载依赖之后，如何将接口暴露给回调函数

                    当执行回调函数的时候，会使用apply将模块定义中的接口，传递给回调函数

                * 如何解决循环依赖的问题

                    将已定义的模块保存在一个对象中，当加载模块依赖的时候，如果在这个对象中存在的话，则直接返回这个模块。否则的话，则再走一遍加载的模块的流程。
                
            * 代码：
            ```js
            var modules = {},	// 存放所有文件模块的信息，每个js文件模块的信息
            loadings = [];	//	存放所有已经加载了的文件模块的id，一旦该id的所有依赖都加载完后，该id将会在数组中移除

            // 上面说了，每个文件模块都要有个id，这个函数是返回当前运行的js文件的文件名，拿文件名作为文件对象的id
            // 比如，当前加载 3.js 后运行 3.js ，那么该函数返回的就是 '3.js'
            function getCurrentJs() {
                return document.currentScript.src
            }
            // 创建节点
            function createNode() {
                var node = document.createElement('script')
                node.type = 'text/javascript'
                node.async = true;
                return node
            }
            // 开始运行
            function init() {
                // 加载 1.js
                loadJs('1.js')
            }	
            // 加载文件(插入dom中)，如果传了回调函数，则在onload后执行回调函数
            function loadJs(url, callback) {
                var node = createNode()
                node.src = url;
                node.setAttribute('data-id', url)
                node.addEventListener('load', function(evt) {
                    var e = evt.target
                    setTimeout(() => {  // 这里延迟一秒，只是让在浏览器上直观的看到每1秒加载出一个文件
                        callback && callback(e)
                    }, 1000)
                }, false)
                
                document.body.appendChild(node)
            }	
                
            // 此时，loadJs(1.js)后，并没有传回调函数，所以1.js加载成功后只是自动运行1.js代码
            // 而1.js代码中，是require( ['2.js', 'xxx.js'], functionA（B, C）{} )，则执行的是require函数, 在下面是require的定义

            window.require = function(deps, callback) {
                // deps 就是对应的 ['2.js', 'xxx.js']
                // callback 就是对应的 functionA
                // 在这里，是不会运行callback的(即模块的运行！)，得等到所有依赖都加载完的啊
                // 所以得有个地方，把一个文件的所有信息都先存起来啊，尤其是deps和callback
                var id = getCurrentJs();// 当前运行的是1.js，所以id就是'1.js'
                if(!modules.id) {
                    modules[id] = { // 该模块对象信息
                        id: id,
                        deps: deps,
                        callback: callback, 
                        exports: null,  // 该模块的返回值return ，
                        就是functionA(B, C)运行后的返回值，仔细想想？在后面的getExports中详细讲
                        
                        status: 1, 
                        
                    }
                    loadings.unshift(id); // 加入这个id，之后会循环loadings数组，递归判断id所有依赖
                }
                
                loadDepsJs(id); // 加载这个文件的所有依赖,即去加载[2.js]
            }

            function loadDepsJs(id) {
                var module = modules[id]; // 获取到这个文件模块对象
                // deps是['2.js']
                module.deps.map(item => {   // item 其实是依赖的Id，即 '2.js'
                    if(!modules[i]) {   // 如果这个文件没被加载过（注：加载过的肯定在modules中有）
                    （1）    loadJs(item, function() {   // 加载 2.js，并且传了个回调，准备要递归了
                                // 2.js加载完后，执行了这个回调函数
                                loadings.unshift(item); // 此时里面有两个了, 1.js 和 2.js
                                // 递归。。。要去搞3.js了
                                loadDepsJs(item)// item传的2.js，递归再进来时，就去modules中取2.js的deps了
                                // 每次检查一下，是否都加载完了
                                checkDeps(); // 循环loadings，配合递归嵌套和modules信息，判断是否都加载完了
                            })
                    }
                })
            }

            // 上面（1）那里，加载了2.js后马上会运行2.js的，而2.js里面是
            define(['js'], fn)
            // 所以相当于执行了 define函数

            window.define = function(deps,callback) {
                var id = getCurrentJs()
                if(!modules.id) {
                    modules[id] = {
                        id: id,
                        deps: getDepsIds(deps),
                        callback: callback,
                        exports: null,
                        status: 1,
                        
                    }
                }
            }

            // 注意，define运行的结果，只是在modules中添加了该模块的信息
            // 因为其实在上面的loadDepsJs中已经事先做了loadings和递归deps的操作，而且是一直不断的循环往复的进行探查，所以define里面就不需要再像require中写一次loadDeps了

            // 循环loadings，查看loadings里面的id，其所依赖的所有层层嵌套的依赖模块是否都加载完了

            function checkDeps() {
                for(var i = 0, id; i < loadings.length ; i++) {
                id = loadings[i]
                if(!modules[id]) continue
                
                var obj = modules[id], 
                deps = obj.deps
                
                // 下面那行为什么要执行checkCycle函数呢，checkDeps是循环loadings数组的模块id，而checkCycle是去判断该id模块所依赖的**层级**的模块是否加载完
                // 即checkDeps是**广度**的循环已经加载（但依赖没完全加载完的）的id
                // checkCycle是**深度**的探查所关联的依赖
                // 还是举例吧。。。假如除了1.js, 2.js, 3.js, 还有个4.js，依赖5.js，那么
                // loadings 可能 是 ['1.js', '4.js']
                // 所以checkDeps --> 1.js，  4.js
                // checkCycle深入内部 1.js --> 2.js --> 3.js ;;; 4.js --> 5.js
                // 一旦比如说1.js的所有依赖2.js、3.js都加载完了，那么1.js 就会在loadings中移出
                
                var flag = checkCycle(deps)
                
                if(flag) {
                        console.log(i, loadings[i] ,'全部依赖已经loaded');
                    
                        loadings.splice(i,1);
                        // ！！！运行模块，然后同时得到该模块的返回值！！！
                        getExport(obj.id)
                        // 不断的循环探查啊~~~~
                        checkDeps()
                }
                
                }
            }
            // 深层次的递归的去判断，层级依赖是否都加在完了
            // 进入1.js的依赖2.js，再进入2.js的依赖3.js ......
            function checkCycle(deps) {
                var flag = true
                
                function cycle(deps) {
                    deps.forEach(item => {
                        if(!modules[item] || modules[item].status == 1) {
                            flag = false
                        } else if(modules[item].deps.length) {
            //                         console.log('inner deps', modules[item].deps);
                            
                            cycle(modules[item].deps)
                        }
                            
                    })
                }
                
                cycle(deps)
                
                return flag
            }

            /*
                运行该id的模块，同时得到模块返回值，modules[id].export
            */
            function getExport(id) {
                /*
                    先想一下，例如模块2.js, 这时 id == 2.js
                    define(['3.js', 'xxxx.js'], functionA(B, C) {
                        // B得到的就是3.js模块的返回值，C是xxxx.js的
                        return aaaaa    // 2.js 模块的返回值
                    })
                    所以：
                    1. 运行模块，就是运行 functionA （模块的callback）
                    2. 得到模块的返回值，就是functionA运行后的返回值 aaaaa
                    问题：
                    1. 运行functionA(B, C)   B, C是什么？怎么来的？
                    2. 有B, C 了，怎么运行functionA ？
                    
                */
                // 解决问题1
                // B, C 就是该模块依赖 deps [3.js, xxxx.js]对应的返回值
                // 那么循环deps 得到 依赖模块Id, 取模块的export
                var params = [];
                var deps = modules[id].deps  
                
                for(var i = 0; i < deps.length; i++) {
                    // 取依赖模块的exports即模块返回值，注意不要害怕取不到，因为你这个模块都进来打算运行了，那么你的所有依赖的模块早都进来过运行完了（还记得模块运行顺序不？）
                    let depId = deps[i]
                    params.push( modules[ depId ].exports )
                }
                
                // 到这里,params就是依赖模块的返回值的数组，也就是B，C对应的实参
                // 也就是 params == [3.js的返回值，xxxx.js的返回值]
                
                if(!modules[id].exports) {
                    // 解决问题2： callback(functionA)的执行，用.apply，这也是为什么params是个数组了
                    // 这一行代码，既运行了该模块，同时也得到了该模块的返回值export
                    modules[id].exports = modules[id].callback.apply(global, params)
                }
            }
            ```

            * 模块运行顺序：

                3.js，2.js，1.js，如果模块以及该模块的依赖都加载完，就执行。 如 3.js 加载完后，没有依赖，直接执行3.js的回调了，2.js加载完后探查到依赖的3.js也加载完，2.js执行自己的回调了,主模块一定在最后执行


        * CMD：通用模块定义，使用sea.js

            * 用法：
            ```js
            // 只有define，没有require
            // 和AMD那个例子一样，还是1依赖2, 2依赖3
            //1.js中
            define(function() {
                
                var a = require('2.js')
                console.log(33333)
                var b = require('4.js')
            })

            //2.js 中
            define(function() {
                var b = require('3.js')
            })
            //3.js 中
            define(function() {
                // xxx
            })
            ```

            * 原理同AMD

            * 模块运行顺序：

                1.js，2.js，3.js，即先执行主模块1.js，碰到require('2.js')就执行2.js，2.js中碰到require('3.js')就执行3.js

    * 服务器端模块化工具

        * webpack基于CommonJs

            同步加载

            一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。

            加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象，用来输出模块。

## 后端篇

### 消息队列

1. 参考链接：

2. 详解：

    在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

    AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。

### 存储过程

1. 参考链接：

    [存储过程和函数](https://www.cnblogs.com/doudouxiaoye/p/5811836.html)

2. 详解：

    存储过程就是一条或多条SQL语句的集合，可视为批文件，但是起作用不仅限于批处理。

### 数据库读写分离

1. 参考链接：

    [想用数据库“读写分离” 请先明白“读写分离”解决什么问题](https://baijiahao.baidu.com/s?id=1614304400276051465&wfr=spider&for=pc)

    [浅谈高性能数据库集群——读写分离](https://www.jianshu.com/p/eba38b1ff43c?utm_source=coffeephp.com)

2. 详解：

    将数据库分为主从库，一个主库用于写数据，多个从库完成读数据的操作，主从库之间通过某种机制进行数据的同步,提升数据库的读写性能


## 服务器篇

### linux服务器定时执行任务

1. 参考链接：

    [Centos7 利用crontab定时执行任务及配置方法](https://www.cnblogs.com/p0st/p/9482167.html)

    [CentOs 7.0实现定时任务（定时访问网页）](https://blog.csdn.net/qq_16505093/article/details/51478064)

2. 详解：

    crond 和 crontab
    ```txt
    1、crontab -e，进入编辑界面 
    2、输入/2 * * * * curl http://www.baidu.com，表示每两分钟访问一次网页 
    3、保存退出，然后service crond start启动服务 
    4、chkconfig crond on设置开机自启动 
    5、 
    基本格式 : 
    *　　*　　*　　*　　*　　command 
    分　 时　 日　 月　 周　 命令 
    第1列表示分钟1～59 每分钟用或者 /1表示 
    第2列表示小时1～23（0表示0点） 
    第3列表示日期1～31 
    第4列表示月份1～12 
    第5列标识号星期0～6（0表示星期天）
    crond不支持精确到秒
    ```

