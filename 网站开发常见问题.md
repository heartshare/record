# 网站开发常见问题

* [前端篇](#前端篇)
* [后端篇](#后端篇)
* [服务器篇](#服务器篇)

## 前端篇

1. unicode和utf编解码的原理和不同

    * 参考链接：

        [Unicode和UTF-8字符串编码解码原理](https://blog.csdn.net/Enl0ve/article/details/82844484)

        [Unicode 和 UTF-8、UTF-16之间的区别](https://blog.csdn.net/zengchen__acmer/article/details/75332190)

        [【编码】ASCII、Unicode、GBK和UTF-8字符编码的区别联系](https://blog.csdn.net/u010262331/article/details/46013905)

        [各种常见编码的转换算法](https://blog.csdn.net/xiaolongwang2010/article/details/10311397)

    Unicode是字符集，而UTF-8是编码规则

    字符集为每一个字符分配一个唯一的ID(学名为码位/码点/Code Point)，而「编码规则」则是将「码位」转换为字节序列的规则。

    起初Unicode规定每个字符都是用 2个字节来表示，但是由于英文字符等只需要一个字节就可以表，那就造成了在保存英文文本时，就会浪费一倍的空间。

    UTF-8是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

    ```txt
    例如「田」的码位是30000，记作U+7530(30000的16进制为0x7530)。
    U+ 0000 ~ U+ 007F: 0XXXXXXX
    U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
    U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
    U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
    
    根据上表中的编码规则，之前的「田」字的码位 U+7530 属于第三行的范围：
    
        7    5    3    0   
        0111 0101 0011 0000    二进制的 7530
    --------------------------
        0111   011111   100101 二进制的 77E5
    1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
    11100111 10010100 10110000 代入模版
    E   7    9   4    B   0
    
    这就是将 U+7530 按照 UTF-8 编码为字节序列 E794B0 的过程。反之亦然。
    ```

    UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。

2. base64和二进制的不同

    * 参考链接：

        [让你完全理解base64是怎么回事](https://www.cnblogs.com/sweeeper/p/8462077.html)

        [一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770)

        [JavaScript用btoa和atob来编码解码Base64](https://my.oschina.net/itblog/blog/1613977)

        [原生JS实现base64解码与编码](https://imweb.io/topic/5b8ea5327cd95ea86319358a)

    Base64编码可以将任意一组字节转换为较长的常见文本字符序列,将用户输入或二进制数据，打包成一种安全格式发送出去，无须担心其中包含冒号、换行符或二进制值等特殊字符。

    ```txt
    例子：输入Ow!

    (1) 字符串"Ow!"被拆分成3个8位的字节(0x4F、0x77、0x21)

    (2) 这3个字节构成了一个24为的二进制01001111 01110111 00100001

    (3) 这些为被划分为一些6位的序列010011、110111、011100、100001,(若不能正好平均分成每段6位，则按6和8的最小公倍数在末尾补0，位数为6和8的最小公倍数，000000用填充码=表示)

    (4) 每个6位值都表示了从0～63之间的数字，对应base64字母表中的64个字符之一。得到的base64编码字符串是4个字符的字符串“T3ch”。然后就可以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些移植性最好的字符(字母、数字等)。

    a:a -- 011000 010011 101001 100001 -- YTph

    a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==

    a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=

    a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 100001 -- YTphYWFh
    ```
    ```txt
    编码表：

    0　A　　17　R　　　34　i　　　51　z

    1　B　　18　S　　　35　j　　　52　0

    2　C　　19　T　　　36　k　　　53　1

    3　D　　20　U　　　37　l　　　54　2

    4　E　　21　V　　　38　m　　　55　3

    5　F　　22　W　　　39　n　　　56　4

    6　G　　23　X　　　40　o　　　57　5

    7　H　　24　Y　　　41　p　　　58　6

    8　I　　25　Z　　　42　q　　　59　7

    9　J　　26　a　　　43　r　　　60　8

    10　K　　27　b　　　44　s　　　61　9

    11　L　　28　c　　　45　t　　　62　+

    12　M　　29　d　　　46　u　　　63　/

    13　N　　30　e　　　47　v

    14　O　　31　f　　　48　w　　　

    15　P　　32　g　　　49　x

    16　Q　　33　h　　　50　y
    ```
    btoa和atob是window对象的两个函数，其中btoa是binary to ascii，用于将binary的数据用ascii码表示，即Base64的编码过程，而atob则是ascii to binary，用于将ascii码解析成binary数据
    ```js
    //方法实现
    var a = 'Hello World!';
    var encodedString = btoa(string);
    console.log(encodedString); // Outputs: "SGVsbG8gV29ybGQh"
    var decodedString = atob(encodedString);
    console.log(decodedString); // Outputs: "Hello World!"
    //涉及中文时，需要encodeURIComponent
    var b = "Hello, 中国！";
    //"SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE="
    var encodedString2 = btoa(encodeURIComponent(b));
    var decodedString2 = decodeURIComponent(atob(encodedString2));
    console.log(decodedString2); //"Hello, 中国！"
    ```

3. 绑定事件的不同种方式，执行顺序，事件委托

    * 参考链接：

        [看懂此文，不再困惑于javascript中的事件绑定、事件冒泡、事件捕获和事件执行顺序](https://blog.csdn.net/aitangyong/article/details/43231111)

        [js中的事件委托或是事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)

    3种方式：
    ```html
    <p id="btn" onclick="hello()"></p>
    <script>
        document.getElementById("btn").onclick = function(){}
        document.getElementById("btn").addEventListener("click",function(){})
    </script>
    ```
    其中addEventListener可重复绑定同一元素，先绑定先执行。

    对于层叠元素，则需要区分事件冒泡和事件捕获，冒泡：从底向面，捕获：从面向底。addEventListener((type, listener, useCapture)
    
    阻止冒泡：只执行当前元素事件，不执行层叠元素事件。event.stopPropagation()

    事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如ul下有很多li，逐一绑定事件很影响性能，且新li加入也要重新绑定事件，会十分麻烦，所以li事件需要委托其上一级ul代为执行事件。
    ```js
    window.onload = function(){
    　　var oUl = document.getElementById("ul1");
    　　oUl.onclick = function(ev){
    　　　　var ev = ev || window.event;
    　　　　var target = ev.target || ev.srcElement;
    　　　　if(target.nodeName.toLowerCase() == 'li'){
    　 　　　　　　	alert(123);
    　　　　　　　  alert(target.innerHTML);
    　　　　}
    　　}
    }
    ```

4. css旋转、拖拽、手势移动

    * 参考链接：

        [CSS3动画（360度旋转、旋转放大、放大、移动）](https://www.cnblogs.com/guozhe/p/5912664.html)

        [HTML5 CSS3 专题 : 拖放 （Drag and Drop）](https://www.cnblogs.com/wzjhoutai/p/6858022.html)

    关键词：transform,translate,scale,rotate,transition,animation,@keyframes,drag系列事件,cursor


5. http状态码和使用场景





6. 前端截图上传服务器实现
7. 获取图片上传进度
8. 无限滚动
9. 持久化缓存
10. []==false !![]==true
11. setTimeOut和setInterval底层区别
12. c++和js区别
13. js继承
14. 闭包数据缓存
15. 事件循环机制 promise
16. 页面生成过程
17. es6
18. http请求方式：get/post/put/delete
19. CMD原理
20. vue响应式原理

## 后端篇

1. 消息队列

    在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

    AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。

2. 存储过程

    * 参考链接：

        [存储过程和函数](https://www.cnblogs.com/doudouxiaoye/p/5811836.html)

    存储过程就是一条或多条SQL语句的集合，可视为批文件，但是起作用不仅限于批处理。

3. 数据库读写分离




## 服务器篇

1. linux服务器定时执行任务

    * 参考链接：

        [Centos7 利用crontab定时执行任务及配置方法](https://www.cnblogs.com/p0st/p/9482167.html)

        [CentOs 7.0实现定时任务（定时访问网页）](https://blog.csdn.net/qq_16505093/article/details/51478064)

    crond 和 crontab
    ```txt
    1、crontab -e，进入编辑界面 
    2、输入/2 * * * * curl http://www.baidu.com，表示每两分钟访问一次网页 
    3、保存退出，然后service crond start启动服务 
    4、chkconfig crond on设置开机自启动 
    5、 
    基本格式 : 
    *　　*　　*　　*　　*　　command 
    分　 时　 日　 月　 周　 命令 
    第1列表示分钟1～59 每分钟用或者 /1表示 
    第2列表示小时1～23（0表示0点） 
    第3列表示日期1～31 
    第4列表示月份1～12 
    第5列标识号星期0～6（0表示星期天）
    crond不支持精确到秒
    ```






