# 网站开发常见问题

* [前端篇](#前端篇)
    * [unicode和utf编解码的原理和不同](#unicode和utf编解码的原理和不同)
    * [base64和二进制的不同](#base64和二进制的不同)
    * [绑定事件的不同种方式，执行顺序，事件委托](#绑定事件的不同种方式，执行顺序，事件委托)
    * [css旋转、拖拽、手势移动](#css旋转、拖拽、手势移动)
    * [http状态码和使用场景](#http状态码和使用场景)
    * [前端截图上传服务器实现](#前端截图上传服务器实现)
    * [获取图片上传进度](#获取图片上传进度)
    * [无限滚动](#无限滚动)
    * [持久化存储](#持久化存储)
    * [js数据类型与隐式转换](#js数据类型与隐式转换)
    * [js事件循环机制](#js事件循环机制)
    * [js继承](#js继承)
    * [闭包数据缓存](#闭包数据缓存)
    * [页面加载生成过程](#页面加载生成过程)
    * [http请求方式](#http请求方式)
    * [前端模块化](#前端模块化)
    * [for-in,for-of,foreach区别](#for-in,for-of,foreach区别)
    * [arguments,...values,callee,caller,this,call,apply,bind用法](#arguments,...values,callee,caller,this,call,apply,bind用法)
    * [日历的实现](#日历的实现)
    * [深复制的实现](#深复制的实现)
    * [overflow:hidden清除浮动的原理](#overflow:hidden清除浮动的原理)
    * [前端路由原理](#前端路由原理)
    * [强制缓存和协商缓存](#强制缓存和协商缓存)
    * [节流和防抖](#节流和防抖)
    * [xss和csrf](#xss和csrf)
    * [js函数柯里化](#js函数柯里化)
    * [js依赖注入与控制反转](js依赖注入与控制反转)
    * [webpack](#webpack)
    * [用户查找、光标、右键功能行为](#用户查找、光标、右键功能行为)
    * [表单输入重置与hover提示文字](#表单输入重置与hover提示文字)
    * [特殊事件与自定义事件](#特殊事件与自定义事件)
    * [DOM树解析和更改与遍历](#DOM树解析和更改与遍历)
    * [js获取视频第一帧](#js获取视频第一帧)
    * [浏览器性能数据](#浏览器性能数据)
    * [媒体查询匹配](#媒体查询匹配)
    * [浏览器对话与打印](#浏览器对话与打印)
    * [人工标注文档Range](#人工标注文档Range)
    * [height和top与y](#height和top与y)
    * [页面复制文字时自动加版权](#页面复制文字时自动加版权)
* [后端篇](#后端篇)
    * [消息队列](#消息队列)
    * [存储过程](#存储过程)
    * [数据库读写分离](#数据库读写分离)
    * [SQL分页](#SQL分页)
    * [SQL索引原理](#SQL索引原理)
* [服务器篇](#服务器篇)
    * [linux服务器定时执行任务](#linux服务器定时执行任务)

## 前端篇

### unicode和utf编解码的原理和不同

1. 参考链接：

    [Unicode和UTF-8字符串编码解码原理](https://blog.csdn.net/Enl0ve/article/details/82844484)

    [Unicode 和 UTF-8、UTF-16之间的区别](https://blog.csdn.net/zengchen__acmer/article/details/75332190)

    [【编码】ASCII、Unicode、GBK和UTF-8字符编码的区别联系](https://blog.csdn.net/u010262331/article/details/46013905)

    [各种常见编码的转换算法](https://blog.csdn.net/xiaolongwang2010/article/details/10311397)

2. 详解：

    Unicode是字符集，而UTF-8是编码规则

    字符集为每一个字符分配一个唯一的ID(学名为码位/码点/Code Point)，而「编码规则」则是将「码位」转换为字节序列的规则。

    起初Unicode规定每个字符都是用 2个字节来表示，但是由于英文字符等只需要一个字节就可以表，那就造成了在保存英文文本时，就会浪费一倍的空间。

    UTF-8是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

    ```txt
    例如「田」的码位是30000，记作U+7530(30000的16进制为0x7530)。
    U+ 0000 ~ U+ 007F: 0XXXXXXX
    U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
    U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
    U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
    
    根据上表中的编码规则，之前的「田」字的码位 U+7530 属于第三行的范围：
    
        7    5    3    0   
        0111 0101 0011 0000    二进制的 7530
    --------------------------
        0111   011111   100101 二进制的 77E5
    1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
    11100111 10010100 10110000 代入模版
    E   7    9   4    B   0
    
    这就是将 U+7530 按照 UTF-8 编码为字节序列 E794B0 的过程。反之亦然。
    ```

    UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。

### base64和二进制的不同

1. 参考链接：

    [让你完全理解base64是怎么回事](https://www.cnblogs.com/sweeeper/p/8462077.html)

    [一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770)

    [JavaScript用btoa和atob来编码解码Base64](https://my.oschina.net/itblog/blog/1613977)

    [原生JS实现base64解码与编码](https://imweb.io/topic/5b8ea5327cd95ea86319358a)

2. 详解：

    Base64编码可以将任意一组字节转换为较长的常见文本字符序列,将用户输入或二进制数据，打包成一种安全格式发送出去，无须担心其中包含冒号、换行符或二进制值等特殊字符。

    ```txt
    例子：输入Ow!

    (1) 字符串"Ow!"被拆分成3个8位的字节(0x4F、0x77、0x21)

    (2) 这3个字节构成了一个24为的二进制01001111 01110111 00100001

    (3) 这些为被划分为一些6位的序列010011、110111、011100、100001,(若不能正好平均分成每段6位，则按6和8的最小公倍数在末尾补0，位数为6和8的最小公倍数，000000用填充码=表示)

    (4) 每个6位值都表示了从0～63之间的数字，对应base64字母表中的64个字符之一。得到的base64编码字符串是4个字符的字符串“T3ch”。然后就可以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些移植性最好的字符(字母、数字等)。

    a:a -- 011000 010011 101001 100001 -- YTph

    a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==

    a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=

    a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 100001 -- YTphYWFh
    ```
    ```txt
    编码表：

    0　A　　17　R　　　34　i　　　51　z

    1　B　　18　S　　　35　j　　　52　0

    2　C　　19　T　　　36　k　　　53　1

    3　D　　20　U　　　37　l　　　54　2

    4　E　　21　V　　　38　m　　　55　3

    5　F　　22　W　　　39　n　　　56　4

    6　G　　23　X　　　40　o　　　57　5

    7　H　　24　Y　　　41　p　　　58　6

    8　I　　25　Z　　　42　q　　　59　7

    9　J　　26　a　　　43　r　　　60　8

    10　K　　27　b　　　44　s　　　61　9

    11　L　　28　c　　　45　t　　　62　+

    12　M　　29　d　　　46　u　　　63　/

    13　N　　30　e　　　47　v

    14　O　　31　f　　　48　w　　　

    15　P　　32　g　　　49　x

    16　Q　　33　h　　　50　y
    ```
    btoa和atob是window对象的两个函数，其中btoa是binary to ascii，用于将binary的数据用ascii码表示，即Base64的编码过程，而atob则是ascii to binary，用于将ascii码解析成binary数据
    ```js
    //方法实现
    var a = 'Hello World!';
    var encodedString = btoa(string);
    console.log(encodedString); // Outputs: "SGVsbG8gV29ybGQh"
    var decodedString = atob(encodedString);
    console.log(decodedString); // Outputs: "Hello World!"
    //涉及中文时，需要encodeURIComponent
    var b = "Hello, 中国！";
    //"SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE="
    var encodedString2 = btoa(encodeURIComponent(b));
    var decodedString2 = decodeURIComponent(atob(encodedString2));
    console.log(decodedString2); //"Hello, 中国！"
    ```

### 绑定事件的不同种方式，执行顺序，事件委托

1. 参考链接：

    [看懂此文，不再困惑于javascript中的事件绑定、事件冒泡、事件捕获和事件执行顺序](https://blog.csdn.net/aitangyong/article/details/43231111)

    [js中的事件委托或是事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)

2. 详解：

    3种方式：
    ```html
    <p id="btn" onclick="hello()"></p>
    <script>
        document.getElementById("btn").onclick = function(){}
        document.getElementById("btn").addEventListener("click",function(){})
    </script>
    ```
    其中addEventListener可重复绑定同一元素，先绑定先执行。

    对于层叠元素，则需要区分事件冒泡和事件捕获，冒泡：从底向面，捕获：从面向底。addEventListener((type, listener, useCapture)
    
    阻止冒泡：只执行当前元素事件，不执行层叠元素事件。event.stopPropagation()

    事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如ul下有很多li，逐一绑定事件很影响性能，且新li加入也要重新绑定事件，会十分麻烦，所以li事件需要委托其上一级ul代为执行事件。
    ```js
    window.onload = function(){
    　　var oUl = document.getElementById("ul1");
    　　oUl.onclick = function(ev){
    　　　　var ev = ev || window.event;
    　　　　var target = ev.target || ev.srcElement;
    　　　　if(target.nodeName.toLowerCase() == 'li'){
    　 　　　　　　	alert(123);
    　　　　　　　  alert(target.innerHTML);
    　　　　}
    　　}
    }
    ```

### css旋转、拖拽、手势移动

1. 参考链接：

    [CSS3动画（360度旋转、旋转放大、放大、移动）](https://www.cnblogs.com/guozhe/p/5912664.html)

    [HTML5 CSS3 专题 : 拖放 （Drag and Drop）](https://www.cnblogs.com/wzjhoutai/p/6858022.html)

2. 详解：

    关键词：transform,translate,scale,rotate,transition,animation,@keyframes,drag系列事件,cursor


### http状态码和使用场景

1. 参考链接：

    [HTTP状态码（HTTP Status Code）及常用场景](https://www.cnblogs.com/QQParadise/p/5019860.html)

2. 详解：
    ```txt
    常见状态码：
    HTTP: Status 200 – 服务器成功返回网页
    HTTP: Status 3xx - 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
    HTTP: Status 404 – 请求的网页不存在
    HTTP: Status 503 – 服务不可用
    ```

### 前端截图上传服务器实现

1. 参考链接：

    [浅析 js 实现网页截图的两种方式](https://juejin.im/entry/58b91491570c35006c4f7fdf)

2. 详解：

    * canvas思路:(html2canvas)
    ```txt
    将dom转换成canvas图片。

    递归取出目标模版的所有DOM节点，填充到一个rederList，并附加是否为顶层元素/包含内容的容器 等信息

    通过z-index postion float等css属性和元素的层级信息将rederList排序，计算出一个canvas的renderQueue

    遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等

    将画好的canvas填充进页面
    ```
    优缺点:复杂度高，稳定性强。

    * svg思路:(rasterizeHTML.js)
    ```txt
    svg的标签里有个foreignObject标签，可以加载其它命名空间的xml(xhtml)文档,只需要将要渲染的DOM扔进<foreignObject></foreignObject>，利用Blob构建svg图像。
    通过一系列的hack技巧替我们绕过了许多限制:
    1.将<img/>的url 转为 dataURI
    2.将background-color从style中取出，修改url后重新插入样式表
    3.将link的的样式通过ajax down下来然后注入<style></sytle>
    ```
    优缺点:简单，只能对已经存在的静态资源进行处理，而对js动态生成并不能实时处理。

    * 上传
    ```js
    var fd = new FormData();
    fd.append("img", imgBlob);
    $.ajax({
        type: "POST",
        url: "http://tmpfile.coding.io/img",
        dataType: 'json',
        data: fd,
        crossDomain: true,
        processData: false,
        contentType: false,
        success: function(data){
            if(data && data.path) {    
            console.log("http://tmpfile.coding.io/tmp" + data.path);
            }
        }
    });
    ```

### 获取图片上传进度

1. 参考链接：

    [XHR简介](https://www.cnblogs.com/syfwhu/p/6116323.html)

    [深入理解ajax系列第一篇——XHR对象](https://www.cnblogs.com/yibutian/p/9456248.html)

    [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

    [使用原生JS 或jquery ajax 获取上传图片实时进度](https://segmentfault.com/a/1190000012871456)

    [JS、JQ实现图片上传，文件上传、带进度条上传的几种方法](https://blog.csdn.net/qq_38740171/article/details/82999793)

2. 详解：

    * 常用只读属性：

        (1) XMLHttpRequest.readyState 返回unsigned short，状态码:
        * 0	UNSENT 代理被创建，但尚未调用 open() 方法。
        * 1	OPENED open() 方法已经被调用。
        * 2	HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。
        * 3	LOADING	下载中,responseText 属性已经包含部分数据。
        * 4	DONE 下载操作已完成。

        (2) XMLHttpRequest.response 返回ArrayBuffer、Blob、Document、DOMString，具体是哪种类型取决于XMLHttpRequest.responseType的值。其中包含响应体body。

        (3)XMLHttpRequest.responseText 返回string或null

        (4)XMLHttpRequest.responseURL 返回响应的序列化URL

        (5)XMLHttpRequest.responseXML 返回一个Document，其中包含该请求的响应
        * 如果响应的内容类型是'text/xml'或'application/xml'，这个属性中将保存着响应数据的XML DOM文档(document形式)

        (6)XMLHttpRequest.status 返回unsigned short，请求响应状态
        * UNSENT（未发送） 0
        * OPENED（已打开） 0
        * LOADING（载入中） 200
        * DONE（完成） 200

        (7)XMLHttpRequest.statusText 返回string，响应状态文本
        * UNSET
        * OPENED
        * LOADING
        * DONE
        * OK
        * Not Found

    * 常用属性：

        (1) XMLHttpRequest.responseType 响应数据的类型：text、arraybuffer、blob、document、json

    * 常用方法：

        (1)XMLHttpRequest.abort() 中止请求

        (2)XMLHttpRequest.getAllResponseHeaders() 返回所有用CRLF分隔的响应头,string或null
        ```js
        var request = new XMLHttpRequest();
        request.open("GET", "foo.txt", true);
        request.send();

        request.onreadystatechange = function() {
        if(this.readyState == this.HEADERS_RECEIVED) {

            // Get the raw header string
            var headers = request.getAllResponseHeaders();

            // Convert the header string into an array
            // of individual headers
            var arr = headers.trim().split(/[\r\n]+/);

            // Create a map of header names to values
            var headerMap = {};
            arr.forEach(function (line) {
                var parts = line.split(': ');
                var header = parts.shift();
                var value = parts.join(': ');
                headerMap[header] = value;
            });

            var contentType = headerMap["content-type"];//text/html; charset=utf-8
        }

        /*
        date: Fri, 08 Dec 2017 21:04:30 GMT\r\n
        content-encoding: gzip\r\n
        x-content-type-options: nosniff\r\n
        server: meinheld/0.6.1\r\n
        x-frame-options: DENY\r\n
        content-type: text/html; charset=utf-8\r\n
        connection: keep-alive\r\n
        strict-transport-security: max-age=63072000\r\n
        vary: Cookie, Accept-Encoding\r\n
        content-length: 6502\r\n
        x-xss-protection: 1; mode=block\r\n
        */
        ```

        (3)XMLHttpRequest.getResponseHeader(name) 返回包含指定响应头的字符串,string或null，name如"Content-Type"

        (4)XMLHttpRequest.open(method, url, async, user, password) 初始化一个请求
        * method:get,post,put,delete
        * async:是否异步
        * user和password用于认证

        (5)XMLHttpRequest.overrideMimeType() 重写由服务器返回的MIME type,默认"text/xml"

        (6)XMLHttpRequest.send() 发送请求

        (7)XMLHttpRequest.setRequestHeader(header, value) 设置HTTP请求头的值

    * 事件：

        (1)onloadstart 开始

        (2)onprogress 数据传输进行中

        (3)onabort 终止

        (4)onerror 失败

        (5)onload 成功

        (6)ontimeout 超时

        (7)onloadend 完成（不论成功与否）

        (8)onreadystatechange readyState属性发生变化

    * 获取上传图片实时进度

    ```js
    $.ajax({
        url: 'URL',
        type: 'POST',
        data: data,
        processData: false, //用来回避jquery对formdata的默认序列化，XMLHttpRequest会对其进行正确处理  
        contentType: false, //设为false才会获得正确的conten-Type  
        xhr: function() { //用以显示上传进度  
            var xhr = $.ajaxSettings.xhr();
            if (xhr.upload) {
                xhr.upload.addEventListener('progress', function(event) {
                    var percent = Math.floor(event.loaded / event.total * 100);
                    $("#progress .progress-item").css("width",percent + "%");
                }, false);
            }
        },
        success: function(data) {

        }
    })

    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'url');
    // 上传完成后的回调函数
    xhr.onreadystatechange = function() {
        if (xhr.status === 200) {　　
            console.log(xhr.responseText);
        } else {　
            console.log('上传出错');
        }
    };
    // 获取上传进度
    xhr.upload.onprogress = function(event) {
        console.log(event.loaded)
        console.log(event.total)
        if (event.lengthComputable) {
            var percent = Math.floor(event.loaded / event.total * 100);
            document.querySelector("#progress .progress-item").style.width = percent + "%";
            // 设置进度显示
            console.log(percent)
        }
    };
    xhr.send(data);
    ```

### 无限滚动

1. 参考链接：

    [原生js之列表优化-无限滚动实例](https://www.jianshu.com/p/f57272d4276d)

2. 详解：

    关键词：onscroll,scrollTop

    onscroll 与 onwheel: onwheel是鼠标滚轮旋转, 而onscroll 处理的是对象内部内容区的滚动事件


### 持久化存储

1. 参考链接：

    [持久化存储与HTTP缓存](https://www.jianshu.com/p/71163b408940)

    [理解cookie、session、localStorage、sessionStorage之不同](https://blog.csdn.net/qq_35585701/article/details/81393361)

2. 详解：

    * LocalStorage

        关闭浏览器后，数据不会丢失
        ```js
        //1. 添加键、值
        localStorage.setItem(key, value)
        //2. 获得键、值
        localStorage.getItem(key)
        //3.清空localStorage
        localStorage.clear()
        ```
        特点：
        * LocalStorage跟HTTP无关，发送请求不会带上LocalStorage的值
        * 只有相同域名的页面才能互相读取LocalStorage
        * 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）
        * 常用场景：浏览器端储存数据（不能记录密码等敏感信息）
        * LocalStorage 永久有效，除非用户清理缓存

    * SessionStorage

        会话结束后，数据丢失
        ```js
        //1. 添加键、值
        sessionStorage.setItem(key, value)
        //2. 获得键、值
        sessionStorage.getItem(key)
        //3.清空sessionStorage
        sessionStorage.clear()
        ```
        特点同上

    * Cookie

        Cookie是存放在浏览器端的数据，每次都随请求发送给 Server。存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。

        特点：
        * 服务器通过 Set-Cookie 头给客户端一串字符串
        * 客户端每次访问相同域名的网页时，必须带上这段字符串
        * 客户端要在一段时间内保存这个Cookie
        * Cookie 默认在用户关闭页面后就失效，代码可以任意设置 Cookie 的过期时间，max-age和Expires
        * 大小大概在 4kb 以内

        ```js
        function setCookie(cname,cvalue,exdays)
        {
            var d = new Date();
            d.setTime(d.getTime()+(exdays*24*60*60*1000));
            var expires = "expires="+d.toGMTString();
            document.cookie = cname + "=" + cvalue + "; " + expires;
        }

        function getCookie(cname)
        {
            var name = cname + "=";
            var ca = document.cookie.split(';');
            for(var i=0; i<ca.length; i++) 
            {
                var c = ca[i].trim();
                if (c.indexOf(name)==0) return c.substring(name.length,c.length);
            }
            return "";
        }

        function delete(cname){ 
            var date = new Date(); 
            date.setTime(date.getTime()-10000); 
            document.cookie = cname + "=; expires =" + date.toGMTString();
        }
        ```

    * Session

        Session是基于Cookie实现的，它利用一个sessionId把用户的敏感数据隐藏起来，在Set-Cookie上，使用随机数来做sessionId,最终只是把这串随机数暴露给外界，而真正的信息却保存在了服务器端的sessions对象里面。它就像一个密码簿一样，有效的信息与sessionId一一对应,当下次用户访问该网站的其他页面的时候，就会带着登录时服务器给的这个sessionId。

        特点：
        * 将 SessionID（随机数）通过 Cookie 发给客户端
        * 客户端访问服务器时，服务器读取 SessionID
        * 服务器有一块内存（哈希表）保存了所有 session
        * 通过 SessionID 可以得到对应用户的隐私信息
        * 这块内存（哈希表）就是服务器上的所有 session

### js数据类型与隐式转换

1. 参考链接：

    [JS的隐式转换 从 [] ==false 说起](https://www.cnblogs.com/nanchen/p/7905528.html)

    [JS中 [] == ![]结果为true，而 {} == !{}却为false， 追根刨底](https://blog.csdn.net/magic_xiang/article/details/83686224)


    [JavaScript中valueOf、toString的隐式调用](https://www.cnblogs.com/barrior/p/4598354.html)

2. 详解：

    * js数据类型

        原始值（primitives）：undefined， null， booleans， numbers，strings， symbol（es6）

        对象值（objects）：Object

    * 数学运算

        a+b=a的原数据类型+b的原数据类型

        有string为string，没string为number，[].toString()->""，{}.toString()->"[object Object]"

        * [] + [] = "" + "" = ""
        * [] + {} = "" + "[object Object]" = "[object Object]"

    * 比较运算

        * x===y,只有类型和值相等为true,否则为false
        * x == y
            * xy都为Null或undefined为true, null == undefined->true
            * x或y为NaN为false, NaN == NaN->false
            * 如果x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较
            * 如果存在Object，转换为原始值，比较
            * !可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余都为false

        
        |  value   |toNumber|    toString     |toBoolean|
        |----------|--------|-----------------|---------|
        |   NaN    |  NaN   |      "NaN"      |  false  |
        | Infinity |Infinity|    "Infinity"   |  true   |
        |    []    |   0    |        ""       |  true   |
        |   [1]    |   1    |       "1"       |  true   |
        |   null   |   0    |     "null"      |  false  |
        |undefined |  NaN   |   "undefined"   |  false  |
        |    {}    |  NaN   |"[object Object]"|  true   |
        |function()|  NaN   |   "function"    |  true   |

        ```txt
        []==false,[]==![],[]==0,''==0,""=="" true
        {}==false,{}==!{},{}==0,NaN==0 false
        ```

    * 隐式调用：对象生成时会自动调用(不同对象会有不同的隐式调用)
        * function:toSting/valueOf
        * 事件:handleEvent
        * JSON对象:toJSON
        * promise:then
        * object:get/set
        * 遍历器接口:Symbol.iterator

### js事件循环机制

1. 参考链接：

    [详解JavaScript中的Event Loop（事件循环）机制](https://www.cnblogs.com/cangqinglang/p/8967268.html)

    [谈谈 Event Loop（事件循环）机制](https://www.jianshu.com/p/6e9f4eb7fdbb)

    [Javascript异步编程之setTimeout与setInterval详解分析](https://www.cnblogs.com/tugenhua0707/p/4083475.html)

    [理解JavaScript 执行机制及异步回调（setTimeout/setInterval/Promise）](https://blog.csdn.net/zuggs_/article/details/82381558)

    [js 异步执行顺序](https://www.jianshu.com/p/ca480f9e7dea)

    [为什么要用setTimeout模拟setInterval?](https://blog.csdn.net/b954960630/article/details/82286486)

    [详解 setTimeout、setImmediate、process.nextTick 的区别](https://www.cnblogs.com/onepixel/articles/7605465.html)

    [setTimeout/setImmediate/process.nextTick的区别](https://www.jianshu.com/p/77f03673aa06)

    [简单理解Vue中的nextTick](https://www.jianshu.com/p/a7550c0e164f)

2. 详解：

    * js是单线程的非阻塞语言：因为如果是多线程，一边绑定事件，一边移除元素，会引起冲突。

    * 执行栈：方法排队执行的地方，每个单元对应一个context，包含作用域中的this。

    * 事件队列：异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，再把事件放回执行栈。

    * 事件循环机制：由执行栈和事件队列构成的无限循环

    * 宏任务：setInterval()，setTimeout()
        * setTimeout：在指定的毫秒数后，将定时任务处理的函数添加到事件队列的队尾。
        * setInterval：按照指定的周期(以毫秒数计时)，将定时任务处理函数添加到事件队列的队尾。
            * 因为js是单线程的，如果处于堵塞状态计不了时，它必须依赖外部计时并触发定时，所以队列中的定时事件也是异步事件。
            * 每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。
            * setInterval有两个缺点：
                * 某些间隔会被跳过；
                * 可能多个定时器会连续执行；
            * setTimeout模拟setInterval,解决setInterval缺点
            ```js
            //每次执行的时候都会创建一个新的定时器
            var a = setTimeout(function () {
                // 任务
                setTimeout(a, interval);//获取当前函数的引用，并且为其设置另一个定时器
            }, interval)
            //在前一个定时器执行完前，不会向队列插入新的定时器
            //保证定时器间隔
            ```

    * 微任务：new Promise()
        * Promise是异步的，是指他的then()和catch()方法，Promise本身还是同步的
        * 有resolve()后，才能执行then(),有reject()，不执行then()

    * 同步任务：async await
        * async function(){} 表示函数内存在异步操作
        * await 把异步操作变为同步，等待得到结果后再向下执行
        * await必须在async函数内

    * 事件优先级：同步任务>异步任务(微任务>宏任务(取决于延时时间))

    * Node.js是一个基于Chrome V8引擎的JavaScript运行环境，比js少了DOM/BOM,多了http/file system,事件执行顺序与js不同
        * 浏览器是先把一个栈以及栈中的微任务走完，才会走下一个栈。node 环境里面是把所以栈走完，才走微任务
        * setTimeout setImmediate 都是宏任务
        * nextTick和then都属于微任务
        * i/o 文件操作为宏任务

    * nextTick、setTimeout、setImmediate的区别

        nodejs中，setTimeout、setImmediate是宏任务，nextTick是微任务，因此setTimeout、setImmediate回调函数插入到任务队列的尾部，nextTick回调函数加入到当前执行栈的尾部，所以nextTick会先执行。

        setTimeout、setImmediate相差不大，但延时设为0时，setImmediate会更快加入任务队列。

        vue中，created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，因为此时DOM没渲染，需要等到mounted()后执行。另外，数据变化导致DOM变化，也应用Vue.nextTick()

    * 例题：
    ```js
    //浏览器
    (function() {
        setTimeout(() => {
            console.log(0);
        });

        new Promise(resolve => {

            console.log(1);
            
            setTimeout(() => {
                resolve();
                Promise.resolve().then(() => {
                    console.log(2);
                    setTimeout(() => console.log(3));
                    Promise.resolve().then(() => console.log(4));
                });
            });

            Promise.resolve().then(() => console.log(5));

        }).then(() => {

            console.log(6);
            Promise.resolve().then(() => console.log(7));
            setTimeout(() => console.log(8));

        });

        console.log(9);
    })();
    //1、9、5、0、6、2、7、4、8、3
    //node.js
    console.log('1');
    setTimeout(function() {
        console.log('2');
        process.nextTick(function() {
            console.log('3');
        })
        new Promise(function(resolve) {
            console.log('4');
            resolve();
        }).then(function() {
            console.log('5')
        })
    })
    process.nextTick(function() {
        console.log('6');
    })
    new Promise(function(resolve) {
        console.log('7');
        resolve();
    }).then(function() {
        console.log('8')
    })
    setTimeout(function() {
        console.log('9');
        process.nextTick(function() {
            console.log('10');
        })
        new Promise(function(resolve) {
            console.log('11');
            resolve();
        }).then(function() {
            console.log('12')
        })
    })
    //1，7，6，8，2，4，3，5，9，11，10，12
    let test = async function () {
        await new Promise((resolve,reject)=>{
            console.log(1);
            setTimeout(() => {
                resolve();
            }, 3000);
        }).then(()=>{
            console.log(2);
        });
        console.log(3)
        await new Promise((resolve,reject)=>{
            console.log(4);
            setTimeout(() => {
                resolve();
            }, 1000);
        }).then(()=>{
            console.log(5);
        });
        console.log(6)
    };
    test();
    //1

    //2
    //3
    //4
    
    //5
    //6
    ```

### js继承

1. 参考链接：

    [js各种继承方式和优缺点的介绍](https://www.cnblogs.com/lanyueff/p/7792009.html)

    [js中实现继承的几种方式](https://www.cnblogs.com/diligentYe/p/6413450.html)

2. 详解：

    ```js
    //父类
    function Parent(name) {
        this.name = name;
        this.color = ['pink', 'red'];
    }
    Parent.prototype.sayHi = function() {
        console.log('Hi');
    }

    //1.原型链(单例模式)
    //(1):属性被所有实例共享(单例，new多个child，数据是互通的，改动其中一个，其它数据会跟着变化)
    //(2):无法向父类种传参
    function Child() {

    }
    Child.prototype = new Parent();
    var child = new Child();
    child.sayHi();

    //2.构造函数:解决原型链的2个问题,但方法都在构造函数中定义，每次创建实例都会创建一遍方法
    function Child(name) {
        Parent.call(this, name);
        this.value = 'test';
    }
    var child = new Child('qq');

    //3.组合继承:解决原型链的2个问题,但创建一次实例时，两次调用了父类构造函数
    function Child() {
        Parent.call(this);
        this.value = 'test';
    }
    Child.prototype = new Parent();
    var child1 = new Child();
    var child2 = new Child();

    //4.寄生式继承(工厂模式)
    function createAnother(o) {
        var another = new Object(o);
        o.sayHi = function() {
            console.log('Hi');
        }
        return another;
    }

    //5.寄生组合式继承
    // 创建只继承原型对象的函数
    function inheritPrototype(parent, child) {
        var prototype = new Object(parent.prototype);
        prototype.constructor = child;
        child.prototype = prototype;
    }
    function Parent() {
        this.color = ['pink', 'red'];
    }
    Parent.prototype.sayHi = function() {
        console.log('Hi');
    }
    function Child() {
        Parent.call(this);
    }
    inheritPrototype(Parent, Child);

    //6.原型式继承
    function createAnother(o) {
        function F() {}
        F.prototype = o;
        return new F();
    }
    function prototype(child, parent) {
        var prototype = createAnother(parent.prototype);
        prototype.constructor = child;
        child.prototype = prototype;
    }
    prototype(Child, Parent);
    ```

### 闭包数据缓存

1. 参考链接：

    [JS闭包异步获取数据并缓存](https://blog.csdn.net/weixin_43820866/article/details/87107035)

    [js async await 终极异步解决方案](https://www.cnblogs.com/CandyManPing/p/9384104.html)

2. 详解：

    向接口请求数据时，数据多次使用，但不想保存在全局变量中，就需要将数据存储在缓存中。查找数据时，如果缓存找不到，则调用API，然后设置缓存，如果找到，直接返回查找到的值即可。闭包正好可以做到这一点，且不会释放外部的引用，从而函数内部的值可以得以保留。

    ```js
    const getList = (function() {
        // 闭包存储data
        let data = {};
        const getData = () => {
            return new Promise((resolve, reject) => {
                $.ajax({
                    url: '/your/api',
                    data: {
                        normal: 1
                    },
                    success: function (result) {
                        data = result.data;
                        resolve();
                    }
                });
            })
        }
        // 异步函数，当调用一个 async 函数时，会返回一个 Promise 对象。
        const result = async function (type) {
            if (JONS.stringify(data) === '{}') {
                //await 只能出现在 async 函数中。
                await getData();//等待异步操作执行完成，再执行后面的操作，相当于把后面的代码写在success里，但用await会比较简洁
                //如果 async 函数没有返回值，它会返回 Promise.resolve(undefined)。如果有返回值data，就会resolve(data),把data传入then
                //当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。
                return data;
            } else {
                return data;
            }
        }

        return result;
    })();

    // 第一次调用通过api请求数据
    getList().then(res => {
        console.log(res);

        // 第二次调用则直接拿取缓存数据
        getList().then(res => {
            console.log(res);
        }
    });
    ```

### 页面加载生成过程

1. 参考链接：

    [网页生成过程及重排和重绘](https://blog.csdn.net/qq_41635167/article/details/83932920)

    [web页面加载、解析、渲染过程](https://www.cnblogs.com/CandyManPing/p/6635008.html)

    [从输入URL到页面加载的全过程](https://www.cnblogs.com/xiaohuochai/p/9193083.html)

2. 详解：

    浏览器：
    * 输入网址
    * 浏览器通过DNS查找域名的IP地址
    * 浏览器给web服务器发送一个HTTP请求（TCP三次握手，四次挥手）
    * 服务器处理请求，响应HTML
    * 浏览器开始显示HTML
    * 页面加载时遇到CSS/JS/图片等资源会发送请求获取

    页面：
    * 解析html：HTML代码转化成DOM
    * 解析css/js：CSS代码转化成CSSOM（CSS Object Model）、js处理后产生一棵节点带CSS Style、会响应自定义事件的Styled DOM树
    * 构建render树：结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
    * 渲染排列：生成布局（layout），即将所有渲染树的所有节点进行平面合成，主要影响性能的地方
    * 渲染绘制：将布局绘制（paint）在屏幕上，主要影响性能的地方

    重排：DOM结构发生变化（js操作：事件、增减移动元素）

    重绘：DOM、CSS发生变化（js操作：事件、增减移动元素、元素样式变化）

### http请求方式

1. 参考链接：

    [HTTP请求方法详解](https://www.cnblogs.com/foodoir/p/5911099.html)

    [HTTP协议以及HTTP请求中8种请求方法](https://blog.csdn.net/qq_38191191/article/details/78671063)

    [RESTful介绍和使用教程](https://blog.csdn.net/x541211190/article/details/81141459)

2. 详解：

    * 8种请求方法

        * get

        获取资源:URL提交数据，但是不同的浏览器对于URL是有限制的,IE传输的数据量一般限制在2KB

        * post

        传输实体文本:提交的数据放置在HTTP报文实体的主体里,安全性比GET方法要高,POST数据大小无限制

        * head

        获得报文首部:用于确认URI的有效性及资源更新的日期时间

        * put

        传输文件:用来传输文件,保存在请求URI指定的位置,HTTP/1.1的PUT方法自身不带验证机制,存在安全问题

        * delete

        删除文件:按URI删除指定资源

        * options

        询问支持的方法:查询针对请求URI指定资源支持的方法（客户端询问服务器可以提交哪些请求方法）

        * trace

        追踪路径:对请求消息的传输路径进行追踪，TRACE方法是让Web服务器端将之前的请求通信还给客户端的方法

        * connect

        用隧道协议连接代理:主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输

    * restful

        基于HTTP、URI、XML、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是Web服务的一种新的架构风格。

        * 对网络上所有的资源都有一个Url（通用资源标志符）

        * 对资源的操作不会改变Url

        * 同一资源有多种表现形式
        
            xml、json

        * 所有操作都是无状态的

            基于接口：客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前的请求，不需了解请求的历史。可以更容易的释放资源，让服务器利用Pool（连接池）技术来提高稳定性和性能。

        * 资源操作
            * get->select
            * post->insert
            * put->update
            * delete->delete

### 前端模块化

1. 参考链接：

    [前端模块化（CommonJS,AMD和CMD）](https://www.jianshu.com/p/735781477d28)

    [前端模块化，AMD与CMD的区别](https://www.cnblogs.com/futai/p/5258349.html)

    [前端模块化之AMD与CMD原理](https://blog.csdn.net/weixin_33947521/article/details/88001955)

    [requireJS原理解析](https://blog.csdn.net/cde7070/article/details/65935888)

    [CommonJs、AMD、CMD、Webpack](https://blog.csdn.net/weixin_41143293/article/details/79662362)

2. 详解：

    * 模块化为了解决js相互引用产生的问题，如：

        * 顺序引入：先引入jquery，才能引入其它js
        * 同步加载：1.js加载并执行完，才加载2.js
        * window全局变量污染

    * 模块：

        * 普通函数
        * 对象
        * 立即执行函数

    * 在webpack出现前的2种前端模块化工具（代码模块化，执行上没有区别）

        * AMD：异步模块定义，使用require.js

            采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行，避免顺序引入和同步加载的问题。

            * 用法：
            ```js
            // 1.js 中（入口用require，其他用define）
            require(['2.js'], function(A) {
                // A得到的就是2.js模块的返回值
                // 主要的执行代码
                // 2.js 3.js都加载完，才执行1.js的这回调函数
            })

            // 2.js 中
            define(['3.js', 'xxxx.js'], functionA(B, C) {
                // B得到的就是3.js模块的返回值，C是xxxx.js的
                return aaaaa;    // 2.js 模块的返回值
            })

            // 3.js 中
            define([], functionA() {
                
                retrun {}   // 3.js 模块的返回值
            })
            ```

            * 原理：

                * 块依赖加载之后，如何调用回调函数

                    使用requireJs时，都是在页面上只引入一个require.js，把data-main指向我们的main.js

                    运行main.js时，执行里面的require和define方法，requireJs会把这些依赖和回调方法都用一个数据结构存起来

                    然后使用script来加载这些模块依赖，并且监听load函数，且每个script元素都会有一个自定义的属性，用来指明模块名

                    当模块加载成功之后，可以通过元素属性来获取模块名，接着通过模块名来获取模块的定义，接着对模块进行初始化，再对子模块重复操作

                    当子模块没有其他要加载的依赖的时候这个时候表明子模块已经加载完毕，调用回调函数

                * 加载依赖之后，如何将接口暴露给回调函数

                    当执行回调函数的时候，会使用apply将模块定义中的接口，传递给回调函数

                * 如何解决循环依赖的问题

                    将已定义的模块保存在一个对象中，当加载模块依赖的时候，如果在这个对象中存在的话，则直接返回这个模块。否则的话，则再走一遍加载的模块的流程。
                
            * 代码：
            ```js
            var modules = {},	// 存放所有文件模块的信息，每个js文件模块的信息
            loadings = [];	//	存放所有已经加载了的文件模块的id，一旦该id的所有依赖都加载完后，该id将会在数组中移除

            // 上面说了，每个文件模块都要有个id，这个函数是返回当前运行的js文件的文件名，拿文件名作为文件对象的id
            // 比如，当前加载 3.js 后运行 3.js ，那么该函数返回的就是 '3.js'
            function getCurrentJs() {
                return document.currentScript.src
            }
            // 创建节点
            function createNode() {
                var node = document.createElement('script')
                node.type = 'text/javascript'
                node.async = true;
                return node
            }
            // 开始运行
            function init() {
                // 加载 1.js
                loadJs('1.js')
            }	
            // 加载文件(插入dom中)，如果传了回调函数，则在onload后执行回调函数
            function loadJs(url, callback) {
                var node = createNode()
                node.src = url;
                node.setAttribute('data-id', url)
                node.addEventListener('load', function(evt) {
                    var e = evt.target
                    setTimeout(() => {  // 这里延迟一秒，只是让在浏览器上直观的看到每1秒加载出一个文件
                        callback && callback(e)
                    }, 1000)
                }, false)
                
                document.body.appendChild(node)
            }	
                
            // 此时，loadJs(1.js)后，并没有传回调函数，所以1.js加载成功后只是自动运行1.js代码
            // 而1.js代码中，是require( ['2.js', 'xxx.js'], functionA（B, C）{} )，则执行的是require函数, 在下面是require的定义

            window.require = function(deps, callback) {
                // deps 就是对应的 ['2.js', 'xxx.js']
                // callback 就是对应的 functionA
                // 在这里，是不会运行callback的(即模块的运行！)，得等到所有依赖都加载完的啊
                // 所以得有个地方，把一个文件的所有信息都先存起来啊，尤其是deps和callback
                var id = getCurrentJs();// 当前运行的是1.js，所以id就是'1.js'
                if(!modules.id) {
                    modules[id] = { // 该模块对象信息
                        id: id,
                        deps: deps,
                        callback: callback, 
                        exports: null,  // 该模块的返回值return ，
                        就是functionA(B, C)运行后的返回值，仔细想想？在后面的getExports中详细讲
                        
                        status: 1, 
                        
                    }
                    loadings.unshift(id); // 加入这个id，之后会循环loadings数组，递归判断id所有依赖
                }
                
                loadDepsJs(id); // 加载这个文件的所有依赖,即去加载[2.js]
            }

            function loadDepsJs(id) {
                var module = modules[id]; // 获取到这个文件模块对象
                // deps是['2.js']
                module.deps.map(item => {   // item 其实是依赖的Id，即 '2.js'
                    if(!modules[i]) {   // 如果这个文件没被加载过（注：加载过的肯定在modules中有）
                    （1）    loadJs(item, function() {   // 加载 2.js，并且传了个回调，准备要递归了
                                // 2.js加载完后，执行了这个回调函数
                                loadings.unshift(item); // 此时里面有两个了, 1.js 和 2.js
                                // 递归。。。要去搞3.js了
                                loadDepsJs(item)// item传的2.js，递归再进来时，就去modules中取2.js的deps了
                                // 每次检查一下，是否都加载完了
                                checkDeps(); // 循环loadings，配合递归嵌套和modules信息，判断是否都加载完了
                            })
                    }
                })
            }

            // 上面（1）那里，加载了2.js后马上会运行2.js的，而2.js里面是
            define(['js'], fn)
            // 所以相当于执行了 define函数

            window.define = function(deps,callback) {
                var id = getCurrentJs()
                if(!modules.id) {
                    modules[id] = {
                        id: id,
                        deps: getDepsIds(deps),
                        callback: callback,
                        exports: null,
                        status: 1,
                        
                    }
                }
            }

            // 注意，define运行的结果，只是在modules中添加了该模块的信息
            // 因为其实在上面的loadDepsJs中已经事先做了loadings和递归deps的操作，而且是一直不断的循环往复的进行探查，所以define里面就不需要再像require中写一次loadDeps了

            // 循环loadings，查看loadings里面的id，其所依赖的所有层层嵌套的依赖模块是否都加载完了

            function checkDeps() {
                for(var i = 0, id; i < loadings.length ; i++) {
                id = loadings[i]
                if(!modules[id]) continue
                
                var obj = modules[id], 
                deps = obj.deps
                
                // 下面那行为什么要执行checkCycle函数呢，checkDeps是循环loadings数组的模块id，而checkCycle是去判断该id模块所依赖的**层级**的模块是否加载完
                // 即checkDeps是**广度**的循环已经加载（但依赖没完全加载完的）的id
                // checkCycle是**深度**的探查所关联的依赖
                // 还是举例吧。。。假如除了1.js, 2.js, 3.js, 还有个4.js，依赖5.js，那么
                // loadings 可能 是 ['1.js', '4.js']
                // 所以checkDeps --> 1.js，  4.js
                // checkCycle深入内部 1.js --> 2.js --> 3.js ;;; 4.js --> 5.js
                // 一旦比如说1.js的所有依赖2.js、3.js都加载完了，那么1.js 就会在loadings中移出
                
                var flag = checkCycle(deps)
                
                if(flag) {
                        console.log(i, loadings[i] ,'全部依赖已经loaded');
                    
                        loadings.splice(i,1);
                        // ！！！运行模块，然后同时得到该模块的返回值！！！
                        getExport(obj.id)
                        // 不断的循环探查啊~~~~
                        checkDeps()
                }
                
                }
            }
            // 深层次的递归的去判断，层级依赖是否都加在完了
            // 进入1.js的依赖2.js，再进入2.js的依赖3.js ......
            function checkCycle(deps) {
                var flag = true
                
                function cycle(deps) {
                    deps.forEach(item => {
                        if(!modules[item] || modules[item].status == 1) {
                            flag = false
                        } else if(modules[item].deps.length) {
            //                         console.log('inner deps', modules[item].deps);
                            
                            cycle(modules[item].deps)
                        }
                            
                    })
                }
                
                cycle(deps)
                
                return flag
            }

            /*
                运行该id的模块，同时得到模块返回值，modules[id].export
            */
            function getExport(id) {
                /*
                    先想一下，例如模块2.js, 这时 id == 2.js
                    define(['3.js', 'xxxx.js'], functionA(B, C) {
                        // B得到的就是3.js模块的返回值，C是xxxx.js的
                        return aaaaa    // 2.js 模块的返回值
                    })
                    所以：
                    1. 运行模块，就是运行 functionA （模块的callback）
                    2. 得到模块的返回值，就是functionA运行后的返回值 aaaaa
                    问题：
                    1. 运行functionA(B, C)   B, C是什么？怎么来的？
                    2. 有B, C 了，怎么运行functionA ？
                    
                */
                // 解决问题1
                // B, C 就是该模块依赖 deps [3.js, xxxx.js]对应的返回值
                // 那么循环deps 得到 依赖模块Id, 取模块的export
                var params = [];
                var deps = modules[id].deps  
                
                for(var i = 0; i < deps.length; i++) {
                    // 取依赖模块的exports即模块返回值，注意不要害怕取不到，因为你这个模块都进来打算运行了，那么你的所有依赖的模块早都进来过运行完了（还记得模块运行顺序不？）
                    let depId = deps[i]
                    params.push( modules[ depId ].exports )
                }
                
                // 到这里,params就是依赖模块的返回值的数组，也就是B，C对应的实参
                // 也就是 params == [3.js的返回值，xxxx.js的返回值]
                
                if(!modules[id].exports) {
                    // 解决问题2： callback(functionA)的执行，用.apply，这也是为什么params是个数组了
                    // 这一行代码，既运行了该模块，同时也得到了该模块的返回值export
                    modules[id].exports = modules[id].callback.apply(global, params)
                }
            }
            ```

            * 模块运行顺序：

                3.js，2.js，1.js，如果模块以及该模块的依赖都加载完，就执行。 如 3.js 加载完后，没有依赖，直接执行3.js的回调了，2.js加载完后探查到依赖的3.js也加载完，2.js执行自己的回调了,主模块一定在最后执行


        * CMD：通用模块定义，使用sea.js

            * 用法：
            ```js
            // 只有define，没有require
            // 和AMD那个例子一样，还是1依赖2, 2依赖3
            //1.js中
            define(function() {
                
                var a = require('2.js')
                console.log(33333)
                var b = require('4.js')
            })

            //2.js 中
            define(function() {
                var b = require('3.js')
            })
            //3.js 中
            define(function() {
                // xxx
            })
            ```

            * 原理同AMD

            * 模块运行顺序：

                1.js，2.js，3.js，即先执行主模块1.js，碰到require('2.js')就执行2.js，2.js中碰到require('3.js')就执行3.js

    * 服务器端模块化工具

        * webpack基于CommonJs

            同步加载

            一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。

            加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象，用来输出模块。





### for-in,for-of,foreach区别

1. 参考链接：

    [for、for in和for of和forEach的区别](http://blog.sina.com.cn/s/blog_c112a2980102xqg9.html)

2. 详解：

    * for一般用于循环数组
    * for-in可循环数组、对象，会循环出下标、键值，可通过data[key]访问
    * for-of在Array、Object、Set、Map中都可以使用，会循环出值，直接访问value即可
    * forEach循环在Array、Set、Map中都可以使用，用法：**.forEach(function(value,key){})

### arguments,...values,callee,caller,call,apply,bind用法

1. 参考链接：

    [callee、caller、call、apply、bind这些方法的含义和使用](https://blog.csdn.net/yc123h/article/details/52729484)

    [Javascript arguments详解](https://www.cnblogs.com/caoyc/p/5735299.html)

    [JS中this到底指向谁？](https://www.cnblogs.com/huangwentian/p/6854472.html)

    [彻底搞懂 JS 中 this 机制](https://blog.csdn.net/cjgeng88/article/details/79846670)

    [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/function)

    [jQuery 源码中大量push.call();splice.call();](https://www.jianshu.com/p/3d837e8d817d)

2. 详解：

    * arguments

    arguments用在函数内部,arguments.length表示传入参数的个数，arguments.callee.length表示函数自身参数的个数，可用for in或for of或for 0~length-1遍历参数

    ```js
    function add(a,b){
        console.log(arguments,arguments.length,arguments.callee.length)
    }
    //add(1,2,3)
    //Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    // 3
    // 2
    ```

    * ...values

    ...values是es6语法，可替代arguments，数组储存传入的参数,for of遍历参数较为方便

    ```js
    function add(...values){
        console.log(values)
    }
    add(1,'a',[0],{a:1},function(){})
    //[1, "a", Array(1), {…}, ƒ]
    ```

    * callee

    callee指向函数自身，用在函数内部，用于解耦或配合arguments使用

    ```js
    //正常递归
    function factorial(num){
        if(num<=1){
            return 1;
        }else{
            return num*factorial(num-1)
        }
    }
    //下面的不规范行为，导致函数指向错误
    var testFactorial = factorial;
    factorial = function(){
        return 0;
    }
    testFactorial(5); //0
    //修改方法
    function factorial(num){
        if(num<=1){
            return 1;
        }else{
            return num*arguments.callee(num-1)
        }
    }

    var testFactorial = factorial;
    factorial = function(){
        return 0;
    }
    console.log(testFactorial(5)); //120
    ```

    * caller

    caller用法是：函数名.caller，如果函数是顶层函数（没有外层函数调用），则为null，如果有外层函数，则指向外层函数。

    ```js
    function outer(){
        inner();
    }
    function inner(){
        console.log(inner.caller);
    }
    outer(); //显示outer的源代码
    ```

    * this

    this指向的对象为函数的上下文context，即函数的调用者。

        * 默认绑定/window回调函数:函数名()调用或window函数回调（setTimeout、setInterval），this指向window
        * 隐式绑定/多层调用链:函数作为数组的一个元素，通过数组下标调用，this指向这个数组，对象1.对象2.函数名()调用，this指向对象2
        * new 绑定：函数作为构造函数，用new关键字调用，this指向新new出的对象
        * 显式绑定:call,apply导致this指向第一个参数指定的地方，对于null和undefined的绑定将不会生效
        * 箭头函数只取决于外层（函数或全局）的作用域，对于前面的4种绑定规则是不会生效，因此需要外层var that = this，供箭头函数内部使用

    * call,apply

        call,apply用于改变函数执行的作用域，即改变函数体内this的指向。区别在于：call的第二个参数起要逐一列出，apply第二个参数可以是array或arguments

        ```js
        window.color = 'red'
        var o = {
            color:'blue'
        }
        function sayColor(color){
            console.log(this.color+' param:'+color)
        }
        sayColor('black');//red param:black

        sayColor.call(window,'black'); //red param:black
        sayColor.apply(window,['black']);//red param:black

        sayColor.call(o,'black') //blue param:black
        sayColor.apply(o,['black']) //blue param:black
        ```

        * 合并数组

            ```js
            var arr1 = [1, 2, 3];  
            var arr2 = [4, 5, 6];  
            var arr3 = Array.prototype.push.call(arr1, arr2);
            console.log(arr3);
            console.log(arr1);
            console.log(arr2);
            4
            (4) [1, 2, 3, Array(3)]
            (3) [4, 5, 6]

            var arr1 = [1, 2, 3];  
            var arr2 = [4, 5, 6];  
            var arr3 = Array.prototype.push.apply(arr1, arr2);
            console.log(arr3);
            console.log(arr1);
            console.log(arr2);
            6
            (6) [1, 2, 3, 4, 5, 6]
            (3) [4, 5, 6]

            //造成输出的区别，是因为call的第二个参数起是枚举，apply的第二个参数是数组
            var arr1 = [1, 2, 3];  
            var arr2 = [4, 5, 6];  
            var arr3 = Array.prototype.push.call(arr1, ...arr2);
            console.log(arr3);
            console.log(arr1);
            console.log(arr2);
            4
            (6) [1, 2, 3, 4, 5, 6]
            (3) [4, 5, 6]
            ```

        * 对象转数组

            ```js
            var obj = {0:'hello',1:'world',length:2};
            console.log(Array.prototype.slice.call(obj));
            (2) ["hello", "world"]

            var obj = {0:'hello',1:'world',length:2};
            console.log(Array.prototype.slice.apply(obj));
            (2) ["hello", "world"]
            ```

        * 获取索引

            ```js
            var arr = [1,2,3];
            console.log(Array.prototype.indexOf.call(arr,2));
            1

            var arr = [1,2,3];
            console.log(Array.prototype.indexOf.apply(arr,[2]));
            1
            ```

    * bind

    bind方法会创建一个函数实例,this会被绑定到传给bind()函数的值

    ```js
    window.color = 'red'
    var o = {
        color:'blue'
    }
    function sayColor(color){
        console.log(this.color)
    }
    var objSayColor = sayColor.bind(o);
    objSayColor(); //blue
    ```


### 日历的实现

1. 参考链接：

    [Date](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)

2. 详解：

    * new Date()

        用法：

        * new Date();
        * new Date(value);
        * new Date(dateString);
        * new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);

        new Date(this.selectedYear,this.selectedMonth,0)会获得当月最后一天的日期

    * set方法

    凡是set方法，传入数超出合理范围，会自动转为毫秒处理，再使用get获取信息，因此日月的加减不需要处理进位和退位问题。

    * 6*7的日历显示

        * 新开长度为42的数组
        
        * 因为第一行一定会出现本月的数字，于是getDay计算本月1号时星期几，确定1号位于数组的位置

        * 从1号开始填充本月进数组

        * 通过日期加减，把数组剩余位置填满

        * 设置ul宽度，使li每7格换一次行

    ```js
    // 根据给定日期算出星期
    getDay(date){
        return new Date(date).getDay();
    }

    // 获取某月的天数
    getMonthNumber(){
        let d = new Date(this.selectedYear,this.selectedMonth,0);
        let num = d.getDate();
        return num;
    }

    // 获取某一天的昨天和明天
    // date 代表指定的日期，格式：2018-09-27
    // day 传-1表始前一天，传1表始后一天
    getNextDate(date,day) {  
        var dd = new Date(date);
        dd.setDate(dd.getDate() + day);
        var y = dd.getFullYear();
        var m = dd.getMonth() + 1 < 10 ? "0" + (dd.getMonth() + 1) : dd.getMonth() + 1;
        var d = dd.getDate() < 10 ? "0" + dd.getDate() : dd.getDate();
        return y + "-" + m + "-" + d;
    }

    // 获取日历中某一天的昨天和明天的数字
    getNextDayNumber(date,day){
        var dd = new Date(date);
        dd.setDate(dd.getDate() + day);
        var d = dd.getDate();
        return d;
    }
    ```

### 深复制的实现

1. 参考链接：

    [深入js 深拷贝对象](https://www.jianshu.com/p/b08bc61714c7)

2. 详解：

    * 递归法(简单常用，可复制原型链属性__proto__，无法处理对象成环、特殊类型symbol、不可枚举属性get/set)
    ```js
    function deepClone(obj) {
        if (typeof obj !== 'object') {
            throw new Error('obj 不是一个对象！')
        }

        let isArray = Array.isArray(obj)
        let cloneObj = isArray ? [] : {}
        for (let key in obj) {
            cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
        }

        return cloneObj
    }
    ```

    * 代理法(可symbol，无法处理对象成环、不可复制原型链属性__proto__、不可枚举属性get/set)
    ```js
    function deepClone(obj) {
        if (typeof obj !== 'object') {
            throw new Error('obj 不是一个对象！')
        }

        let isArray = Array.isArray(obj)
        let cloneObj = isArray ? [...obj] : { ...obj }
        Reflect.ownKeys(cloneObj).forEach(key => {
            cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
        })

        return cloneObj
    }
    ```
    ```js
    function deepClone(obj) {
        if (obj == null) {
            return null
        }
        var result = Array.isArray(obj) ? [] : {};
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (typeof obj[key] === 'object') {
                    result[key] = deepClone(obj[key]);  // 如果是对象，再次调用该方法自身
                } else {
                    result[key] = obj[key];
                }
            }
        }
        return result;
    }
    ```

    * 序列化法(只能处理数组和对象，且对象不能成环)
    ```js
    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj))
    }
    ```

    * lodash法(较完善)
    ```js
    let result = _.cloneDeep(test)
    ```

    * 组合法(无法处理日期和正则，Object.getOwnPropertyDescriptor的value是浅拷贝)
    ```js
    function cloneDeep(obj) {
        let family = {}
        let parent = Object.getPrototypeOf(obj)

        while (parent != null) {
            family = completeAssign(deepClone(family), parent)
            parent = Object.getPrototypeOf(parent)
        }

        function completeAssign(target, ...sources) {
            sources.forEach(source => {
                let descriptors = Object.keys(source).reduce((descriptors, key) => {
                    descriptors[key] = Object.getOwnPropertyDescriptor(source, key)
                    return descriptors
                }, {})

                // Object.assign 默认也会拷贝可枚举的Symbols
                Object.getOwnPropertySymbols(source).forEach(sym => {
                    let descriptor = Object.getOwnPropertyDescriptor(source, sym)
                    if (descriptor.enumerable) {
                        descriptors[sym] = descriptor
                    }
                })
                Object.defineProperties(target, descriptors)
            })
            return target
        }

        return completeAssign(deepClone(obj), family)
    }
    ```

### overflow:hidden清除浮动的原理

1. 参考链接：

    [为什么"overflow:hidden"能清除浮动的影响](https://www.jianshu.com/p/7e04ed3f4bea)

2. 详解：

    * BFC

        BFC（Block Formatting Context），块级格式化上下文(块级元素)，它规定了内部的块级元素(父子关系)的布局方式，空网页下只有body一个块级上下文。

        * BFC布局规则

            * 内部块级元素从上到下排布
            * 同一BFC的兄弟块级元素会margin合并，否则不会
            * margin与border相接触
            * 块级元素不会与float元素重叠
            * 计算块级元素高度时，里面的浮动元素也参与计算

        * 创建BFC

            * float的值不为none
            * overflow的值不为visible
            * position的值为fixed / absolute
            * display的值为table-cell / table-caption / inline-block / flex / inline-flex

    ```html
    <body>
    <div class="parent">
        <div class="child1"></div>
        <div class="child2"></div>
    </div>
    </body>
    ```
    ```css
    .parent{
        width:300px; 
        background:#ddd; 
        border:1px solid;
        overflow: hidden; 
    } 
    .child1{ 
        width:100px; 
        height:100px; 
        background:pink;
        float:left;
    }
    .child2{ 
        width:200px; 
        height:50px; 
        background:red;
    }
    ```
    在parent加入overflow: hidden前，parent高度为50px，加入后高度为100px，所以父元素overflow: hidden，可以清除包含块内子元素的浮动。

### 前端路由原理

1. 参考链接：

    [前端路由的前生今世及实现原理](https://segmentfault.com/a/1190000011967786)

2. 详解：

    * 后端渲染路由

        1.浏览器发出请求

        2.服务器监听到80/443端口的请求，并解析url路径

        3.根据服务器的路由配置，返回相应信息（html、json、image）

        4.浏览器根据数据包的Content-Type来决定如何解析数据

    * 前端路由

        检测url的变化，截获url地址，然后解析来匹配路由规则。

        https://...#value 井号后面的value为hash，hash变化不会请求后端，只会触发hashchange事件，然后js解析新的页面内容。回退使用history.go(-1)，前进使用hashchange事件，刷新使用load事件。

        pushState和replaceState方法，以及onpopstate事件，能够使url不出现井号跳转，原理和hash相同，如vue的history模式，但是刷新页面依然会发请求导致404，因此需要服务器转发请求，重定向到根页面，如使用nginx。回退使用popstate事件，前进使用pushState，刷新使用服务器重定向，再load。

        ```txt
        server {
            listen       8083;
            server_name  localhost;

            location / {
                root   D:\wwwroot;
                try_files $uri $uri/ /index.html;
                index  index.html index.htm;
            }

            location /api {
                add_header 'Access-Control-Allow-Origin' '*';
                proxy_pass http://localhost:7675/api;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }
        ```

    * pushState和replaceState

        history.pushState(状态对象, 标题 , URL);创建新的历史记录条目

        history.replaceState(状态对象, 标题 , URL);修改历史记录条目

        状态对象是能被序列化的对象(小于640k)，用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。

        获取当前状态：let currentState = history.state;


### 强制缓存和协商缓存

1. 参考链接：

    [强制缓存（200）和协商缓存（304）整理](https://blog.csdn.net/zl399615007/article/details/84534884)

    [强制缓存和协商缓存有什么区别](https://www.jianshu.com/p/1a1536ab01f1)

    [彻底弄懂强缓存与协商缓存](https://www.jianshu.com/p/9c95db596df5)

2. 详解：

    * 强制缓存

        浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中，从缓存中获取资源信息，包括缓存header信息，本次请求不会与服务器通信。状态码：200（from cache）

        * 相关header

            * expires:强制缓存过期时间
            * cache-control:更细致的expires,优先级高于expires，其值包含：
                * public(可被任何缓存区缓存),private(单个用户的响应消息，不共享缓存)
                * no-cache(请求或响应消息不能缓存),no-store(请求和响应消息都不使用缓存)
                * max-age(过期时间)
                * min-fresh(可以接收响应时间小于当前时间加上指定时间的响应),max-stale(可以接收超时的响应)

    * 协商缓存

        如果没有命中强制缓存，浏览器会发送请求到服务器，请求会携带第一次返回的有关缓存的header字段信息（Last-Modifued/If-Modified-Since和Etag/If-None-Match），由服务器根据header信息来比对结果是否协商缓存命中。若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。状态码：304（not modified）

        * 相关header

            * Last-Modified(响应资源的最后修改时间)
            * If-Modified-Since(资源过期时，如有Last-Modified，请求服务器会带上此请求时间，如Last-Modified时间大于if-modified-since，则返回最新资源，HTTP 200，否则响应HTTP 304)
            * Etag(服务器响应时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。)
            * If-None-Match(资源过期时，如有Etag，请求服务器会带上if-none-match(值是Etag的值)，由服务器决定返回200或304)
            * 优先级：ETag>Last-Modified

        * 为什么既有Last-Modified还有Etag?Last-Modified比较难解决的问题:

            * 文件周期性变化，文件仅仅改变的修改时间，而不改变内容，导致重新get
            * 文件变化特别快，需要用到If-Modified-Since，能检查到的粒度是秒级
            * 某些服务器不能精确的得到文件的最后修改时间

        * 用户的行为对缓存的影响

            * 对Expires/Cache-Control有效：地址栏回车/页面链接跳转/新开窗口/前进后退
            * 对Expires/Cache-Control有效：F5刷新/Ctrl+F5强制刷新
            * 对Last-Modified/Etag有效：地址栏回车/页面链接跳转/新开窗口/前进后退/F5刷新
            * 对Last-Modified/Etag有效：Ctrl+F5强制刷新


### 节流和防抖

1. 参考链接：

    [函数防抖和节流](https://www.jianshu.com/p/c8b86b09daf0)

    [js防抖和节流](https://www.cnblogs.com/momo798/p/9177767.html)

2. 详解：

    * 防抖（debounce）

        触发事件后在n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间。

        * 非立即执行
        
            触发事件后函数不会立即执行，而是在n秒后执行，如果在n秒内又触发了事件，则会重新计算函数执行时间

            ```js
            // 防抖
            function debounce1(func, wait) {
                var timeout = null;
                return function() {
                    let context = this;
                    let args = arguments;

                    if(timeout !== null)   clearTimeout(timeout);

                    timeout = setTimeout(() => {
                        func.apply(context, args)
                    }, wait);
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', debounce1(handle(a), 1000));
            ```

        * 立即执行

            触发事件后函数会立即执行，然后n秒内不触发事件才能继续执行函数的效果

            ```js
            // 防抖
            function debounce2(func,wait) {
                let timeout;
                return function () {
                    let context = this;
                    let args = arguments;

                    if (timeout) clearTimeout(timeout);

                    let callNow = !timeout;
                    timeout = setTimeout(() => {
                        timeout = null;
                    }, wait)

                    if (callNow) func.apply(context, args)
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', debounce2(handle(a), 1000));
            ```

    * 节流（throttle）

        连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。

        * 时间戳

            ```js
            // 节流
            function throttle1(func, wait) {
                let previous = 0;
                return function() {
                    let now = Date.now();
                    let context = this;
                    let args = arguments;
                    if (now - previous > wait) {
                        func.apply(context, args);
                        previous = now;
                    }
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', throttle1(handle(a), 1000));
            ```

        * 定时器

            ```js
            // 节流
            function throttle2(func, wait) {
                let timeout;
                return function() {
                    let context = this;
                    let args = arguments;
                    if (!timeout) {
                        timeout = setTimeout(() => {
                            timeout = null;
                            func.apply(context, args)
                        }, wait)
                    }
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', throttle2(handle(a), 1000));
            ```

### xss和csrf

1. 参考链接：

    [XSS 和 CSRF简述及预防措施](https://www.cnblogs.com/yangsg/p/10621496.html)

    [xss注入方法及验证方法](https://blog.51cto.com/zhouanya/1909746)

    [XSS及CSRF攻击防御](https://blog.csdn.net/zl834205311/article/details/81773511)

2. 详解：

    * xss(跨站脚本攻击)

        在网站写入恶意代码，当别人浏览网页时，导致恶意脚本被执行，获取用户隐私数据。

        * 反射型：发送带恶意脚本的get、post请求(如websocket对话)，后端没做过滤，就直接向其它用户展示
        * 持久型：提交恶意input，后端没做过滤，保存到数据库，再向其它用户展示
        * DOM型：注入script、img、onerror等操作

        预防方法：对输入进行检查、过滤和转义。

    * csrf(跨站请求伪造)

        用户带着A网站的cookie，访问B网站时，被B网站窃取后，B网站向A网站发送伪造请求，使B网站获得用户在A网站的权限。

        预防方法：

        * 验证码:图像识别，提高攻击难度
        * referer:header的referer记录了来源地址，检测到referer不是本网站的请求，则拒绝
        * 令牌:请求信息带token，验证身份

### js函数柯里化

1. 参考链接：

    [详解JS函数柯里化](https://www.jianshu.com/p/2975c25e4d71)

    [前端柯里化的三种作用](https://blog.csdn.net/qq_39674542/article/details/82657109)

2. 详解：

    * 柯里化:高阶函数
        ```js
        function add(x, y) {
            return x + y
        }
        function curryingAdd(x) {
            return function (y) {
                return x + y
            }
        }
        add(1, 2)           // 3
        curryingAdd(1)(2)   // 3
        ```

    * 好处：

        * 参数复用

            ```js
            function check(reg, txt) {
                return reg.test(txt)
            }

            check(/\d+/g, 'test')       //false
            check(/[a-z]+/g, 'test')    //true

            function curryingCheck(reg) {
                return function(txt) {
                    return reg.test(txt)
                }
            }
            var hasNumber = curryingCheck(/\d+/g)
            var hasLetter = curryingCheck(/[a-z]+/g)

            hasNumber('test1')      // true
            hasNumber('testtest')   // false
            hasLetter('21212')      // false
            ```

        * 延迟执行：累积传入的参数，最后执行
        * 固定易变因素：传参固定下来，生成一个更明确的应用函数。如bind函数用以固定this这个易变对象。

    * 封装
    ```js
    // 支持多参数传递
    function progressCurrying(fn, args) {

        var _this = this
        var len = fn.length;
        var args = args || [];

        return function() {
            var _args = Array.prototype.slice.call(arguments);
            Array.prototype.push.apply(args, _args);

            // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
            if (_args.length < len) {
                return progressCurrying.call(_this, fn, _args);
            }

            // 参数收集完毕，则执行fn
            return fn.apply(this, _args);
        }
    }
    ```

    * 反柯里化：把原来已经固定的参数或者this上下文等当作参数延迟到未来传递

    * 题目
    ```js
    function add() {
        // 第一次执行时，定义一个数组专门用来存储所有的参数
        var _args = Array.prototype.slice.call(arguments);
        console.log(1,arguments,_args)
        // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
        var _adder = function() {
            _args.push(...arguments);
            console.log(2,arguments,_args)
            return _adder;
        };

        // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
        _adder.toString = function () {
            console.log(3,_args)
            return _args.reduce(function (a, b) {
                console.log(4,_args,a,b)
                return a + b;
            });
        }
        console.log(5,_args)
        return _adder;
    }

    add(1)(2)(3) = 6;
    add(1, 2, 3)(4) = 10;
    add(1)(2)(3)(4)(5) = 15;
    add(1, 2, 3)(4, 5)(6) = 21;
    /*
    1 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ] (3) [1, 2, 3]
    5 (3) [1, 2, 3]
    2 Arguments(2) [4, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] (5) [1, 2, 3, 4, 5]
    2 Arguments [6, callee: ƒ, Symbol(Symbol.iterator): ƒ] (6) [1, 2, 3, 4, 5, 6]
    3 (6) [1, 2, 3, 4, 5, 6]
    4 (6) [1, 2, 3, 4, 5, 6] 1 2
    4 (6) [1, 2, 3, 4, 5, 6] 3 3
    4 (6) [1, 2, 3, 4, 5, 6] 6 4
    4 (6) [1, 2, 3, 4, 5, 6] 10 5
    4 (6) [1, 2, 3, 4, 5, 6] 15 6
    ƒ 21
    */
    ```

### js依赖注入与控制反转

1. 参考链接：

    [细数Javascript技术栈中的四种依赖注入](https://www.cnblogs.com/front-end-ralph/p/5208045.html)

2. 详解：

    * 场景

        A想调用B的某些方法，于是A里面就要new一个B，后来A不用B了，想用C，于是就需要改A的代码，new B变为new C，代码耦合性高。

        因此，如果有一个容器能给到A，A就能用到B、C、D...的方法，而且没经调用的方法，不实例化对象，同样B也能通过容器用到其它方法，于是就用到依赖注入与控制反转。

    * 依赖注入与控制反转

        依赖注入与控制反转描述的是同一件事情，A靠注入的容器获取外部资源，容器反过来控制了A想获得的资源。

    * 实现


        ```js
        //es5
        function injector(){
            this.hadinstance = true;
            console.log('实例化injector,只有hadinstance:',this.hadinstance);
        }
        injector.prototype.A = function(){
            console.log('实例化A');
            return new A();
        };
        injector.prototype.B = function(){
            console.log('实例化B');
            return new B();
        };
        function myClass1(injector){
            this.myInjector = injector;
        }
        function A(){
            this.a = 'a';
            this.say=function(){
                alert('A');
            }
        }
        function B(){
            this.b = 'b';
            this.say=function(){
                alert('B');
            }
        }

        let test = new myClass1(new injector());//实例化injector,只有hadinstance: true
        Object.getOwnPropertyNames(test);//["myContainer"]
        Object.getOwnPropertyNames(injector.prototype);//(3) ["constructor", "A", "B"]
        Object.getOwnPropertyNames(new injector());//["hadinstance"]
        Object.getOwnPropertyNames(new A());//(2) ["a", "say"]
        test.myInjector.A().say();//实例化A
        test.myInjector.B().b;//实例化B

        //es6
        class injector{
            constructor(){
                this.hadinstance = true;
                console.log('实例化injector,只有hadinstance:',this.hadinstance);
            }
            A(){
                console.log('实例化A');
                return new A();
            }
            B(){
                console.log('实例化B');
                return new B();
            }
        }
        class myClass1{
            constructor(injector){
                this.myInjector = injector;
            }
        }
        class A{
            constructor(){
                this.a = 'a';
                this.say=function(){
                    alert('A');
                }
            }
        }
        class B{
            constructor(){
                this.b = 'b';
                this.say=function(){
                    alert('B');
                }
            }
        }
        let test = new myClass1(new injector());//实例化injector,只有hadinstance: true
        Object.getOwnPropertyNames(test);//["myContainer"]
        Object.getOwnPropertyNames(injector.prototype);//(3) ["constructor", "A", "B"]
        Object.getOwnPropertyNames(new injector());//["hadinstance"]
        Object.getOwnPropertyNames(new A());//(2) ["a", "say"]
        test.myInjector.A().say();//实例化A
        test.myInjector.B().b;//实例化B
        ```

### webpack

1. 参考链接：

    [webpack4.x配置详解，多页面，拆分代码，多入口，多出口，新特性新坑](https://www.cnblogs.com/pomelott/p/8977092.html)

    [webpack官网](https://www.webpackjs.com/concepts/)

2. 详解：

    ```js
    const webpack = require("webpack");
    const path = require('path');
    const glob = require("glob");
    //消除冗余的css
    const purifyCssWebpack = require("purifycss-webpack");
    // html模板
    const htmlWebpackPlugin = require("html-webpack-plugin");
    // 清除目录等
    const cleanWebpackPlugin = require("clean-webpack-plugin");
    //4.x之前用以压缩
    const uglifyjsWebpackPlugin = require("uglifyjs-webpack-plugin");
    // 分离css
    const extractTextPlugin = require("extract-text-webpack-plugin");
    //静态资源输出
    const copyWebpackPlugin = require("copy-webpack-plugin");

    module.exports = {
        entry: {
            // 多入口文件
            a: './src/js/index.js',
            b: './src/js/index2.js',
            jquery: 'jquery'
        },
        output: {
            path:path.resolve(__dirname, 'dist'),
            // 打包多出口文件
            // 生成 a.bundle.js  b.bundle.js  jquery.bundle.js
            filename: './js/[name].bundle.js'
        },
        // devtool: "source-map",  // 开启调试模式
        module:{
            rules: [
                {
                    test: /\.css$/,
                    // 不分离的写法
                    // use: ["style-loader", "css-loader"]
                    // 使用postcss不分离的写法
                    // use: ["style-loader", "css-loader", "postcss-loader"]
                    // 此处为分离css的写法
                    /*use: extractTextPlugin.extract({
                        fallback: "style-loader",
                        use: "css-loader",
                        // css中的基础路径
                        publicPath: "../"

                    })*/
                    // 此处为使用postcss分离css的写法
                    use: extractTextPlugin.extract({
                        fallback: "style-loader",
                        use: ["css-loader", "postcss-loader"],
                        // css中的基础路径
                        publicPath: "../"

                    })
                },
                {
                    test: /\.js$/,
                    use: ["babel-loader"],
                    // 不检查node_modules下的js文件
                    exclude: "/node_modules/"
                },
                {
                    test: /\.(png|jpg|gif)$/,
                    use: [{
                            // 需要下载file-loader和url-loader
                            loader: "url-loader",
                            options: {
                                limit: 50,
                                // 图片文件输出的文件夹
                                outputPath: "images"
                            }
                        }
                    ]
                },
                {
                    test: /\.html$/,
                    // html中的img标签
                    use: ["html-withimg-loader"]
                },
                {
                    test: /\.less$/,
                    // 三个loader的顺序不能变
                    // 不分离的写法
                    // use: ["style-loader", "css-loader", "less-loader"]
                    // 分离的写法
                    use: extractTextPlugin.extract({
                        fallback:"style-loader",
                        use: ["css-loader", "less-loader"]
                    })
                },
                {
                    test: /\.(scss|sass)$/,
                    // sass不分离的写法，顺序不能变
                    // use: ["style-loader", "css-loader", "sass-loader"]
                    // 分离的写法
                    use: extractTextPlugin.extract({
                        fallback:"style-loader",
                        use: ["css-loader", "sass-loader"]
                    })
                }
            ]
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin(),
            // 调用之前先清除
            new cleanWebpackPlugin(["dist"]),
            // 4.x之前可用uglifyjs-webpack-plugin用以压缩文件，4.x可用--mode更改模式为production来压缩文件
            // new uglifyjsWebpackPlugin(),
            new copyWebpackPlugin([{
                from: path.resolve(__dirname,"src/assets"),
                to: './pulic'
            }]),
            // 分离css插件参数为提取出去的路径
            new extractTextPlugin("css/index.css"),
            // 消除冗余的css代码
            new purifyCssWebpack({
                // glob为扫描模块，使用其同步方法
                paths: glob.sync(path.join(__dirname, "src/*.html"))
            }),
            // 全局暴露统一入口
            new webpack.ProvidePlugin({
                $: "jquery"
            }),
            // 自动生成html模板
            new htmlWebpackPlugin({
                filename: "index.html",
                title: "xxxx",
                chunks: ['a',"jquery"],  // 按需引入对应名字的js文件
                template: "./src/index.html"
            }),
            new htmlWebpackPlugin({
                chunks: ['b'],
                filename: "index2.html",
                title: "page2",
                template: "./src/index2.html"
            })
        ],
        devServer: {
            contentBase: path.resolve(__dirname, "dist"),
            host: "localhost",
            port: "8090",
            open: true, // 开启浏览器
            hot: true   // 开启热更新
        },
        // 提取js，lib1名字可改
        optimization: {
            splitChunks: {
                cacheGroups: {
                    lib1: {
                        chunks: "initial",
                        name: "jquery",
                        enforce: true
                    }
                }
            }
        }

    }
    ```


### 用户查找、光标、右键功能行为

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * 浏览器搜索功能(ctrl F或js window.find),无需遍历json或后台处理
    ```js
    //有bug，未来可能废弃
    window.find(要搜索的字符串, true区分大小写, true向上搜索, true循环搜索,true全字匹配搜索(该参数无效), true会搜索框架内的文本, true弹出一个搜索对话框);
    ```

    * 用户选择的文本范围或光标的当前位置(window.getSelection或Document.getSelection())
    ```js
    const selection = window.getSelection()
    const selection2 = document.getSelection()
    //属性
    //Selection {anchorNode: text, anchorOffset: 37, focusNode: text, focusOffset: 41, isCollapsed: false, …}
    //>anchorNode: text 选区开始位置所属的节点
    //>anchorOffset: 37 选区开始位置
    //>baseNode: text
    //>baseOffset: 37
    //>extentNode: text
    //>extentOffset: 41
    //>focusNode: text 选区结束位置所属的节点
    //>focusOffset: 41 选区结束位置
    //>isCollapsed: false 选区的起始点和终止点是否位于一个位置
    //>rangeCount: 1 选区中range对象数量(跨越多少个标签)
    //>type: "Range" 选区类型
    //方法
    //containsNode()判断指定的节点是否包含在Selection中
    //更多方法查看mdn
    ```

    * 禁用右键功能
    ```js
    window.oncontextmenu = function () {return false;}
    ```

    * 禁止选中文本
    ```js
    window.onselectstart = function () {return false;}
    ```

    * 禁止复制
    ```js
    document.oncopy = function () {return false;}
    ```

### 表单输入重置与hover提示文字

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * 表单重置

        Form.reset()或点击input type=reset

    * 提交按钮使用图片

        input type=image src

    * hover显示提示文字

        title属性

### 特殊事件与自定义事件

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * 浏览器失去/正常网络连接,navigator.onLine为false/true时，触发事件offline/online
    * 设备的纵横方向改变事件:orientationchange
    * 存储区域（localStorage 或 sessionStorage）被修改,触发 storage 事件
    * Promise 被 reject 且没有 reject 处理,触发 unhandledrejection,值兼容chrome，edge，firefox
    * 自定义事件 CustomEvent
    ```js
    obj.addEventListener("cat", function(e) { process(e.detail)});

    //事件名称：cat，配置项：bubbles默认false不冒泡，cancelable默认false事件不可取消，detail事件初始化时传递的数据.
    var event = new CustomEvent("cat", {
        detail: {
            hazcheeseburger: true
        }
    });
    //继承event所有属性和方法
    //bubbles: false
    //cancelBubble: false
    //cancelable: false
    //composed: false
    //currentTarget: null
    //defaultPrevented: false
    //detail: {hazcheeseburger: true}
    //eventPhase: 0
    //isTrusted: false
    //path: []
    //returnValue: true
    //srcElement: null
    //target: null
    //timeStamp: 480928.11999982223
    //type: "cat"
    //Event.composedPath()
    //Event.preventDefault()
    //Event.stopImmediatePropagation()
    //Event.stopPropagation()
    obj.dispatchEvent(event);
    ```

### DOM树解析和更改与遍历

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * XML/HTML源代码解析为DOM Document：DOMParser.parseFromString，相反操作：XMLSerializer.serializeToString
    ```js
    let parser = new DOMParser(),
    doc = parser.parseFromString(XML/HTML源代码(可url), 指定类型字符串("application/xml","image/svg+xml","text/html","application/xml"));

    var s = new XMLSerializer();
    var d = document;
    var str = s.serializeToString(d);
    ```

    * 监视对DOM树所做更改
    ```js
    let targetNode = document.querySelector(`#id`);

    // 配置
    let config = {
        attributeFilter:[特定属性名称],//要监视的特定属性名称的数组
        attributeOldValue: true,//记录任何有改动的属性的上一个值,无默认值
        attributes: true,//监视元素属性值变更,默认false
        characterData: true,//监视目标节点子树节点所包含的字符数据的变化,无默认值
        characterDataOldValue: true,//记录节点文本的先前值.无默认值
        childList: true,//监视目标节点添加或删除新的子节点,默认false
        subtree: true//监视目标节点子树添加或删除新的子节点,默认false
    };

    // 更改被监测到时执行
    const mutationCallback = (mutationsList) => {
        for(let mutation of mutationsList) {
            let type = mutation.type;
            switch (type) {
                case "childList":
                    console.log("A child node has been added or removed.");
                    break;
                case "attributes":
                    console.log(`The ${mutation.attributeName} attribute was modified.`);
                    break;
                case "subtree":
                    console.log(`The subtree was modified.`);
                    break;
                default:
                    break;
            }
        }
    };

    let observer = new MutationObserver(mutationCallback);

    //开始监测
    observer.observe(targetNode, config);

    //停止监测
    observer.disconnect();
    ```

    * 遍历文档的子树中的所有节点及其位置 document.createTreeWalker()
    ```js
    treeWalker = document.createTreeWalker(根节点, 过滤某些内容节点[option], NodeFilter 对象, 标识符(已废弃));
    ```
    ```js
    var treeWalker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_ELEMENT,
        { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
        false
    );

    var nodeList = [];

    while(treeWalker.nextNode()) nodeList.push(treeWalker.currentNode);
    ```
    1. option
        * NodeFilter.SHOW_ALL -1 显示所有节点
        * NodeFilter.SHOW_ATTRIBUTE 2 显示特性Attr节点 废弃
        * NodeFilter.SHOW_CDATA_SECTION 8 显示CDTA CDATASection 节点 废弃
        * NodeFilter.SHOW_COMMENT 128 显示注释Comment节点
        * NodeFilter.SHOW_DOCUMENT 256 显示文档Document节点
        * NodeFilter.SHOW_DOCUMENT_FRAGMENT 1024 显示文档片段DocumentFragment节点
        * NodeFilter.SHOW_DOCUMENT_TYPE 512 显示文档类型DocumentType节点
        * NodeFilter.SHOW_ELEMENT 1 显示元素Element节点
        * NodeFilter.SHOW_ENTITY 32 显示实体Entity节点 废弃
        * NodeFilter.SHOW_ENTITY_REFERENCE 16 显示实体引用 废弃
        * NodeFilter.SHOW_NOTATION 2048 显示符号Notation 节点 废弃
        * NodeFilter.SHOW_PROCESSING_INSTRUCTION 64 显示处理指令 ProcessingInstruction节点
        * NodeFilter.SHOW_TEXT 4 显示文字Text nodes节点
    2. NodeFilter
    ```js
    var nodeIterator = document.createNodeIterator(
        
        document.getElementById('someId'),

        NodeFilter.SHOW_TEXT,

        { 
            acceptNode: function(node) {
                if ( ! /^\s*$/.test(node.data) ) {
                    return NodeFilter.FILTER_ACCEPT;
                    //return NodeFilter.FILTER_REJECT;
                    //return NodeFilter.FILTER_SKIP;
                }
            }
        },
        false
    );

    var node;

    while ((node = nodeIterator.nextNode())) {
        alert(node.data);
    }
    ```


### js获取视频第一帧

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

    [JS获取HTML video标签视频第一帧](https://blog.csdn.net/weixin_33915554/article/details/92002316)

    [Dynamically using the first frame as poster in HTML5 video?](https://stackoverflow.com/questions/7323053/dynamically-using-the-first-frame-as-poster-in-html5-video)

2. 详解：

    * loadeddata事件:媒体资源的第一帧加载完成时被触发
    ```js
    //部分浏览器生效
    <video id="video" src="/1.MP4" controls></video>//资源不跨域
    <div id="output"></div>
    $(()=>{
        var output = document.getElementById("output");
        var video = document.getElementById("video");
        video.addEventListener('loadeddata', function () {
            var canvas = document.createElement("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);

            var img = document.createElement("img");
            img.src = canvas.toDataURL("image/png");
            output.appendChild(img);
        });
    })
    ```

    * [Popcorn.js](https://github.com/mozilla/popcorn-js/)
    ```js
    var video = Popcorn("#video-id");

    video.listen("canplayall", function() {
        this.currentTime(10).capture();
    });
    ```

### 浏览器性能数据

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * Window.performance
    ```js
    memory: MemoryInfo
        jsHeapSizeLimit: 2197815296
        totalJSHeapSize: 15563541
        usedJSHeapSize: 12592021
        __proto__: MemoryInfo
    navigation: PerformanceNavigation//网页导航的类型
        redirectCount: 0
        type: 1
        __proto__: PerformanceNavigation
    onresourcetimingbufferfull: null
    timeOrigin: 1571303991051.22
    timing: PerformanceTiming//包含延迟相关的性能信息
        connectEnd: 1571303991051
        connectStart: 1571303991051
        domComplete: 1571303992579
        domContentLoadedEventEnd: 1571303992574
        domContentLoadedEventStart: 1571303992569
        domInteractive: 1571303992569
        domLoading: 1571303992522
        domainLookupEnd: 1571303991051
        domainLookupStart: 1571303991051
        fetchStart: 1571303991051
        loadEventEnd: 1571303992582
        loadEventStart: 1571303992579
        navigationStart: 1571303991049
        redirectEnd: 0
        redirectStart: 0
        requestStart: 1571303991068
        responseEnd: 1571303992519
        responseStart: 1571303992515
        secureConnectionStart: 0
        unloadEventEnd: 1571303992518
        unloadEventStart: 1571303992518
        __proto__: PerformanceTiming
    __proto__: Performance
    //方法
    performance.mark(time)//某一时刻，单位：ms，最高精确到5us
    performance.now()//从某一时刻到调用该方法时刻的毫秒数
    //页面加载时间
    var perfData = window.performance.timing; 
    var pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
    //请求响应时间
    var connectTime = perfData.responseEnd - perfData.requestStart;
    //页面渲染时间
    var renderTime = perfData.domComplete - perfData.domLoading;
    ```

### 媒体查询匹配

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    ```js
    window.matchMedia("(min-width: 400px)")
    //matches: true
    //media: "(min-width: 400px)"
    //onchange: null
    //__proto__: MediaQueryList
    ```

### 浏览器对话与打印

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * window.prompt对话框

    ```js
    用户输入文字 = window.prompt(提示用户输入文字, 文本输入框默认值);
    ```

    * console.assert()断言

    ```js
    const errorMsg = 'the # is not even';
    for (let number = 2; number <= 5; number += 1) {
        console.log('the # is ' + number);
        console.assert(number % 2 === 0, {number: number, errorMsg: errorMsg});
        // 或者使用 ES2015 对象简写:
        // console.assert(number % 2 === 0, {number, errorMsg});
    }
    // 输出:
    // the # is 2
    // the # is 3
    // Assertion failed: {number: 3, errorMsg: "the # is not even"}
    // the # is 4
    // the # is 5
    // Assertion failed: {number: 5, errorMsg: "the # is not even"}
    ```

    * Console.count() Console.countReset() 输出计数

    ```js
    var user = "";

    function greet() {
    console.count();
    return "hi " + user;
    }

    user = "bob";
    greet();
    user = "alice";
    greet();
    greet();
    console.count();
    console.countReset();
    // 输出:
    // "default: 1"
    // "default: 2"
    // "default: 3"
    // "default: 1"
    // "default: 0"
    var user = "";

    function greet() {
    console.count(user);
    return "hi " + user;
    }

    user = "bob";
    greet();
    user = "alice";
    greet();
    greet();
    console.countReset("bob");
    console.count("alice");
    // 输出:
    // "bob: 1"
    // "alice: 1"
    // "alice: 2"
    // "bob: 0"
    // "alice: 3"
    ```

    * console.dir打印对象树

    ```js
    console.dir(object)
    ```

    * Console.dirxml()显示xml/html交互树(可折叠拉伸的标签)

    ```js
    console.dir(object)
    ```

    * console.log console.info console.warn console.error console.debug 输出不同级别信息

    ```js
    console.log(obj1,obj2...)
    console.info(obj1,obj2...)
    console.warn(obj1,obj2...)
    console.error(obj1,obj2...)
    console.debug(obj1,obj2...)
    console.log('String: %s, Int: %d,Float: %f, Object: %o, Style: %c', "字符串", "整数", "浮点数", "对象", "样式")
    console.log('the word is %s try number %d', 'foo', 123)
    console.log(`temp的值为: ${temp}`)
    console.log("%c3D Text"," text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em")
    ```

    * console.group console.groupCollapsed console.groupEnd()输出分组

        * console.group创建新的分组.内容输出当前分组,直到调用console.groupEnd()之后,结束分组
        * console.groupCollapsed与group的区别是输出内容不折叠
        * console.groupEnd结束分组

    * Console.table打印表格

    ```js
    //可点击列名排序
    console.table([["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]])
    //可隐藏指定列
    console.table([["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]],["1"])
    ```

    * console.time console.timeEnd console.timeLog 打印占用时长

        * console.time(timerName)计时开始
        * console.timeEnd(timerName)计时结束，打印经过的时间
        * console.timeLog(timerName)计时结束，打印经过的时间,并带上timer名

    * console.trace()输出堆栈跟踪

### 人工标注文档Range

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

    [JS Range 对象的使用](https://blog.csdn.net/m0_37885651/article/details/88353305)

    [JavaScript之Range--或许会有点用](https://segmentfault.com/a/1190000015142374)

2. 详解：

    * 应用场景：文档标注

    * range储存网页选中文字位置

        * window.getSelection().getRangeAt(0) Selection转Range
        ```js
        collapsed: false//是否起始点和结束点是同一个位置
        commonAncestorContainer: text//返回目标节点的共有祖先节点
        endContainer: text//返回结束的Node
        endOffset: 96//返回结束位置在目标节点起始的偏移值
        startContainer: text//返回开始的Node
        startOffset: 19//返回开始位置在目标节点起始的偏移值
        __proto__: Range
        //方法
        Range.cloneContents()//返回DocumentFragment，可用于插入节点
        Range.cloneRange()//返回被克隆range
        Range.selectNode()//设置range包含整个节点
        Range.selectNodeContents()//设置Range包含节点的内容
        Range.collapse(bool)//设置起始点和结束点是否折叠
        Range.compareBoundaryPoints(how, sourceRange)//返回边界节点与指定范围对比
        //how:
        //Range.END_TO_END尾与尾对比
        //Range.END_TO_START尾与始对比
        //Range.START_TO_END始与尾对比
        //Range.START_TO_START始与始对比
        //返回值：-1,0,1表示前于，相同，后于
        Range.comparePoint(新节点，偏移量)//节点与新节点的偏移量比较，返回值：-1,0,1表示前于，相同，后于
        Range.createContextualFragment(string)//字符串转DocumentFragment
        Range.deleteContents()//移除内容
        Range.detach()//使range锁定或解锁
        documentFragment = range.extractContents()//range转documentFragment
        boundingRect = range.getBoundingClientRect()//返回矩形
        rectList = range.getClientRects()//返回矩形列表
        Range.insertNode(新节点)//在Range的起始位置插入节点
        bool = range.intersectsNode(节点)//判断节点与范围是否相交
        bool = range.isPointInRange(新节点，偏移量)//判断节点的偏移量与范围是否相交
        Range.setEnd(新节点，偏移量)//设置Range结束位置
        Range.setEndAfter(节点)//设置Range结束位置在指定节点之后
        Range.setEndBefore(节点)//设置Range结束位置在指定节点之前
        Range.setStart(新节点，偏移量)//设置Range起始位置
        Range.setStartAfter(节点)//设置Range起始位置在指定节点之后
        Range.setStartBefore(节点)//设置Range起始位置在指定节点之前
        Range.surroundContents(新节点)//将Range内容移动到新节点
        text = range.toString()//Range序列化字符串
        ```

        * 手动创建Range

        ```js
        var range = document.createRange();
        range.setStart(startContainer, startOffset);
        range.setEnd(endContainer, endOffset);
        ```

        * xpath(xml路径语言)和range互转
        ```js
        function getElementXPath (element) {
            if (!element) return null

            if (element.id) {
                return `//*[@id=${element.id}]`
            } else if (element.tagName === 'BODY') {
                return '/html/body'
            } else {
                const sameTagSiblings = Array.from(element.parentNode.childNodes)
                .filter(e => e.nodeName === element.nodeName)
                const idx = sameTagSiblings.indexOf(element)

                return getElementXPath(element.parentNode) +
                '/' +
                element.tagName.toLowerCase() +
                (sameTagSiblings.length > 1 ? `[${idx + 1}]` : '')
            }
        }
        function createRangeFromXPathRange (xpathRange) {
            var startContainer,
            endContainer,
            endOffset,
            evaluator = new XPathEvaluator()

            // must have legal start and end container nodes
            startContainer = evaluator.evaluate(
                xpathRange.startContainerPath,
                document.documentElement,
                null,
                XPathResult.FIRST_ORDERED_NODE_TYPE,
                null
            )
            if (!startContainer.singleNodeValue) {
                return null
            }

            if (xpathRange.collapsed || !xpathRange.endContainerPath) {
                endContainer = startContainer
                endOffset = xpathRange.startOffset
            }
            else {
                endContainer = evaluator.evaluate(
                    xpathRange.endContainerPath,
                    document.documentElement,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                )
                if (!endContainer.singleNodeValue) {
                    return null
                }

                endOffset = xpathRange.endOffset
            }

            // map to range object
            var range = document.createRange()
            range.setStart(startContainer.singleNodeValue, xpathRange.startOffset)
            range.setEnd(endContainer.singleNodeValue, endOffset)
            return range
        }
        ```


### height和top与y
1. 参考链接：

    [Measuring Element Dimension and Location with CSSOM in Windows Internet Explorer 9](https://docs.microsoft.com/en-us/previous-versions/hh781509(v=vs.85))

    [getBoundingClientRect的用法](https://www.cnblogs.com/Songyc/p/4458570.html)

    [js窗口尺寸获取常用属性](https://blog.csdn.net/csdnxcn/article/details/77886499)

2. 详解：

    外层蓝色父元素与包裹内层红色子元素，虚线与实线间为margin，深色区为border-width，内虚线到深色区为padding，内层灰色区为滚动区。

    ![position1](./position1.png)
    ![position2](./position2.png)
    ![position3](./position3.png)

    * object.getBoundingClientRect()

        获取元素相对于视窗的位置集合，集合中有top, right, bottom, left等属性。

        ![getBoundingClientRect](./getBoundingClientRect.jpg)

    * height相关

        * box-sizing:border-box怪异模式

            totalHeight=contentHeight(padding向内收)+margin

        * box-sizing:content-box标准模式

            totalHeight=contentHeight+padding(padding向外张)+border+margin

    * scroll相关

        * scrollTop:距离滚动区顶部距离
        * scrollHeight:滚动区高度

    * offset相关

        * offsetTop:距离父元素顶部距离(不包含边线)
        * offsetHeight:距离父元素顶部距离(包含边线)
        * offsetY:指针距离元素顶部距离(不含border，旋转不变)

    * layer相关

        * layerY:指针距离元素顶部距离(含border，旋转不变)

    * client相关

        * clientTop:边框厚度，相当于borderTopWidth
        * clientHeight:包含padding的内容高度，不包括滚动
        * clientY:指针距离可视区顶部距离

    * page相关

        * pageY:指针距离文档顶部距离

    * screen相关

        * screenY:指针距离屏幕顶部距离

    * y:指针相对于当前文档y坐标

### 页面复制文字时自动加版权
1. 参考链接：

    [JS实现页面复制文字时自动加版权](https://blog.csdn.net/lzuacm/article/details/88197591)

2. 详解：

    利用chrome查看网站触发某事件(如copy)时的代码:

        F12-source-Event Listener Breakpoints-选择事件打勾-触发事件

        可以看到csdn使用copyright.js，百度即可，或搜索“js加版权”

    ```js
    $(document).on('copy', function(e)
    {
        var selected = window.getSelection();
        var selectedText = selected.toString().replace(/\n/g, '<br>');
        var copyFooter = '<br>---------------------<br>著作权归作者所有。<br>' 
                                + '商业转载请联系作者获得授权，非商业转载请注明出处。<br>'
                                + '作者：Bravo Yeung<br> 源地址：' + document.location.href
                                + '<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！';
        var copyHolder = $('<div>', {id: 'temp', html: selectedText + copyFooter, style: {position: 'absolute', left: '-99999px'}});
        //创建div，内容为选中的文字+附加的内容，位置设为不可见
        $('body').append(copyHolder);
        selected.selectAllChildren(copyHolder[0]);//把指定元素的所有子元素设为选中区域，并取消之前的选中区域
        window.setTimeout(function() {
            copyHolder.remove();
        },0);
    });
    ```
    ```js
    var ua = navigator.userAgent.toLowerCase();
    if (window.ActiveXObject) {  /* 兼容IE */
        document.body.oncopy = function () {
            event.returnValue = false;
            var selectedText = document.selection.createRange().text;
            var pageInfo = '<br>---------------------<br>著作权归作者所有。<br>'
                + '商业转载请联系作者获得授权，非商业转载请注明出处。<br>'
                + '作者：Bravo Yeung<br> 源地址：' + document.location.href
                + '<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！';
            clipboardData.setData('Text', selectedText.replace(/\n/g, '<br>') + pageInfo);
        }
    }
    else {
        function addCopyRight() {
            var body_element = document.getElementsByTagName('body')[0];
            var selection = window.getSelection();
            var pageInfo = '<br>---------------------<br>著作权归作者所有。<br>'
                + '商业转载请联系作者获得授权，非商业转载请注明出处。<br>'
                + '作者：Bravo Yeung<br> 源地址：' + document.location.href
                + '<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！';
            var copyText = selection.toString().replace(/\n/g, '<br>') + pageInfo;
            var newDiv = document.createElement('div');
            newDiv.style.position = 'absolute';
            newDiv.style.left = '-99999px';
            body_element.appendChild(newDiv);
            newDiv.innerHTML = copyText;
            selection.selectAllChildren(newDiv);
            window.setTimeout(function () {
                body_element.removeChild(newDiv);
            }, 0);
        }
        document.oncopy = addCopyRight;
    }
    ```

## 后端篇

### 消息队列

1. 参考链接：

2. 详解：

    在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

    AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。

### 存储过程

1. 参考链接：

    [存储过程和函数](https://www.cnblogs.com/doudouxiaoye/p/5811836.html)

2. 详解：

    存储过程就是一条或多条SQL语句的集合，可视为批文件，但是起作用不仅限于批处理。

### 数据库读写分离

1. 参考链接：

    [想用数据库“读写分离” 请先明白“读写分离”解决什么问题](https://baijiahao.baidu.com/s?id=1614304400276051465&wfr=spider&for=pc)

    [浅谈高性能数据库集群——读写分离](https://www.jianshu.com/p/eba38b1ff43c?utm_source=coffeephp.com)

2. 详解：

    将数据库分为主从库，一个主库用于写数据，多个从库完成读数据的操作，主从库之间通过某种机制进行数据的同步,提升数据库的读写性能

### SQL分页

1. 参考链接：

    [SQL server分页的四种方法](https://blog.csdn.net/weixin_37610397/article/details/80892426#max_43)

2. 详解：

    * 三重循环
    ```sql
    select * from 
    (select top pageSize * from 
    (select top (pageIndex*pageSize) * from Questions order by id asc ) as q1 
    order by id desc ) as q2
    order by id asc
    ```

    * 利用max（id）
    ```sql
    select top pageSize * from Questions where id >=
    (select max(id) from 
    (select top ((pageIndex-1)*pageSize+1) id from Questions order by id asc) as q1) 
    order by id;
    ```

    * 利用row_number
    ```sql
    select top pageSize * from 
    (select row_number() over(order by id asc) as rownumber,* from Questions) q1
    where rownumber>((pageIndex-1)*pageSize);
    ```

    * offset /fetch next（2012版本及以上才有）
    ```sql
    select * from Questions order by id 
    offset ((pageIndex-1)*pageSize) rows
    fetch next pageSize rows only;
    ```

    * 封装的存储过程
    ```sql
    create procedure paging_procedure
    (	@pageIndex int,
        @pageSize int
    )
    as
    begin 
        --实现方法
    end

    --调用
    exec paging_procedure @pageIndex=2,@pageSize=8;
    ```

### SQL索引原理

1. 参考链接：

    [深入浅出数据库索引原理](https://www.cnblogs.com/aspwebchh/p/6652855.html)

2. 详解：

    * 索引的生成

        把平铺堆叠的数据变为平衡树，查询时无需逐一查找，而是变为n分查找，提高了查询效率，但增删改导致数据变化，因此需要梳理平衡树，导致降低了增删改效率。

    * 聚集索引：主键
    * 非聚集索引：index

    * sql

        create index index_name on table_name(column_name);

## 服务器篇

### linux服务器定时执行任务

1. 参考链接：

    [Centos7 利用crontab定时执行任务及配置方法](https://www.cnblogs.com/p0st/p/9482167.html)

    [CentOs 7.0实现定时任务（定时访问网页）](https://blog.csdn.net/qq_16505093/article/details/51478064)

2. 详解：

    crond 和 crontab
    ```txt
    1、crontab -e，进入编辑界面 
    2、输入/2 * * * * curl http://www.baidu.com，表示每两分钟访问一次网页 
    3、保存退出，然后service crond start启动服务 
    4、chkconfig crond on设置开机自启动 
    5、 
    基本格式 : 
    *　　*　　*　　*　　*　　command 
    分　 时　 日　 月　 周　 命令 
    第1列表示分钟1～59 每分钟用或者 /1表示 
    第2列表示小时1～23（0表示0点） 
    第3列表示日期1～31 
    第4列表示月份1～12 
    第5列标识号星期0～6（0表示星期天）
    crond不支持精确到秒
    ```
