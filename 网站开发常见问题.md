# 网站开发常见问题

* [前端篇](#前端篇)
    * [unicode和utf编解码的原理和不同](#unicode和utf编解码的原理和不同)
    * [base64和二进制的不同](#base64和二进制的不同)
    * [绑定事件的不同种方式，执行顺序，事件委托](#绑定事件的不同种方式，执行顺序，事件委托)
    * [css旋转、拖拽、手势移动](#css旋转、拖拽、手势移动)
    * [http状态码和使用场景](#http状态码和使用场景)
    * [前端截图上传服务器实现](#前端截图上传服务器实现)
    * [获取图片上传进度](#获取图片上传进度)
    * [无限滚动](#无限滚动)
    * [持久化存储](#持久化存储)
    * [js数据类型与隐式转换](#js数据类型与隐式转换)
    * [js事件循环机制](#js事件循环机制)
    * [闭包数据缓存](#闭包数据缓存)
    * [页面加载生成过程](#页面加载生成过程)
    * [http请求方式](#http请求方式)
    * [网络协议与7层结构](#网络协议与7层结构)
    * [前端模块化](#前端模块化)
    * [for-in,for-of,foreach区别](#for-in,for-of,foreach区别)
    * [arguments,...values,callee,caller,this,call,apply,bind用法](#arguments,...values,callee,caller,this,call,apply,bind用法)
    * [日历的实现](#日历的实现)
    * [深复制的实现](#深复制的实现)
    * [overflow:hidden清除浮动的原理](#overflow:hidden清除浮动的原理)
    * [前端路由原理](#前端路由原理)
    * [强制缓存和协商缓存](#强制缓存和协商缓存)
    * [节流和防抖](#节流和防抖)
    * [xss和csrf](#xss和csrf)
    * [js函数柯里化](#js函数柯里化)
    * [js依赖注入与控制反转](js依赖注入与控制反转)
    * [gulp和webpack](#gulp和webpack)
    * [用户查找、光标、右键功能行为](#用户查找、光标、右键功能行为)
    * [表单输入重置与hover提示文字](#表单输入重置与hover提示文字)
    * [特殊事件与自定义事件](#特殊事件与自定义事件)
    * [DOM树解析和更改与遍历](#DOM树解析和更改与遍历)
    * [js获取视频第一帧](#js获取视频第一帧)
    * [浏览器性能数据](#浏览器性能数据)
    * [媒体查询匹配](#媒体查询匹配)
    * [浏览器对话与打印](#浏览器对话与打印)
    * [人工标注文档Range](#人工标注文档Range)
    * [height和top与y](#height和top与y)
    * [页面复制文字时自动加版权](#页面复制文字时自动加版权)
    * [delete操作符](#delete操作符)
    * [数组模拟dictionary与二重排序](#数组模拟dictionary与二重排序)
    * [已知或者未知宽度的垂直水平居中](#已知或者未知宽度的垂直水平居中)
    * [简单实现双向数据绑定mvvm](#简单实现双向数据绑定mvvm)
    * [三角形](#三角形)
    * [webWorker与serviceWorker](#webWorker与serviceWorker)
    * [js设计模式](#js设计模式)
    * [运算符优先级](#运算符优先级)
    * [作用域与变量](#作用域与变量)
    * [virtualDOM_Diff](#virtualDOM_Diff)
    * [实现instanceof](#实现instanceof)
    * [抽象语法树AST与babel](#抽象语法树AST与babel)
    * [前端SEO与踩过的坑](#前端SEO与踩过的坑)
    * [websocket](#websocket)
    * [变量的解构赋值](#变量的解构赋值)
    * [文件内容读取](#文件内容读取)
    * [js异步加载](js异步加载)
    * [promise.all实现](#promise.all实现)
    * [便捷的函数与方法](#便捷的函数与方法)
    * [可迭代对象](#可迭代对象)
    * [url的含义](#url的含义)
    * [reflect](#reflect)
    * [图片懒加载](#图片懒加载)
    * [jsonp](#jsonp)
    * [ajax](#ajax)
* [后端篇](#后端篇)
    * [JSON_Web_Token](#JSON_Web_Token)
    * [灰度发布](#灰度发布)
    * [消息队列](#消息队列)
    * [存储过程](#存储过程)
    * [数据库读写分离](#数据库读写分离)
    * [SQL分页](#SQL分页)
    * [SQL索引原理](#SQL索引原理)
* [服务器篇](#服务器篇)
    * [linux服务器定时执行任务](#linux服务器定时执行任务)
    * [高性能系统](#高性能系统)
* [架构协同篇](#架构协同篇)
    * [DevOps](#DevOps)

## 前端篇

### unicode和utf编解码的原理和不同

1. 参考链接：

    [Unicode和UTF-8字符串编码解码原理](https://blog.csdn.net/Enl0ve/article/details/82844484)

    [Unicode 和 UTF-8、UTF-16之间的区别](https://blog.csdn.net/zengchen__acmer/article/details/75332190)

    [【编码】ASCII、Unicode、GBK和UTF-8字符编码的区别联系](https://blog.csdn.net/u010262331/article/details/46013905)

    [各种常见编码的转换算法](https://blog.csdn.net/xiaolongwang2010/article/details/10311397)

2. 详解：

    Unicode是字符集，而UTF-8是编码规则

    字符集为每一个字符分配一个唯一的ID(学名为码位/码点/Code Point)，而「编码规则」则是将「码位」转换为字节序列的规则。

    起初Unicode规定每个字符都是用 2个字节来表示，但是由于英文字符等只需要一个字节就可以表，那就造成了在保存英文文本时，就会浪费一倍的空间。

    UTF-8是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

    ```txt
    例如「田」的码位是30000，记作U+7530(30000的16进制为0x7530)。
    U+ 0000 ~ U+ 007F: 0XXXXXXX
    U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
    U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
    U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
    
    根据上表中的编码规则，之前的「田」字的码位 U+7530 属于第三行的范围：
    
        7    5    3    0   
        0111 0101 0011 0000    二进制的 7530
    --------------------------
        0111   011111   100101 二进制的 77E5
    1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
    11100111 10010100 10110000 代入模版
    E   7    9   4    B   0
    
    这就是将 U+7530 按照 UTF-8 编码为字节序列 E794B0 的过程。反之亦然。
    ```

    UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。

### base64和二进制的不同

1. 参考链接：

    [让你完全理解base64是怎么回事](https://www.cnblogs.com/sweeeper/p/8462077.html)

    [一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770)

    [JavaScript用btoa和atob来编码解码Base64](https://my.oschina.net/itblog/blog/1613977)

    [原生JS实现base64解码与编码](https://imweb.io/topic/5b8ea5327cd95ea86319358a)

2. 详解：

    Base64编码可以将任意一组字节转换为较长的常见文本字符序列,将用户输入或二进制数据，打包成一种安全格式发送出去，无须担心其中包含冒号、换行符或二进制值等特殊字符。

    ```txt
    例子：输入Ow!

    (1) 字符串"Ow!"被拆分成3个8位的字节(0x4F、0x77、0x21)

    (2) 这3个字节构成了一个24为的二进制01001111 01110111 00100001

    (3) 这些为被划分为一些6位的序列010011、110111、011100、100001,(若不能正好平均分成每段6位，则按6和8的最小公倍数在末尾补0，位数为6和8的最小公倍数，000000用填充码=表示)

    (4) 每个6位值都表示了从0～63之间的数字，对应base64字母表中的64个字符之一。得到的base64编码字符串是4个字符的字符串“T3ch”。然后就可以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些移植性最好的字符(字母、数字等)。

    a:a -- 011000 010011 101001 100001 -- YTph

    a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==

    a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=

    a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 100001 -- YTphYWFh
    ```
    ```txt
    编码表：

    0　A　　17　R　　　34　i　　　51　z

    1　B　　18　S　　　35　j　　　52　0

    2　C　　19　T　　　36　k　　　53　1

    3　D　　20　U　　　37　l　　　54　2

    4　E　　21　V　　　38　m　　　55　3

    5　F　　22　W　　　39　n　　　56　4

    6　G　　23　X　　　40　o　　　57　5

    7　H　　24　Y　　　41　p　　　58　6

    8　I　　25　Z　　　42　q　　　59　7

    9　J　　26　a　　　43　r　　　60　8

    10　K　　27　b　　　44　s　　　61　9

    11　L　　28　c　　　45　t　　　62　+

    12　M　　29　d　　　46　u　　　63　/

    13　N　　30　e　　　47　v

    14　O　　31　f　　　48　w　　　

    15　P　　32　g　　　49　x

    16　Q　　33　h　　　50　y
    ```
    btoa和atob是window对象的两个函数，其中btoa是binary to ascii，用于将binary的数据用ascii码表示，即Base64的编码过程，而atob则是ascii to binary，用于将ascii码解析成binary数据
    ```js
    //方法实现
    var a = 'Hello World!';
    var encodedString = btoa(string);
    console.log(encodedString); // Outputs: "SGVsbG8gV29ybGQh"
    var decodedString = atob(encodedString);
    console.log(decodedString); // Outputs: "Hello World!"
    //涉及中文时，需要encodeURIComponent
    var b = "Hello, 中国！";
    //"SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE="
    var encodedString2 = btoa(encodeURIComponent(b));
    var decodedString2 = decodeURIComponent(atob(encodedString2));
    console.log(decodedString2); //"Hello, 中国！"
    ```

### 绑定事件的不同种方式，执行顺序，事件委托

1. 参考链接：

    [看懂此文，不再困惑于javascript中的事件绑定、事件冒泡、事件捕获和事件执行顺序](https://blog.csdn.net/aitangyong/article/details/43231111)

    [js中的事件委托或是事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)

2. 详解：

    3种方式：
    ```html
    <p id="btn" onclick="hello()"></p>
    <script>
        document.getElementById("btn").onclick = function(){}
        document.getElementById("btn").addEventListener("click",function(){})
    </script>
    ```
    其中addEventListener可重复绑定同一元素，先绑定先执行。

    对于层叠元素，则需要区分事件冒泡和事件捕获，冒泡：从底向面，捕获：从面向底。addEventListener((type, listener, useCapture)
    
    阻止冒泡：只执行当前元素事件，不执行层叠元素事件。event.stopPropagation()

    事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如ul下有很多li，逐一绑定事件很影响性能，且新li加入也要重新绑定事件，会十分麻烦，所以li事件需要委托其上一级ul代为执行事件。
    ```js
    window.onload = function(){
    　　var oUl = document.getElementById("ul1");
    　　oUl.onclick = function(ev){
    　　　　var ev = ev || window.event;
    　　　　var target = ev.target || ev.srcElement;
    　　　　if(target.nodeName.toLowerCase() == 'li'){
    　 　　　　　　	alert(123);
    　　　　　　　  alert(target.innerHTML);
    　　　　}
    　　}
    }
    ```

### css旋转、拖拽、手势移动

1. 参考链接：

    [CSS3动画（360度旋转、旋转放大、放大、移动）](https://www.cnblogs.com/guozhe/p/5912664.html)

    [HTML5 CSS3 专题 : 拖放 （Drag and Drop）](https://www.cnblogs.com/wzjhoutai/p/6858022.html)

2. 详解：

    关键词：transform,translate,scale,rotate,transition,animation,@keyframes,drag系列事件,cursor


### http状态码和使用场景

1. 参考链接：

    [HTTP状态码（HTTP Status Code）及常用场景](https://www.cnblogs.com/QQParadise/p/5019860.html)

2. 详解：
    ```txt
    常见状态码：
    HTTP: Status 200 – 服务器成功返回网页
    HTTP: Status 3xx - 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
    HTTP: Status 404 – 请求的网页不存在
    HTTP: Status 503 – 服务不可用
    ```

### 前端截图上传服务器实现

1. 参考链接：

    [浅析 js 实现网页截图的两种方式](https://juejin.im/entry/58b91491570c35006c4f7fdf)

2. 详解：

    * canvas思路:(html2canvas)
    ```txt
    将dom转换成canvas图片。

    递归取出目标模版的所有DOM节点，填充到一个rederList，并附加是否为顶层元素/包含内容的容器 等信息

    通过z-index postion float等css属性和元素的层级信息将rederList排序，计算出一个canvas的renderQueue

    遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等

    将画好的canvas填充进页面
    ```
    优缺点:复杂度高，稳定性强。

    * svg思路:(rasterizeHTML.js)
    ```txt
    svg的标签里有个foreignObject标签，可以加载其它命名空间的xml(xhtml)文档,只需要将要渲染的DOM扔进<foreignObject></foreignObject>，利用Blob构建svg图像。
    通过一系列的hack技巧替我们绕过了许多限制:
    1.将<img/>的url 转为 dataURI
    2.将background-color从style中取出，修改url后重新插入样式表
    3.将link的的样式通过ajax down下来然后注入<style></sytle>
    ```
    优缺点:简单，只能对已经存在的静态资源进行处理，而对js动态生成并不能实时处理。

    * 上传
    ```js
    var fd = new FormData();
    fd.append("img", imgBlob);
    $.ajax({
        type: "POST",
        url: "http://tmpfile.coding.io/img",
        dataType: 'json',
        data: fd,
        crossDomain: true,
        processData: false,
        contentType: false,
        success: function(data){
            if(data && data.path) {    
            console.log("http://tmpfile.coding.io/tmp" + data.path);
            }
        }
    });
    ```

### 获取图片上传进度

1. 参考链接：

    [XHR简介](https://www.cnblogs.com/syfwhu/p/6116323.html)

    [深入理解ajax系列第一篇——XHR对象](https://www.cnblogs.com/yibutian/p/9456248.html)

    [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

    [使用原生JS 或jquery ajax 获取上传图片实时进度](https://segmentfault.com/a/1190000012871456)

    [JS、JQ实现图片上传，文件上传、带进度条上传的几种方法](https://blog.csdn.net/qq_38740171/article/details/82999793)

2. 详解：

    * 常用只读属性：

        (1) XMLHttpRequest.readyState 返回unsigned short，状态码:
        * 0	UNSENT 代理被创建，但尚未调用 open() 方法。
        * 1	OPENED open() 方法已经被调用。
        * 2	HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。
        * 3	LOADING	下载中,responseText 属性已经包含部分数据。
        * 4	DONE 下载操作已完成。

        (2) XMLHttpRequest.response 返回ArrayBuffer、Blob、Document、DOMString，具体是哪种类型取决于XMLHttpRequest.responseType的值。其中包含响应体body。

        (3)XMLHttpRequest.responseText 返回string或null

        (4)XMLHttpRequest.responseURL 返回响应的序列化URL

        (5)XMLHttpRequest.responseXML 返回一个Document，其中包含该请求的响应
        * 如果响应的内容类型是'text/xml'或'application/xml'，这个属性中将保存着响应数据的XML DOM文档(document形式)

        (6)XMLHttpRequest.status 返回unsigned short，请求响应状态
        * UNSENT（未发送） 0
        * OPENED（已打开） 0
        * LOADING（载入中） 200
        * DONE（完成） 200

        (7)XMLHttpRequest.statusText 返回string，响应状态文本
        * UNSET
        * OPENED
        * LOADING
        * DONE
        * OK
        * Not Found

    * 常用属性：

        (1) XMLHttpRequest.responseType 响应数据的类型：text、arraybuffer、blob、document、json

    * 常用方法：

        (1)XMLHttpRequest.abort() 中止请求

        (2)XMLHttpRequest.getAllResponseHeaders() 返回所有用CRLF分隔的响应头,string或null
        ```js
        var request = new XMLHttpRequest();
        request.open("GET", "foo.txt", true);
        request.send();

        request.onreadystatechange = function() {
        if(this.readyState == this.HEADERS_RECEIVED) {

            // Get the raw header string
            var headers = request.getAllResponseHeaders();

            // Convert the header string into an array
            // of individual headers
            var arr = headers.trim().split(/[\r\n]+/);

            // Create a map of header names to values
            var headerMap = {};
            arr.forEach(function (line) {
                var parts = line.split(': ');
                var header = parts.shift();
                var value = parts.join(': ');
                headerMap[header] = value;
            });

            var contentType = headerMap["content-type"];//text/html; charset=utf-8
        }

        /*
        date: Fri, 08 Dec 2017 21:04:30 GMT\r\n
        content-encoding: gzip\r\n
        x-content-type-options: nosniff\r\n
        server: meinheld/0.6.1\r\n
        x-frame-options: DENY\r\n
        content-type: text/html; charset=utf-8\r\n
        connection: keep-alive\r\n
        strict-transport-security: max-age=63072000\r\n
        vary: Cookie, Accept-Encoding\r\n
        content-length: 6502\r\n
        x-xss-protection: 1; mode=block\r\n
        */
        ```

        (3)XMLHttpRequest.getResponseHeader(name) 返回包含指定响应头的字符串,string或null，name如"Content-Type"

        (4)XMLHttpRequest.open(method, url, async, user, password) 初始化一个请求
        * method:get,post,put,delete
        * async:是否异步
        * user和password用于认证

        (5)XMLHttpRequest.overrideMimeType() 重写由服务器返回的MIME type,默认"text/xml"

        (6)XMLHttpRequest.send() 发送请求

        (7)XMLHttpRequest.setRequestHeader(header, value) 设置HTTP请求头的值

    * 事件：

        (1)onloadstart 开始

        (2)onprogress 数据传输进行中

        (3)onabort 终止

        (4)onerror 失败

        (5)onload 成功

        (6)ontimeout 超时

        (7)onloadend 完成（不论成功与否）

        (8)onreadystatechange readyState属性发生变化

    * 获取上传图片实时进度

    ```js
    $.ajax({
        url: 'URL',
        type: 'POST',
        data: data,
        processData: false, //用来回避jquery对formdata的默认序列化，XMLHttpRequest会对其进行正确处理  
        contentType: false, //设为false才会获得正确的conten-Type  
        xhr: function() { //用以显示上传进度  
            var xhr = $.ajaxSettings.xhr();
            if (xhr.upload) {
                xhr.upload.addEventListener('progress', function(event) {
                    var percent = Math.floor(event.loaded / event.total * 100);
                    $("#progress .progress-item").css("width",percent + "%");
                }, false);
            }
        },
        success: function(data) {

        }
    })

    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'url');
    // 上传完成后的回调函数
    xhr.onreadystatechange = function() {
        if (xhr.status === 200) {　　
            console.log(xhr.responseText);
        } else {　
            console.log('上传出错');
        }
    };
    // 获取上传进度
    xhr.upload.onprogress = function(event) {
        console.log(event.loaded)
        console.log(event.total)
        if (event.lengthComputable) {
            var percent = Math.floor(event.loaded / event.total * 100);
            document.querySelector("#progress .progress-item").style.width = percent + "%";
            // 设置进度显示
            console.log(percent)
        }
    };
    xhr.send(data);
    ```

### 无限滚动

1. 参考链接：

    [原生js之列表优化-无限滚动实例](https://www.jianshu.com/p/f57272d4276d)

2. 详解：

    关键词：onscroll,scrollTop

    onscroll 与 onwheel: onwheel是鼠标滚轮旋转, 而onscroll 处理的是对象内部内容区的滚动事件


### 持久化存储

1. 参考链接：

    [持久化存储与HTTP缓存](https://www.jianshu.com/p/71163b408940)

    [理解cookie、session、localStorage、sessionStorage之不同](https://blog.csdn.net/qq_35585701/article/details/81393361)

    [浏览器数据库 IndexedDB 入门教程](http://www.ruanyifeng.com/blog/2018/07/indexeddb.html)

2. 详解：

    * LocalStorage

        关闭浏览器后，数据不会丢失
        ```js
        //1. 添加键、值
        localStorage.setItem(key, value)
        //2. 获得键、值
        localStorage.getItem(key)
        //3.清空localStorage
        localStorage.clear()
        ```
        特点：
        * LocalStorage跟HTTP无关，发送请求不会带上LocalStorage的值
        * 只有相同域名的页面才能互相读取LocalStorage
        * 每个域名 localStorage 最大存储量为 5Mb 左右（每个浏览器不一样）
        * 常用场景：浏览器端储存数据（不能记录密码等敏感信息）
        * LocalStorage 永久有效，除非用户清理缓存

    * SessionStorage

        会话结束后，数据丢失
        ```js
        //1. 添加键、值
        sessionStorage.setItem(key, value)
        //2. 获得键、值
        sessionStorage.getItem(key)
        //3.清空sessionStorage
        sessionStorage.clear()
        ```
        特点同上

    * indexdb

        * 描述

            IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。

        * 特点

            1. 键值对储存
            2. 异步
            3. 支持事务（transaction）
            4. 同源限制
            5. 储存空间大
            6. 支持二进制储存

        * 储存路径

            1. windows版本

            C:\Users\用户\AppData\Local\Google\Chrome\User Data\Default\IndexedDB

            2. linux版本

            /home/用户/.config/google-chrome/Default/IndexedDB/

        * 操作

            ```js
            //打开数据库
            var request = window.indexedDB.open(databaseName, version);
            request.onerror = function (event) {
                console.log('数据库打开报错');
            };
            var db;
            request.onsuccess = function (event) {
                db = request.result;
                console.log('数据库打开成功');
            };
            var db;
            //如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件(数据库从无到有的新建过程也触发此事件)
            request.onupgradeneeded = function (event) {//新建数据库
                db = event.target.result;
                //新建表
                var objectStore;
                if (!db.objectStoreNames.contains('person')) {
                    objectStore = db.createObjectStore(
                        'person',
                        { keyPath: 'id' },//主键是id
                        { autoIncrement: true },//自增
                    );
                    //创建索引
                    objectStore.createIndex('name', 'name', { unique: false });
                    objectStore.createIndex('email', 'email', { unique: true });
                }
            }
            //通过事务添加数据
            function add() {
                var request = db.transaction(['person'], 'readwrite')
                    .objectStore('person')
                    .add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });

                request.onsuccess = function (event) {
                    console.log('数据写入成功');
                };

                request.onerror = function (event) {
                    console.log('数据写入失败');
                }
            }
            //读取数据
            function read() {
                var transaction = db.transaction(['person']);
                var objectStore = transaction.objectStore('person');
                var request = objectStore.get(1);

                request.onerror = function(event) {
                    console.log('事务失败');
                };

                request.onsuccess = function( event) {
                    if (request.result) {
                        console.log('Name: ' + request.result.name);
                        console.log('Age: ' + request.result.age);
                        console.log('Email: ' + request.result.email);
                    } else {
                        console.log('未获得数据记录');
                    }
                };
            }
            //遍历数据
            function readAll() {
                var objectStore = db.transaction('person').objectStore('person');

                objectStore.openCursor().onsuccess = function (event) {
                    var cursor = event.target.result;

                    if (cursor) {
                        console.log('Id: ' + cursor.key);
                        console.log('Name: ' + cursor.value.name);
                        console.log('Age: ' + cursor.value.age);
                        console.log('Email: ' + cursor.value.email);
                        cursor.continue();
                    } else {
                        console.log('没有更多数据了！');
                    }
                };
            }
            //更新数据
            function update() {
                var request = db.transaction(['person'], 'readwrite')
                    .objectStore('person')
                    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });

                request.onsuccess = function (event) {
                    console.log('数据更新成功');
                };

                request.onerror = function (event) {
                    console.log('数据更新失败');
                }
            }
            //删除数据
            function remove() {
                var request = db.transaction(['person'], 'readwrite')
                    .objectStore('person')
                    .delete(1);

                request.onsuccess = function (event) {
                    console.log('数据删除成功');
                };
            }
            //使用索引
            var transaction = db.transaction(['person'], 'readonly');
            var store = transaction.objectStore('person');
            var index = store.index('name');
            var request = index.get('李四');

            request.onsuccess = function (e) {
                var result = e.target.result;
                if (result) {
                    // ...
                } else {
                    // ...
                }
            }
            ```

    * Cookie

        Cookie是存放在浏览器端的数据，每次都随请求发送给 Server。存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie。

        特点：
        * 服务器通过 Set-Cookie 头给客户端一串字符串
        * 客户端每次访问相同域名的网页时，必须带上这段字符串
        * 客户端要在一段时间内保存这个Cookie
        * Cookie 默认在用户关闭页面后就失效，代码可以任意设置 Cookie 的过期时间，max-age和Expires
        * 大小大概在 4kb 以内

        ```js
        function setCookie(cname,cvalue,exdays)
        {
            var d = new Date();
            d.setTime(d.getTime()+(exdays*24*60*60*1000));
            var expires = "expires="+d.toGMTString();
            document.cookie = cname + "=" + cvalue + "; " + expires;
        }

        function getCookie(cname)
        {
            var name = cname + "=";
            var ca = document.cookie.split(';');
            for(var i=0; i<ca.length; i++) 
            {
                var c = ca[i].trim();
                if (c.indexOf(name)==0) return c.substring(name.length,c.length);
            }
            return "";
        }

        function delete(cname){ 
            var date = new Date(); 
            date.setTime(date.getTime()-10000); 
            document.cookie = cname + "=; expires =" + date.toGMTString();
        }
        ```

    * Session

        Session是基于Cookie实现的，它利用一个sessionId把用户的敏感数据隐藏起来，在Set-Cookie上，使用随机数来做sessionId,最终只是把这串随机数暴露给外界，而真正的信息却保存在了服务器端的sessions对象里面。它就像一个密码簿一样，有效的信息与sessionId一一对应,当下次用户访问该网站的其他页面的时候，就会带着登录时服务器给的这个sessionId。

        特点：
        * 将 SessionID（随机数）通过 Cookie 发给客户端
        * 客户端访问服务器时，服务器读取 SessionID
        * 服务器有一块内存（哈希表）保存了所有 session
        * 通过 SessionID 可以得到对应用户的隐私信息
        * 这块内存（哈希表）就是服务器上的所有 session

### js数据类型与隐式转换

1. 参考链接：

    [JS的隐式转换 从 [] ==false 说起](https://www.cnblogs.com/nanchen/p/7905528.html)

    [JS中 [] == ![]结果为true，而 {} == !{}却为false， 追根刨底](https://blog.csdn.net/magic_xiang/article/details/83686224)


    [JavaScript中valueOf、toString的隐式调用](https://www.cnblogs.com/barrior/p/4598354.html)

2. 详解：

    * js数据类型

        原始值（primitives）：undefined， null， booleans， numbers，strings， symbol（es6）

        对象值（objects）：Object

    * 数学运算

        a+b=a的原数据类型+b的原数据类型

        有string为string，没string为number，[].toString()->""，{}.toString()->"[object Object]"

        * [] + [] = "" + "" = ""
        * [] + {} = "" + "[object Object]" = "[object Object]"

    * 比较运算

        * x===y,只有类型和值相等为true,否则为false
        * x == y
            * xy都为Null或undefined为true, null == undefined->true
            * x或y为NaN为false, NaN == NaN->false
            * 如果x和y为String，Number，Boolean并且类型不一致，都转为Number再进行比较
            * 如果存在Object，转换为原始值，比较
            * !可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余都为false

        
        |  value   |toNumber|    toString     |toBoolean|
        |----------|--------|-----------------|---------|
        |   NaN    |  NaN   |      "NaN"      |  false  |
        | Infinity |Infinity|    "Infinity"   |  true   |
        |    []    |   0    |        ""       |  true   |
        |   [1]    |   1    |       "1"       |  true   |
        |   null   |   0    |     "null"      |  false  |
        |undefined |  NaN   |   "undefined"   |  false  |
        |    {}    |  NaN   |"[object Object]"|  true   |
        |function()|  NaN   |   "function"    |  true   |

        ```txt
        []==false,[]==![],[]==0,''==0,""=="" true
        {}==false,{}==!{},{}==0,NaN==0 false
        ```

    * 隐式调用：对象生成时会自动调用(不同对象会有不同的隐式调用)
        * function:toString/valueOf
        * 事件:handleEvent
        * JSON对象:toJSON
        * promise:then
        * object:get/set
        * 遍历器接口:Symbol.iterator

### js事件循环机制

1. 参考链接：

    [详解JavaScript中的Event Loop（事件循环）机制](https://www.cnblogs.com/cangqinglang/p/8967268.html)

    [谈谈 Event Loop（事件循环）机制](https://www.jianshu.com/p/6e9f4eb7fdbb)

    [Javascript异步编程之setTimeout与setInterval详解分析](https://www.cnblogs.com/tugenhua0707/p/4083475.html)

    [理解JavaScript 执行机制及异步回调（setTimeout/setInterval/Promise）](https://blog.csdn.net/zuggs_/article/details/82381558)

    [js 异步执行顺序](https://www.jianshu.com/p/ca480f9e7dea)

    [为什么要用setTimeout模拟setInterval?](https://blog.csdn.net/b954960630/article/details/82286486)

    [详解 setTimeout、setImmediate、process.nextTick 的区别](https://www.cnblogs.com/onepixel/articles/7605465.html)

    [setTimeout/setImmediate/process.nextTick的区别](https://www.jianshu.com/p/77f03673aa06)

    [简单理解Vue中的nextTick](https://www.jianshu.com/p/a7550c0e164f)

    [浅谈async/await](https://www.jianshu.com/p/1e75bd387aa0)

    [async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)

    [面试向：Async/Await 代替 Promise.all()](https://juejin.im/post/5d56f89b518825415d0608be)

    [ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs/async)

    [Async/Await替代Promise的6个理由](https://www.cnblogs.com/fundebug/p/6667725.html)

2. 详解：

    * js是单线程的非阻塞语言：因为如果是多线程，一边绑定事件，一边移除元素，会引起冲突。

    * 执行栈：方法排队执行的地方，每个单元对应一个context，包含作用域中的this。

    * 事件队列：异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，再把事件放回执行栈。

    * 事件循环机制：由执行栈和事件队列构成的无限循环

    * 宏任务：setInterval()，setTimeout()
        * setTimeout：在指定的毫秒数后，将定时任务处理的函数添加到事件队列的队尾。
        * setInterval：按照指定的周期(以毫秒数计时)，将定时任务处理函数添加到事件队列的队尾。
            * 因为js是单线程的，如果处于堵塞状态计不了时，它必须依赖外部计时并触发定时，所以队列中的定时事件也是异步事件。
            * 每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。
            * setInterval有两个缺点：
                * 某些间隔会被跳过；
                * 可能多个定时器会连续执行；
            * setTimeout模拟setInterval,解决setInterval缺点
            ```js
            //每次执行的时候都会创建一个新的定时器
            var a = setTimeout(function () {
                // 任务
                setTimeout(a, interval);//获取当前函数的引用，并且为其设置另一个定时器
            }, interval)
            //在前一个定时器执行完前，不会向队列插入新的定时器
            //保证定时器间隔
            ```

    * 微任务1：new Promise()
        * Promise是异步的，是指他的then()和catch()方法，Promise本身还是同步的
        * 有resolve()后，才能执行then(),有reject()，不执行then()

    * 微任务2：async await
        * 改进generator语法，比promise更节约代码，能通过try catch处理JSON.parse(await getJSON())错误，条件语句可不再嵌套在then中，解决继发执行处理回调嵌套问题(根据promise1的结果请求promise2的结果再请求promise3的结果)，解决链式调用then无法找出错误地方的问题
        * async function(){} 表示函数内存在异步操作
        * async 自动将常规函数转换成Promise，返回值也是一个Promise对象
        * await必须在async函数内，如果async里面还有一层function使用await，也需声明此函数为async
        * await promise/function/其它，如果等待的不是 Promise 对象，则转promise后返回该值本身
        * await 强制下面代码等待，直到Promise对象resolve(即使await 其它，也需耗时)，得到resolve的值作为await表达式的运算结果
            ```js
            //继发关系比较耗时
            async function dbFuc(db) {
                let foo = await getFoo();
                let bar = await getBar();
            }
            //应该采用并发
            async function dbFuc(db) {
                // 写法一
                let [foo, bar] = await Promise.all([getFoo(), getBar()]);
                // 写法二
                let fooPromise = getFoo();
                let barPromise = getBar();
                let foo = await fooPromise;
                let bar = await barPromise;
            }
            ```
        * 多个异步操作，可await Promise.all
            ```js
            async function dbFuc(db) {
                let docs = [{}, {}, {}];
                let promises = docs.map((doc) => db.post(doc));

                let results = await Promise.all(promises);
                console.log(results);
            }

            async function dbFuc(db) {
                let docs = [{}, {}, {}];
                let promises = docs.map((doc) => db.post(doc));

                let results = [];
                for (let promise of promises) {
                    results.push(await promise);
                }
                console.log(results);
            }
            ```
        * try/catch 可获取 async 函数内，任意 await 的错误，即可满足 其中一个被拒绝，即会暂停，并返回错误信息 的功能
            ```js
            async function asyncAlls(jobs) {
                try {
                    // 循环执行
                    let results = jobs.map(async job => await job)
                    let res = []
                    // 组合数组
                    for (const result of results) {
                        res.push(await result)
                    }
                    return res
                } catch (error) {
                    //处理error
                    return error;//有一个reject,即到这里
                }
            }
            //也可此处处理error
            asyncAlls(jobs).catch((e)=>{...});
            ```
        * async函数实现
            ```js
            async function fn(args) {
                // ...
            }

            // 等同于
            function fn(args) {
                return spawn(function* () {
                    // ...
                });
            }
            function spawn(genF) {//genF为*
                return new Promise(function(resolve, reject) {
                    const gen = genF();
                    function step(nextF) {
                        let next;
                        try {
                            next = nextF();
                        } catch(e) {
                            return reject(e);
                        }
                        if(next.done) {
                            return resolve(next.value);
                        }
                        Promise.resolve(next.value).then(function(v) {
                            step(function() { return gen.next(v); });
                        }, function(e) {
                            step(function() { return gen.throw(e); });
                        });
                    }
                    step(function() { return gen.next(undefined); });
                });
            }
            ```

    * 事件优先级：同步任务>异步任务(微任务>宏任务(取决于延时时间))

    * Node.js是一个基于Chrome V8引擎的JavaScript运行环境，比js少了DOM/BOM,多了http/file system,事件执行顺序与js不同
        * 浏览器是先把一个栈以及栈中的微任务走完，才会走下一个栈。node 环境里面是把所以栈走完，才走微任务
        * setTimeout setImmediate 都是宏任务
        * nextTick和then都属于微任务
        * i/o 文件操作为宏任务

    * nextTick、setTimeout、setImmediate的区别

        nodejs中，setTimeout、setImmediate是宏任务，process.nextTick()是微任务，因此setTimeout、setImmediate回调函数插入到任务队列的尾部，nextTick回调函数加入到当前执行栈的尾部，所以nextTick会先执行。

        setTimeout、setImmediate相差不大，但延时设为0时，setImmediate会更快加入任务队列。

        vue中，created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，因为此时DOM没渲染，需要等到mounted()后执行。另外，数据变化导致DOM变化，也应用Vue.nextTick()

    * 例题：
    ```js
    //浏览器
    (function() {
        setTimeout(() => {
            console.log(0);
        });

        new Promise(resolve => {

            console.log(1);
            
            setTimeout(() => {
                resolve();
                Promise.resolve().then(() => {
                    console.log(2);
                    setTimeout(() => console.log(3));
                    Promise.resolve().then(() => console.log(4));
                });
            });

            Promise.resolve().then(() => console.log(5));

        }).then(() => {

            console.log(6);
            Promise.resolve().then(() => console.log(7));
            setTimeout(() => console.log(8));

        });

        console.log(9);
    })();
    //1、9、5、0、6、2、7、4、8、3
    //node.js
    console.log('1');
    setTimeout(function() {
        console.log('2');
        process.nextTick(function() {
            console.log('3');
        })
        new Promise(function(resolve) {
            console.log('4');
            resolve();
        }).then(function() {
            console.log('5')
        })
    })
    process.nextTick(function() {
        console.log('6');
    })
    new Promise(function(resolve) {
        console.log('7');
        resolve();
    }).then(function() {
        console.log('8')
    })
    setTimeout(function() {
        console.log('9');
        process.nextTick(function() {
            console.log('10');
        })
        new Promise(function(resolve) {
            console.log('11');
            resolve();
        }).then(function() {
            console.log('12')
        })
    })
    //1，7，6，8，2，4，3，5，9，11，10，12
    let test = async function () {
        await new Promise((resolve,reject)=>{
            console.log(1);
            setTimeout(() => {
                resolve();
            }, 3000);
        }).then(()=>{
            console.log(2);
        });
        console.log(3)
        await new Promise((resolve,reject)=>{
            console.log(4);
            setTimeout(() => {
                resolve();
            }, 1000);
        }).then(()=>{
            console.log(5);
        });
        console.log(6)
    };
    test();
    //1

    //2
    //3
    //4
    
    //5
    //6
    ```

### 闭包数据缓存

1. 参考链接：

    [JS闭包异步获取数据并缓存](https://blog.csdn.net/weixin_43820866/article/details/87107035)

    [js async await 终极异步解决方案](https://www.cnblogs.com/CandyManPing/p/9384104.html)

2. 详解：

    向接口请求数据时，数据多次使用，但不想保存在全局变量中，就需要将数据存储在缓存中。查找数据时，如果缓存找不到，则调用API，然后设置缓存，如果找到，直接返回查找到的值即可。闭包正好可以做到这一点，且不会释放外部的引用，从而函数内部的值可以得以保留。

    ```js
    const getList = (function() {
        // 闭包存储data
        let data = {};
        const getData = () => {
            return new Promise((resolve, reject) => {
                $.ajax({
                    url: '/your/api',
                    data: {
                        normal: 1
                    },
                    success: function (result) {
                        data = result.data;
                        resolve();
                    }
                });
            })
        }
        // 异步函数，当调用一个 async 函数时，会返回一个 Promise 对象。
        const result = async function (type) {
            if (JONS.stringify(data) === '{}') {
                //await 只能出现在 async 函数中。
                await getData();//等待异步操作执行完成，再执行后面的操作，相当于把后面的代码写在success里，但用await会比较简洁
                //如果 async 函数没有返回值，它会返回 Promise.resolve(undefined)。如果有返回值data，就会resolve(data),把data传入then
                //当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。
                return data;
            } else {
                return data;
            }
        }

        return result;
    })();

    // 第一次调用通过api请求数据
    getList().then(res => {
        console.log(res);

        // 第二次调用则直接拿取缓存数据
        getList().then(res => {
            console.log(res);
        }
    });
    ```

### 页面加载生成过程

1. 参考链接：

    [网页生成过程及重排和重绘](https://blog.csdn.net/qq_41635167/article/details/83932920)

    [web页面加载、解析、渲染过程](https://www.cnblogs.com/CandyManPing/p/6635008.html)

    [从输入URL到页面加载的全过程](https://www.cnblogs.com/xiaohuochai/p/9193083.html)

    [详解DNS域名解析全过程](https://blog.csdn.net/m0_37812513/article/details/78775629)

    [一次完整的HTTP请求所经历的7个步骤](https://www.cnblogs.com/jiu0821/p/5641600.html)

    [HTTPS的建立过程（SSL建立安全会话的过程）](https://blog.csdn.net/u011779724/article/details/80776776)

2. 详解：

    浏览器：
    * 输入网址并确认
    * 检查浏览器缓存,见[强制缓存与协商缓存](#强制缓存与协商缓存)
        * 存在缓存，检查是否过期(expires(具体时间)和cache-control(max-age秒))
            * 未过期，直接返回页面
            * 过期，向服务器发起请求(请求过程见下方)验证资源是否未修改(附带ETag和if-last-modify)
                * 未修改，返回304
                * 修改，最新资源和返回200
        * 不存在缓存，向服务器发起请求(请求过程见下方)
    * 域名解析(通过DNS找IP)
        * 检查浏览器 DNS 缓存(TTL)，存在则返回上一次解析的 IP
        * 不存在则检查操作系统缓存(本地hosts文件)是否有相应域名配置
        * 没对应再向LDNS(本地域名服务器)(城市中距离较近的域名服务器)发起查询
        * 不存在则向根域名.查询，根域名服务器返回LDNS一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址
        * LDNS再发送请求给上一步返回的gTLD
        * 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器
        * Name Server根据映射关系表找到目标ip，返回给LDNS
        * LDNS缓存这个域名和对应的ip
        * LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束

    * 建立TCP连接(三次握手)
        ```txt
        1.SYN包，SYN=1,Seq=X,进入 SYN_SENT 状态
        client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
        2.SYN-ACK包,SYN=1,ACK=X+1,Seq=Y,进入 SYN_RECV 状态
        client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
        3.SYN包，SYN=2,ACK=Y+1
        client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
        双方进入 ESTABLISHED 状态
        ```

    * http请求
        ```txt
        请求报文(查看request headers)
        POST /search HTTP/1.1  
        Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, 
        application/msword, application/x-silverlight, application/x-shockwave-flash, */*  
        Referer: <a href="http://www.google.cn/">http://www.google.cn/</a>  
        Accept-Language: zh-cn  
        Accept-Encoding: gzip, deflate  
        User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  
        Host: <a href="http://www.google.cn">www.google.cn</a>  
        Connection: Keep-Alive  
        Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; 
        NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-
        FxlRugatx63JLv7CWMD6UB_O_r  

        hl=zh-CN&source=hp&q=domety  
        ```

    * https请求过程:
        * 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器
        * 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公钥的证书发送给客户端；该证书包含了数字签名和一个用作产生密钥的随机数
        * 客户端验证证书(用根证书的C.pub鉴定证书合法性)后(验证不通过，浏览器会警告)，抽取服务器公钥，再产生一个的随机密码串pre_master_secret，并使用服务器公钥加密（RSA非对称加解密），发送给服务器
        * 客户端与服务器端根据随机密码串pre_master_secret以及客户端与服务器的随机数值独立计算出MAC密钥(Diffie-Hellman密钥交换算法)
        * 客户端将MAC值发送给服务器
        * 服务器将MAC值发送给客户端

        ```txt
        1.算法列表+随机数
        client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
        2.加密算法(证书+公钥+随机数+数字签名(私钥加密))
        client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
        3.验证，公钥加密(随机密码串)
        client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
        4.Diffie-Hellman密钥交换算法
        有两个全局公开的参数，一个素数q和一个整数a,a是q的一个原根(g^i mod p ≠ g^j mod p).
        用户A选择一个作为私有密钥的随机数XA(XA<q)，并计算公开密钥YA=a^XA mod q
        用户B选择一个私有的随机数XB<q，并计算公开密钥YB=a^XB mod q
        用户A产生共享秘密密钥的计算方式是K = (YB)^XA mod q
        用户B产生共享秘密密钥的计算是K = (YA)^XB mod q
        ```
    
    * 服务器处理请求，响应HTML
        ```txt
        响应报文
        HTTP/1.1 200 OK
        Date: Sat, 31 Dec 2005 23:59:59 GMT
        Content-Type: text/html;charset=ISO-8859-1
        Content-Length: 122

        ＜html＞
        ＜head＞
        ＜title＞Wrox Homepage＜/title＞
        ＜/head＞
        ＜body＞
        ＜!-- body goes here --＞
        ＜/body＞
        ＜/html＞
        ```

    * 浏览器解析HTML页面
        * 解析html：HTML代码转化成DOM
        * 页面加载时遇到CSS/JS/图片等资源会发送请求获取
        * 解析css/js：CSS代码转化成CSSOM（CSS Object Model）、js处理后产生一棵节点带CSS Style、会响应自定义事件的Styled DOM树
        * 构建render树：结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
        * 渲染排列：生成布局（layout），即将所有渲染树的所有节点进行平面合成，主要影响性能的地方
        * 渲染绘制：将布局绘制（paint）在屏幕上，主要影响性能的地方

        重排：DOM结构发生变化（js操作：事件、增减移动元素）

        重绘：DOM、CSS发生变化（js操作：事件、增减移动元素、元素样式变化）

    * 关闭TCP连接(四次挥手)
        ```txt
        1.FIN包,FIN=1,ACK=Z,Seq=X,进入 FIN_WAIT_1 状态
        client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
        2.ACK包,ACK=X+1,Seq=Y,服务器进入 CLOSE_WAIT 状态，浏览器端进入 FIN_WAIT_2 状态
        client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
        3.FIN包,FIN=1,ACK=X+1,Seq=Y,浏览器段进入 LAST_ACK 状态
        client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
        4.ACK包,ACK=Y+1,Seq=X+1,浏览器状态变成 TIME_WAIT
        client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
        服务器、浏览器关闭TCP连接
        ```

### http请求方式

1. 参考链接：

    [HTTP请求方法详解](https://www.cnblogs.com/foodoir/p/5911099.html)

    [HTTP协议以及HTTP请求中8种请求方法](https://blog.csdn.net/qq_38191191/article/details/78671063)

    [RESTful介绍和使用教程](https://blog.csdn.net/x541211190/article/details/81141459)

2. 详解：

    * 8种请求方法

        * get

        获取资源:URL提交数据，但是不同的浏览器对于URL是有限制的,IE传输的数据量一般限制在2KB

        * post

        传输实体文本:提交的数据放置在HTTP报文实体的主体里,安全性比GET方法要高,POST数据大小无限制

        * head

        获得报文首部:用于确认URI的有效性及资源更新的日期时间

        * put

        传输文件:用来传输文件,保存在请求URI指定的位置,HTTP/1.1的PUT方法自身不带验证机制,存在安全问题

        * delete

        删除文件:按URI删除指定资源

        * options

        询问支持的方法:查询针对请求URI指定资源支持的方法（客户端询问服务器可以提交哪些请求方法）

        * trace

        追踪路径:对请求消息的传输路径进行追踪，TRACE方法是让Web服务器端将之前的请求通信还给客户端的方法

        * connect

        用隧道协议连接代理:主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输

    * restful

        基于HTTP、URI、XML、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是Web服务的一种新的架构风格。

        * 对网络上所有的资源都有一个Url（通用资源标志符）

        * 对资源的操作不会改变Url

        * 同一资源有多种表现形式
        
            xml、json

        * 所有操作都是无状态的

            基于接口：客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前的请求，不需了解请求的历史。可以更容易的释放资源，让服务器利用Pool（连接池）技术来提高稳定性和性能。

        * 资源操作
            * get->select
            * post->insert
            * put->update
            * delete->delete

### 网络协议与7层结构

1. 参考链接：

    [网络七层协议](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/6056879?fr=aladdin)

    [TCP （传输控制协议）](https://baike.baidu.com/item/TCP/33012)

    [浅谈ftp和sftp的区别](https://blog.csdn.net/zdb292034/article/details/84531859)

    [Telnet](https://baike.baidu.com/item/TELNET/810597)

    [网络文件系统](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/9719420?fromtitle=NFS&fromid=812203)

    [SMTP](https://baike.baidu.com/item/SMTP/175887)

    [http](https://baike.baidu.com/item/http/243074?fr=aladdin)

    [HTTP1.0，HTTP1.1和HTTP2.0的区别](https://www.jianshu.com/p/7bfec28236c3)

    [HTTP3.0(QUIC的实现机制)](https://www.cnblogs.com/chenjinxinlove/p/10104854.html)

2. 详解：

    * 网络七层协议

        1. 物理层

            物理电流电路相关的传输介质

        2. 数据链路层

            定义了在单个链路上如何传输数据

        3. 网络层

            定义了能够标识所有结点的逻辑地址，IP协议

        4. 传输层

            数据流输入、复用与重排序，TCP、UDP协议

        5. 会话层

            会话开始、控制、结束，如使用SQL

        6. 表示层

            定义数据格式及加密，如使用ASCII字符集

        7. 应用层

            与其它计算机进行通讯的一个应用，对应应用程序，如使用TELNET，HTTP，FTP，NFS，SMTP

    * 协议

        * tcp

            1. 可靠连接，有状态连接，每个包会有序号，接收成功会返回ack，三次握手和四次挥手具体见[页面加载生成过程](#页面加载生成过程)

            2. TCP拥塞控制(AIMD)算法：

                * 慢启动

                    每当建立一个TCP连接时或一个TCP连接发生超时重传后，该连接便进入慢启动阶段。

                    拥塞窗口：避免拥塞的窗口。

                    一开始拥塞窗口指数级增加，如果超过阈值，进入拥塞避免阶段，如果报文段丢失重传，重新慢启动

                * 拥塞避免

                    每一次报文被完全接收后，拥塞窗口才加1，拥塞窗口线性增加

                * 快速重传

                    对超时重传的改进，当源端收到对同一个报文的三个重复确认时，就确定一个报文段已经丢失，因此立刻重传丢失的报文段，减少不必要的等待时间。

                * 快速恢复

                    对丢失恢复机制的改进，快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段

        * udp

            不可靠连接，无状态连接，常用于多媒体数据流，强调传输性而不是完整性，包错漏不重传

        * ftp与sftp

            * ftp文件传输协议，方便数据共享。FTP客户端通过FTP协议在服务器上下载资源
            * sftp是在ftp之上进行加密

        * Telnet

            * 是Internet远程登录服务的标准协议和主要方式

            * 过程

                1. 通过ip与远程建立连接(建立一个TCP连接)
                2. 输入用户名和密码，以VNT格式发送数据(从本地主机向远程主机发送一个IP数据包)
                3. 远程主机返回结果
                4. 撤销TCP连接

        * NFS

            基于UDP/IP协议,允许远程客户端以与本地文件系统类似的方式，来通过网络进行访问

        * SMTP

            电子邮件传输的协议,建立在FTP文件传输服务上的一种邮件服务

        * http/https

            * http请求-响应协议,基于tcp协议

                版本：

                    * 0.9:交换信息的无序协议，仅仅限于文字
                    * 1.0:对每一次请求/响应建立并拆除一次连接,双方规定了连接方式和连接类型
                    * 1.1:支持长连接,默认启用Keep-Alive,加入了一些cache的新特性(ETag,Cache-Control),一台物理服务器上可以存在多个虚拟主机共享一个IP地址
                    * 2.0:使用了多路复用的技术,做到同一个连接并发处理多个请求,对请求和响应的头部进行压缩，即不再只是压缩主题部分，这种压缩方式就是HAPCK,引入了server push，它允许服务端推送资源给浏览器
                    * 3.0:QUIC协议:自定义连接机制,自定义重传机制,无阻塞的多路复用,自定义流量控制


            * https在http之上进行加密

                连接过程见[页面加载生成过程](#页面加载生成过程)

### 前端模块化

1. 参考链接：

    [前端模块化（CommonJS,AMD和CMD）](https://www.jianshu.com/p/735781477d28)

    [前端模块化，AMD与CMD的区别](https://www.cnblogs.com/futai/p/5258349.html)

    [前端模块化之AMD与CMD原理](https://blog.csdn.net/weixin_33947521/article/details/88001955)

    [requireJS原理解析](https://blog.csdn.net/cde7070/article/details/65935888)

    [CommonJs、AMD、CMD、Webpack](https://blog.csdn.net/weixin_41143293/article/details/79662362)

2. 详解：

    * 模块化为了解决js相互引用产生的问题，如：

        * 顺序引入：先引入jquery，才能引入其它js
        * 同步加载：1.js加载并执行完，才加载2.js
        * window全局变量污染

    * 模块：

        * 普通函数
        * 对象
        * 立即执行函数

    * 在webpack出现前的2种前端模块化工具（代码模块化，执行上没有区别）

        * AMD：异步模块定义，使用require.js，依赖前置

            采用异步方式加载模块，模块的加载不影响它后面语句的运行，所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行，避免顺序引入和同步加载的问题。

            * 用法：
            ```js
            // 1.js 中（入口用require，其他用define）
            require(['2.js'], function(A) {
                // A得到的就是2.js模块的返回值
                // 主要的执行代码
                // 2.js 3.js都加载完，才执行1.js的这回调函数
            })

            // 2.js 中
            define(['3.js', 'xxxx.js'], functionA(B, C) {
                // B得到的就是3.js模块的返回值，C是xxxx.js的
                return aaaaa;    // 2.js 模块的返回值
            })

            // 3.js 中
            define([], functionA() {
                
                retrun {}   // 3.js 模块的返回值
            })
            ```

            * 原理：

                * 块依赖加载之后，如何调用回调函数

                    使用requireJs时，都是在页面上只引入一个require.js，把data-main指向我们的main.js

                    运行main.js时，执行里面的require和define方法，requireJs会把这些依赖和回调方法都用一个数据结构存起来

                    然后使用script来加载这些模块依赖，并且监听load函数，且每个script元素都会有一个自定义的属性，用来指明模块名

                    当模块加载成功之后，可以通过元素属性来获取模块名，接着通过模块名来获取模块的定义，接着对模块进行初始化，再对子模块重复操作

                    当子模块没有其他要加载的依赖的时候这个时候表明子模块已经加载完毕，调用回调函数

                * 加载依赖之后，如何将接口暴露给回调函数

                    当执行回调函数的时候，会使用apply将模块定义中的接口，传递给回调函数

                * 如何解决循环依赖的问题

                    将已定义的模块保存在一个对象中，当加载模块依赖的时候，如果在这个对象中存在的话，则直接返回这个模块。否则的话，则再走一遍加载的模块的流程。
                
            * 代码：
            ```js
            var modules = {},	// 存放所有文件模块的信息，每个js文件模块的信息
            loadings = [];	//	存放所有已经加载了的文件模块的id，一旦该id的所有依赖都加载完后，该id将会在数组中移除

            // 上面说了，每个文件模块都要有个id，这个函数是返回当前运行的js文件的文件名，拿文件名作为文件对象的id
            // 比如，当前加载 3.js 后运行 3.js ，那么该函数返回的就是 '3.js'
            function getCurrentJs() {
                return document.currentScript.src
            }
            // 创建节点
            function createNode() {
                var node = document.createElement('script')
                node.type = 'text/javascript'
                node.async = true;
                return node
            }
            // 开始运行
            function init() {
                // 加载 1.js
                loadJs('1.js')
            }	
            // 加载文件(插入dom中)，如果传了回调函数，则在onload后执行回调函数
            function loadJs(url, callback) {
                var node = createNode()
                node.src = url;
                node.setAttribute('data-id', url)
                node.addEventListener('load', function(evt) {
                    var e = evt.target
                    setTimeout(() => {  // 这里延迟一秒，只是让在浏览器上直观的看到每1秒加载出一个文件
                        callback && callback(e)
                    }, 1000)
                }, false)
                
                document.body.appendChild(node)
            }	
                
            // 此时，loadJs(1.js)后，并没有传回调函数，所以1.js加载成功后只是自动运行1.js代码
            // 而1.js代码中，是require( ['2.js', 'xxx.js'], functionA（B, C）{} )，则执行的是require函数, 在下面是require的定义

            window.require = function(deps, callback) {
                // deps 就是对应的 ['2.js', 'xxx.js']
                // callback 就是对应的 functionA
                // 在这里，是不会运行callback的(即模块的运行！)，得等到所有依赖都加载完的啊
                // 所以得有个地方，把一个文件的所有信息都先存起来啊，尤其是deps和callback
                var id = getCurrentJs();// 当前运行的是1.js，所以id就是'1.js'
                if(!modules.id) {
                    modules[id] = { // 该模块对象信息
                        id: id,
                        deps: deps,
                        callback: callback, 
                        exports: null,  // 该模块的返回值return ，
                        就是functionA(B, C)运行后的返回值，仔细想想？在后面的getExports中详细讲
                        
                        status: 1, 
                        
                    }
                    loadings.unshift(id); // 加入这个id，之后会循环loadings数组，递归判断id所有依赖
                }
                
                loadDepsJs(id); // 加载这个文件的所有依赖,即去加载[2.js]
            }

            function loadDepsJs(id) {
                var module = modules[id]; // 获取到这个文件模块对象
                // deps是['2.js']
                module.deps.map(item => {   // item 其实是依赖的Id，即 '2.js'
                    if(!modules[i]) {   // 如果这个文件没被加载过（注：加载过的肯定在modules中有）
                    （1）    loadJs(item, function() {   // 加载 2.js，并且传了个回调，准备要递归了
                                // 2.js加载完后，执行了这个回调函数
                                loadings.unshift(item); // 此时里面有两个了, 1.js 和 2.js
                                // 递归。。。要去搞3.js了
                                loadDepsJs(item)// item传的2.js，递归再进来时，就去modules中取2.js的deps了
                                // 每次检查一下，是否都加载完了
                                checkDeps(); // 循环loadings，配合递归嵌套和modules信息，判断是否都加载完了
                            })
                    }
                })
            }

            // 上面（1）那里，加载了2.js后马上会运行2.js的，而2.js里面是
            define(['js'], fn)
            // 所以相当于执行了 define函数

            window.define = function(deps,callback) {
                var id = getCurrentJs()
                if(!modules.id) {
                    modules[id] = {
                        id: id,
                        deps: getDepsIds(deps),
                        callback: callback,
                        exports: null,
                        status: 1,
                        
                    }
                }
            }

            // 注意，define运行的结果，只是在modules中添加了该模块的信息
            // 因为其实在上面的loadDepsJs中已经事先做了loadings和递归deps的操作，而且是一直不断的循环往复的进行探查，所以define里面就不需要再像require中写一次loadDeps了

            // 循环loadings，查看loadings里面的id，其所依赖的所有层层嵌套的依赖模块是否都加载完了

            function checkDeps() {
                for(var i = 0, id; i < loadings.length ; i++) {
                id = loadings[i]
                if(!modules[id]) continue
                
                var obj = modules[id], 
                deps = obj.deps
                
                // 下面那行为什么要执行checkCycle函数呢，checkDeps是循环loadings数组的模块id，而checkCycle是去判断该id模块所依赖的**层级**的模块是否加载完
                // 即checkDeps是**广度**的循环已经加载（但依赖没完全加载完的）的id
                // checkCycle是**深度**的探查所关联的依赖
                // 还是举例吧。。。假如除了1.js, 2.js, 3.js, 还有个4.js，依赖5.js，那么
                // loadings 可能 是 ['1.js', '4.js']
                // 所以checkDeps --> 1.js，  4.js
                // checkCycle深入内部 1.js --> 2.js --> 3.js ;;; 4.js --> 5.js
                // 一旦比如说1.js的所有依赖2.js、3.js都加载完了，那么1.js 就会在loadings中移出
                
                var flag = checkCycle(deps)
                
                if(flag) {
                        console.log(i, loadings[i] ,'全部依赖已经loaded');
                    
                        loadings.splice(i,1);
                        // ！！！运行模块，然后同时得到该模块的返回值！！！
                        getExport(obj.id)
                        // 不断的循环探查啊~~~~
                        checkDeps()
                }
                
                }
            }
            // 深层次的递归的去判断，层级依赖是否都加在完了
            // 进入1.js的依赖2.js，再进入2.js的依赖3.js ......
            function checkCycle(deps) {
                var flag = true
                
                function cycle(deps) {
                    deps.forEach(item => {
                        if(!modules[item] || modules[item].status == 1) {
                            flag = false
                        } else if(modules[item].deps.length) {
            //                         console.log('inner deps', modules[item].deps);
                            
                            cycle(modules[item].deps)
                        }
                            
                    })
                }
                
                cycle(deps)
                
                return flag
            }

            /*
                运行该id的模块，同时得到模块返回值，modules[id].export
            */
            function getExport(id) {
                /*
                    先想一下，例如模块2.js, 这时 id == 2.js
                    define(['3.js', 'xxxx.js'], functionA(B, C) {
                        // B得到的就是3.js模块的返回值，C是xxxx.js的
                        return aaaaa    // 2.js 模块的返回值
                    })
                    所以：
                    1. 运行模块，就是运行 functionA （模块的callback）
                    2. 得到模块的返回值，就是functionA运行后的返回值 aaaaa
                    问题：
                    1. 运行functionA(B, C)   B, C是什么？怎么来的？
                    2. 有B, C 了，怎么运行functionA ？
                    
                */
                // 解决问题1
                // B, C 就是该模块依赖 deps [3.js, xxxx.js]对应的返回值
                // 那么循环deps 得到 依赖模块Id, 取模块的export
                var params = [];
                var deps = modules[id].deps  
                
                for(var i = 0; i < deps.length; i++) {
                    // 取依赖模块的exports即模块返回值，注意不要害怕取不到，因为你这个模块都进来打算运行了，那么你的所有依赖的模块早都进来过运行完了（还记得模块运行顺序不？）
                    let depId = deps[i]
                    params.push( modules[ depId ].exports )
                }
                
                // 到这里,params就是依赖模块的返回值的数组，也就是B，C对应的实参
                // 也就是 params == [3.js的返回值，xxxx.js的返回值]
                
                if(!modules[id].exports) {
                    // 解决问题2： callback(functionA)的执行，用.apply，这也是为什么params是个数组了
                    // 这一行代码，既运行了该模块，同时也得到了该模块的返回值export
                    modules[id].exports = modules[id].callback.apply(global, params)
                }
            }
            ```

            * 模块运行顺序：

                3.js，2.js，1.js，如果模块以及该模块的依赖都加载完，就执行。 如 3.js 加载完后，没有依赖，直接执行3.js的回调了，2.js加载完后探查到依赖的3.js也加载完，2.js执行自己的回调了,主模块一定在最后执行


        * CMD：通用模块定义，使用sea.js，依赖就近

            * 用法：
            ```js
            // 只有define，没有require
            // 和AMD那个例子一样，还是1依赖2, 2依赖3
            //1.js中
            define(function() {
                
                var a = require('2.js')
                console.log(33333)
                var b = require('4.js')
            })

            //2.js 中
            define(function() {
                var b = require('3.js')
            })
            //3.js 中
            define(function() {
                // xxx
            })
            ```

            * 原理同AMD

            * 模块运行顺序：

                1.js，2.js，3.js，即先执行主模块1.js，碰到require('2.js')就执行2.js，2.js中碰到require('3.js')就执行3.js
        
        * es6模块化与commonjs区别

            es6模块化：import-export，编译时加载
            commonjs：require，module.exports=对象/函数，运行时加载

    * 服务器端模块化工具

        * webpack基于CommonJs

            同步加载

            一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。

            加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象，用来输出模块。





### for-in,for-of,foreach区别

1. 参考链接：

    [for、for in和for of和forEach的区别](http://blog.sina.com.cn/s/blog_c112a2980102xqg9.html)

2. 详解：

    * for一般用于循环数组
    * for-in可循环数组、对象，会循环出下标、键值，可通过data[key]访问
    * for-of在Array、Object、Set、Map中都可以使用，会循环出值，直接访问value即可
    * forEach循环在Array、Set、Map中都可以使用，用法：**.forEach(function(value,key){})

### arguments,...values,callee,caller,call,apply,bind用法

1. 参考链接：

    [callee、caller、call、apply、bind这些方法的含义和使用](https://blog.csdn.net/yc123h/article/details/52729484)

    [Javascript arguments详解](https://www.cnblogs.com/caoyc/p/5735299.html)

    [JS中this到底指向谁？](https://www.cnblogs.com/huangwentian/p/6854472.html)

    [彻底搞懂 JS 中 this 机制](https://blog.csdn.net/cjgeng88/article/details/79846670)

    [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/function)

    [jQuery 源码中大量push.call();splice.call();](https://www.jianshu.com/p/3d837e8d817d)

    [前端面试题——自己实现call和apply](https://zhuanlan.zhihu.com/p/83523272)

    [JavaScript直接调用函数与call调用的区别](https://blog.csdn.net/q5706503/article/details/82893277)

    [JS中new运算符的实现原理](https://www.cnblogs.com/YiNongLee/p/9336609.html)

    [js手动实现new方法](https://www.jianshu.com/p/9cee6a703e01)

2. 详解：

    * arguments

    arguments用在函数内部,arguments.length表示传入参数的个数，arguments.callee.length表示函数自身参数的个数，可用for in或for of或for 0~length-1遍历参数

    ```js
    function add(a,b){
        console.log(arguments,arguments.length,arguments.callee.length)
    }
    //add(1,2,3)
    //Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    // 3
    // 2
    ```

    * ...values

    ...values是es6语法，可替代arguments，数组储存传入的参数,for of遍历参数较为方便

    ```js
    function add(...values){
        console.log(values)
    }
    add(1,'a',[0],{a:1},function(){})
    //[1, "a", Array(1), {…}, ƒ]
    ```

    * callee

    callee指向函数自身，用在函数内部，用于解耦或配合arguments使用

    ```js
    //正常递归
    function factorial(num){
        if(num<=1){
            return 1;
        }else{
            return num*factorial(num-1)
        }
    }
    //下面的不规范行为，导致函数指向错误
    var testFactorial = factorial;
    factorial = function(){
        return 0;
    }
    testFactorial(5); //0
    //修改方法
    function factorial(num){
        if(num<=1){
            return 1;
        }else{
            return num*arguments.callee(num-1)
        }
    }

    var testFactorial = factorial;
    factorial = function(){
        return 0;
    }
    console.log(testFactorial(5)); //120
    ```

    * caller

    caller用法是：函数名.caller，如果函数是顶层函数（没有外层函数调用），则为null，如果有外层函数，则指向外层函数。

    ```js
    function outer(){
        inner();
    }
    function inner(){
        console.log(inner.caller);
    }
    outer(); //显示outer的源代码
    ```

    * this

    this指向的对象为函数的上下文context，即函数的调用者。

        * 默认绑定/window回调函数:函数名()调用或window函数回调（setTimeout、setInterval），this指向window
        * 隐式绑定/多层调用链:函数作为数组的一个元素，通过数组下标调用，this指向这个数组，对象1.对象2.函数名()调用，this指向对象2
        * new 绑定：函数作为构造函数，用new关键字调用，this指向新new出的对象
        * 显式绑定:call,apply导致this指向第一个参数指定的地方，对于null和undefined的绑定将不会生效
        * 箭头函数只取决于外层（函数或全局）的作用域，对于前面的4种绑定规则是不会生效，因此需要外层var that = this，供箭头函数内部使用

    * call,apply

        call,apply用于改变函数执行的作用域，即改变函数体内this的指向。区别在于：call的第二个参数起要逐一列出，apply第二个参数可以是array或arguments

        ```js
        window.color = 'red'
        var o = {
            color:'blue'
        }
        function sayColor(color){
            console.log(this.color+' param:'+color)
        }
        sayColor('black');//red param:black

        sayColor.call(window,'black'); //red param:black
        sayColor.apply(window,['black']);//red param:black

        sayColor.call(o,'black') //blue param:black
        sayColor.apply(o,['black']) //blue param:black
        ```

        * 合并数组

            ```js
            var arr1 = [1, 2, 3];  
            var arr2 = [4, 5, 6];  
            var arr3 = Array.prototype.push.call(arr1, arr2);
            console.log(arr3);
            console.log(arr1);
            console.log(arr2);
            4
            (4) [1, 2, 3, Array(3)]
            (3) [4, 5, 6]

            var arr1 = [1, 2, 3];  
            var arr2 = [4, 5, 6];  
            var arr3 = Array.prototype.push.apply(arr1, arr2);
            console.log(arr3);
            console.log(arr1);
            console.log(arr2);
            6
            (6) [1, 2, 3, 4, 5, 6]
            (3) [4, 5, 6]

            //造成输出的区别，是因为call的第二个参数起是枚举，apply的第二个参数是数组
            var arr1 = [1, 2, 3];  
            var arr2 = [4, 5, 6];  
            var arr3 = Array.prototype.push.call(arr1, ...arr2);
            console.log(arr3);
            console.log(arr1);
            console.log(arr2);
            4
            (6) [1, 2, 3, 4, 5, 6]
            (3) [4, 5, 6]
            ```

        * 对象转数组

            ```js
            var obj = {0:'hello',1:'world',length:2};
            console.log(Array.prototype.slice.call(obj));
            (2) ["hello", "world"]

            var obj = {0:'hello',1:'world',length:2};
            console.log(Array.prototype.slice.apply(obj));
            (2) ["hello", "world"]
            ```

        * 获取索引

            ```js
            var arr = [1,2,3];
            console.log(Array.prototype.indexOf.call(arr,2));
            1

            var arr = [1,2,3];
            console.log(Array.prototype.indexOf.apply(arr,[2]));
            1
            ```

        * 自己实现call和apply

            ```js
            var person = {
                fullName: function(txt) {
                    console.log(txt + this.firstName + " " + this.lastName);
                }
            }
            var person1 = {
                firstName:"John",
                lastName: "Doe"
            } 
            person.fullName.call(person1, "Hello, ");
            person.fullName.apply(person1, ["Hello, "]);
            Function.prototype.myOwnCall = function(context) {
                context = context || window;//如果第一个参数传入的是null的情况下，this会指向window
                //防止与原对象方法重名
                var uniqueID = "00" + Math.random();
                while (context.hasOwnProperty(uniqueID)) {
                    uniqueID = "00" + Math.random();
                }
                context[uniqueID] = this;//记录为调用的函数
                //Array.from(arguments).slice(1)
                var args = [];
                for (var i = 1; i < arguments.length; i++) {  
                    args.push("arguments[" + i + "]");
                }
                var result = eval("context[uniqueID](" + args + ")");//传入参数，执行函数，处理函数返回值
                delete context[uniqueID];//清除给原对象新增的方法
                return result;
            }
            Function.prototype.myOwnApply = function(context, arr) {
                context = context || window;//如果第一个参数传入的是null的情况下，this会指向window
                //防止与原对象方法重名
                var uniqueID = "00" + Math.random();
                while (context.hasOwnProperty(uniqueID)) {
                uniqueID = "00" + Math.random();
                }
                context[uniqueID] = this;//记录为调用的函数
            
                var args = [];
                var result = null;
            
                if (!arr) {
                result = context[uniqueID]();//没有第二个参数的情况
                }
                else {
                    //有第二个参数的情况
                    //Array.from(arguments).slice(1)
                    for (var i = 0; i < arr.length; i++) { 
                        args.push("arr[" + i + "]");
                    }
                    result = eval("context[uniqueID](" + args + ")");
                }
                delete context[uniqueID];//清除给原对象新增的方法
                return result;
            }
            person.fullName.myOwnCall(person1, "Hello, ");
            person.fullName.myOwnApply(person1, ["Hello, "]);
            ```


    * 直接调用与call、apply区别

        1. 情景1：使用自身对象不存在的方法，无法直接调用，如arguments想使用Array.prototype.slice

        2. 情景2：改变this指向，产生于直接调用不同的结果

            ```js
            var x = "我是全局变量";
            function a(){
                this.x = "我是在函数类结构a中声明的哦";
            }
            function f(){
                alert (this.x);
            }
            f();//输出：“我是全局变量”
            f.call(new a());//输出：“我是在函数类结构a中声明的哦”
            ```

        3. 情景3：上面2种情况都不是，和直接调用没区别

    * bind

    bind方法会创建一个函数实例,this会被绑定到传给bind()函数的值

    ```js
    window.color = 'red'
    var o = {
        color:'blue'
    }
    function sayColor(color){
        console.log(this.color)
    }
    var objSayColor = sayColor.bind(o);
    objSayColor(); //blue
    ```

    * new

        new运算符背后的步骤：

        * 创建一个空对象
        * 链接到原型
        * 绑定this值
        * 返回新对象

        ```js
        function create(){
            //创建一个空对象
            let obj = new Object();
            //获取构造函数
            let Constructor = [].shift.call(arguments);
            //链接到原型
            obj.__proto__ = Constructor.prototype;
            //绑定this值
            let result = Constructor.apply(obj,arguments);//使用apply，将构造函数中的this指向新对象，这样新对象就可以访问构造函数中的属性和方法
            //返回新对象
            return typeof result === "object" ? result : obj;//如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象
        }
        ```
        ```js
        function _new() {
            let target = {};
            let [constructor, ...args] = [...arguments];
            console.log(constructor,args)
            target.__proto__ = constructor.prototype;
            let result = constructor.apply(target,args);
            if(result && (typeof result == 'object' || typeof result == 'function')) return result;
            return target;
        }
        ```

    * instanceof

        a instanceof b 判断a是否b的实例，即a从b处new出来

        相当于判断 
        ```js
        a.__proto__ == b.prototype 或
        a.constructor == b
        ```

### 日历的实现

1. 参考链接：

    [Date](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)

2. 详解：

    * new Date()

        用法：

        * new Date();
        * new Date(value);
        * new Date(dateString);
        * new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);

        new Date(this.selectedYear,this.selectedMonth,0)会获得当月最后一天的日期

    * set方法

    凡是set方法，传入数超出合理范围，会自动转为毫秒处理，再使用get获取信息，因此日月的加减不需要处理进位和退位问题。

    * 6*7的日历显示

        * 新开长度为42的数组
        
        * 因为第一行一定会出现本月的数字，于是getDay计算本月1号时星期几，确定1号位于数组的位置

        * 从1号开始填充本月进数组

        * 通过日期加减，把数组剩余位置填满

        * 设置ul宽度，使li每7格换一次行

    ```js
    // 根据给定日期算出星期
    getDay(date){
        return new Date(date).getDay();
    }

    // 获取某月的天数
    getMonthNumber(){
        let d = new Date(this.selectedYear,this.selectedMonth,0);
        let num = d.getDate();
        return num;
    }

    // 获取某一天的昨天和明天
    // date 代表指定的日期，格式：2018-09-27
    // day 传-1表始前一天，传1表始后一天
    getNextDate(date,day) {  
        var dd = new Date(date);
        dd.setDate(dd.getDate() + day);
        var y = dd.getFullYear();
        var m = dd.getMonth() + 1 < 10 ? "0" + (dd.getMonth() + 1) : dd.getMonth() + 1;
        var d = dd.getDate() < 10 ? "0" + dd.getDate() : dd.getDate();
        return y + "-" + m + "-" + d;
    }

    // 获取日历中某一天的昨天和明天的数字
    getNextDayNumber(date,day){
        var dd = new Date(date);
        dd.setDate(dd.getDate() + day);
        var d = dd.getDate();
        return d;
    }
    ```

### 深复制的实现

1. 参考链接：

    [深入js 深拷贝对象](https://www.jianshu.com/p/b08bc61714c7)

    [JS如何进行对象的深克隆（深拷贝）？](https://www.cnblogs.com/tangjiao/p/9313829.html)

2. 详解：

    * 递归法(简单常用，可复制原型链属性__proto__，无法处理对象成环、特殊类型symbol、不可枚举属性get/set)
    ```js
    function deepClone(obj) {
        if (typeof obj !== 'object') {
            throw new Error('obj 不是一个对象！')
        }

        let isArray = Array.isArray(obj)
        let cloneObj = isArray ? [] : {}
        for (let key in obj) {
            cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
        }

        return cloneObj
    }
    ```

    * 代理法(可symbol，无法处理对象成环、不可复制原型链属性__proto__、不可枚举属性get/set)
    ```js
    function deepClone(obj) {
        if (typeof obj !== 'object') {
            throw new Error('obj 不是一个对象！')
        }

        let isArray = Array.isArray(obj)
        let cloneObj = isArray ? [...obj] : { ...obj }
        Reflect.ownKeys(cloneObj).forEach(key => {
            cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
        })

        return cloneObj
    }
    ```
    ```js
    function deepClone(obj) {
        if (obj == null) {
            return null
        }
        var result = Array.isArray(obj) ? [] : {};
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (typeof obj[key] === 'object') {
                    result[key] = deepClone(obj[key]);  // 如果是对象，再次调用该方法自身
                } else {
                    result[key] = obj[key];
                }
            }
        }
        return result;
    }
    ```

    * 序列化法(只能处理数组和对象，且对象不能成环)
    ```js
    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj))
    }
    ```

    * lodash法(较完善)
    ```js
    let result = _.cloneDeep(test)
    ```

    * 组合法(无法处理日期和正则，Object.getOwnPropertyDescriptor的value是浅拷贝)
    ```js
    function cloneDeep(obj) {
        let family = {}
        let parent = Object.getPrototypeOf(obj)

        while (parent != null) {
            family = completeAssign(deepClone(family), parent)
            parent = Object.getPrototypeOf(parent)
        }

        function completeAssign(target, ...sources) {
            sources.forEach(source => {
                let descriptors = Object.keys(source).reduce((descriptors, key) => {
                    descriptors[key] = Object.getOwnPropertyDescriptor(source, key)
                    return descriptors
                }, {})

                // Object.assign 默认也会拷贝可枚举的Symbols
                Object.getOwnPropertySymbols(source).forEach(sym => {
                    let descriptor = Object.getOwnPropertyDescriptor(source, sym)
                    if (descriptor.enumerable) {
                        descriptors[sym] = descriptor
                    }
                })
                Object.defineProperties(target, descriptors)
            })
            return target
        }

        return completeAssign(deepClone(obj), family)
    }
    ```

    专门针对特殊类型
    ```js
    var clone = function(obj){
        if(obj === null) return null;
        if(obj.constructor !== 'object') return obj;
        if(obj.constructor === Date) return new Date(obj);
        if(obj.constructor === RegExp) return new RegExp(obj);
        var newObj = new obj.constructor(); //保持继承的原型
        for(var key in obj){
            if(obj.hasOwnProperty(key)){
                var val = obj[key];
                newObj[key] = typeof val === 'object' ? arguments.callee(val):val;
            }
        }
        return newObj;
    }
    ```

    特殊类型+成环
    ```js
    function deepClone(obj, hash = new WeakMap()) {
        if(obj instanceof RegExp) return new RegExp(obj);
        if(obj instanceof Date) return new Date(obj);
        if(obj === null || typeof obj !== 'object') return obj;
        if(hash.has(obj)) {
            return hash.get(obj);
        }
        //obj为Array，相当于new Array()
        //obj为Object，相当于new Object()
        let constr = new obj.constructor();
        hash.set(obj,constr);
        for(let key in obj) {
            if(obj.hasOwnProperty(key)) {
                constr[key] = deepClone(obj[key],hash);
            }
        }
        return constr;
    }
    var o1 = new Object();
    var o2 = new Object();
    o1.next = o2;
    o2.next = o1;
    var target = [ 0, null, undefined, NaN, [1,2], {name: 'a',obj: { a: 1}}, function a(){ return 1; }, new Date("2020-01-01"), new RegExp(/aaa/), o1 ];
    ```

### overflow:hidden清除浮动的原理

1. 参考链接：

    [为什么"overflow:hidden"能清除浮动的影响](https://www.jianshu.com/p/7e04ed3f4bea)

2. 详解：

    * BFC

        BFC（Block Formatting Context），块级格式化上下文(块级元素)，它规定了内部的块级元素(父子关系)的布局方式，空网页下只有body一个块级上下文。

        * BFC布局规则

            * 内部块级元素从上到下排布
            * 同一BFC的兄弟块级元素会margin合并，否则不会
            * margin与border相接触
            * 块级元素不会与float元素重叠
            * 计算块级元素高度时，里面的浮动元素也参与计算

        * 创建BFC

            * float的值不为none
            * overflow的值不为visible
            * position的值为fixed / absolute
            * display的值为table-cell / table-caption / inline-block / flex / inline-flex

    ```html
    <body>
    <div class="parent">
        <div class="child1"></div>
        <div class="child2"></div>
    </div>
    </body>
    ```
    ```css
    .parent{
        width:300px; 
        background:#ddd; 
        border:1px solid;
        overflow: hidden; 
    } 
    .child1{ 
        width:100px; 
        height:100px; 
        background:pink;
        float:left;
    }
    .child2{ 
        width:200px; 
        height:50px; 
        background:red;
    }
    ```
    在parent加入overflow: hidden前，parent高度为50px，加入后高度为100px，所以父元素overflow: hidden，可以清除包含块内子元素的浮动。

### 前端路由原理

1. 参考链接：

    [前端路由的前生今世及实现原理](https://segmentfault.com/a/1190000011967786)

2. 详解：

    * 后端渲染路由

        1.浏览器发出请求

        2.服务器监听到80/443端口的请求，并解析url路径

        3.根据服务器的路由配置，返回相应信息（html、json、image）

        4.浏览器根据数据包的Content-Type来决定如何解析数据

    * 前端路由

        检测url的变化，截获url地址，然后解析来匹配路由规则。

        https://...#value 井号后面的value为hash，hash变化不会请求后端，只会触发hashchange事件，然后js解析新的页面内容。回退使用history.go(-1)，前进使用hashchange事件，刷新使用load事件。

        pushState和replaceState方法，以及onpopstate事件，能够使url不出现井号跳转，原理和hash相同，如vue的history模式，但是刷新页面依然会发请求导致404，因此需要服务器转发请求，重定向到根页面，如使用nginx。回退使用popstate事件，前进使用pushState，刷新使用服务器重定向，再load。

        ```txt
        server {
            listen       8083;
            server_name  localhost;

            location / {
                root   D:\wwwroot;
                try_files $uri $uri/ /index.html;
                index  index.html index.htm;
            }

            location /api {
                add_header 'Access-Control-Allow-Origin' '*';
                proxy_pass http://localhost:7675/api;
            }

            error_page   500 502 503 504  /50x.html;
            location = /50x.html {
                root   html;
            }
        }
        ```

    * pushState和replaceState

        history.pushState(状态对象, 标题 , URL);创建新的历史记录条目

        history.replaceState(状态对象, 标题 , URL);修改历史记录条目

        状态对象是能被序列化的对象(小于640k)，用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。

        获取当前状态：let currentState = history.state;


### 强制缓存和协商缓存

1. 参考链接：

    [强制缓存（200）和协商缓存（304）整理](https://blog.csdn.net/zl399615007/article/details/84534884)

    [强制缓存和协商缓存有什么区别](https://www.jianshu.com/p/1a1536ab01f1)

    [彻底弄懂强缓存与协商缓存](https://www.jianshu.com/p/9c95db596df5)

2. 详解：

    * 强制缓存

        浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中，从缓存中获取资源信息，包括缓存header信息，本次请求不会与服务器通信。状态码：200（from cache）

        * 相关header

            * expires:强制缓存过期时间
            * cache-control:更细致的expires,优先级高于expires，其值包含：
                * public(可被任何缓存区缓存),private(单个用户的响应消息，不共享缓存)
                * no-cache(请求或响应消息不能缓存),no-store(请求和响应消息都不使用缓存)
                * max-age(过期时间)
                * min-fresh(可以接收响应时间小于当前时间加上指定时间的响应),max-stale(可以接收超时的响应)

    * 协商缓存

        如果没有命中强制缓存，浏览器会发送请求到服务器，请求会携带第一次返回的有关缓存的header字段信息（Last-Modifued/If-Modified-Since和Etag/If-None-Match），由服务器根据header信息来比对结果是否协商缓存命中。若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。状态码：304（not modified）

        * 相关header

            * Last-Modified(响应资源的最后修改时间)
            * If-Modified-Since(资源过期时，如有Last-Modified，请求服务器会带上此请求时间，如Last-Modified时间大于if-modified-since，则返回最新资源，HTTP 200，否则响应HTTP 304)
            * Etag(服务器响应时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。)
            * If-None-Match(资源过期时，如有Etag，请求服务器会带上if-none-match(值是Etag的值)，由服务器决定返回200或304)
            * 优先级：ETag>Last-Modified

        * 为什么既有Last-Modified还有Etag?Last-Modified比较难解决的问题:

            * 文件周期性变化，文件仅仅改变的修改时间，而不改变内容，导致重新get
            * 文件变化特别快，需要用到If-Modified-Since，能检查到的粒度是秒级
            * 某些服务器不能精确的得到文件的最后修改时间

        * 用户的行为对缓存的影响

            * 对Expires/Cache-Control有效：地址栏回车/页面链接跳转/新开窗口/前进后退
            * 对Expires/Cache-Control有效：F5刷新/Ctrl+F5强制刷新
            * 对Last-Modified/Etag有效：地址栏回车/页面链接跳转/新开窗口/前进后退/F5刷新
            * 对Last-Modified/Etag有效：Ctrl+F5强制刷新


### 节流和防抖

1. 参考链接：

    [函数防抖和节流](https://www.jianshu.com/p/c8b86b09daf0)

    [js防抖和节流](https://www.cnblogs.com/momo798/p/9177767.html)

2. 详解：

    * 防抖（debounce）

        触发事件后在n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间。

        * 非立即执行
        
            触发事件后函数不会立即执行，而是在n秒后执行，如果在n秒内又触发了事件，则会重新计算函数执行时间

            ```js
            // 防抖
            function debounce1(func, wait) {
                var timeout = null;
                return function() {
                    let context = this;
                    let args = arguments;

                    if(timeout !== null)   clearTimeout(timeout);

                    timeout = setTimeout(() => {
                        func.apply(context, args)
                    }, wait);
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', debounce1(handle(a), 1000));
            ```

        * 立即执行

            触发事件后函数会立即执行，然后n秒内不触发事件才能继续执行函数的效果

            ```js
            // 防抖
            function debounce2(func,wait) {
                let timeout;
                return function () {
                    let context = this;
                    let args = arguments;

                    if (timeout) clearTimeout(timeout);

                    let callNow = !timeout;
                    timeout = setTimeout(() => {
                        timeout = null;
                    }, wait)

                    if (callNow) func.apply(context, args)
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', debounce2(handle(a), 1000));
            ```

    * 节流（throttle）

        连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。

        * 时间戳

            ```js
            // 节流
            function throttle1(func, wait) {
                let previous = 0;
                return function() {
                    let now = Date.now();
                    let context = this;
                    let args = arguments;
                    if (now - previous > wait) {
                        func.apply(context, args);
                        previous = now;
                    }
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', throttle1(handle(a), 1000));
            ```

        * 定时器

            ```js
            // 节流
            function throttle2(func, wait) {
                let timeout;
                return function() {
                    let context = this;
                    let args = arguments;
                    if (!timeout) {
                        timeout = setTimeout(() => {
                            timeout = null;
                            func.apply(context, args)
                        }, wait)
                    }
                }
            }
            // 处理函数
            function handle(a) {
                console.log(a,Math.random());
            }
            // 滚动事件
            window.addEventListener('scroll', throttle2(handle(a), 1000));
            ```

### xss和csrf

1. 参考链接：

    [XSS 和 CSRF简述及预防措施](https://www.cnblogs.com/yangsg/p/10621496.html)

    [xss注入方法及验证方法](https://blog.51cto.com/zhouanya/1909746)

    [XSS及CSRF攻击防御](https://blog.csdn.net/zl834205311/article/details/81773511)

2. 详解：

    * xss(跨站脚本攻击)

        在网站写入恶意代码，当别人浏览网页时，导致恶意脚本被执行，获取用户隐私数据。

        * 反射型：发送带恶意脚本的get、post请求(如websocket对话)，后端没做过滤，就直接向其它用户展示
        * 持久型：提交恶意input，后端没做过滤，保存到数据库，再向其它用户展示
        * DOM型：注入script、img、onerror等操作

        预防方法：对输入进行检查、过滤和转义。

    * csrf(跨站请求伪造)

        用户带着A网站的cookie，访问B网站时，被B网站窃取后，B网站向A网站发送伪造请求，使B网站获得用户在A网站的权限。

        预防方法：

        * 验证码:图像识别，提高攻击难度
        * referer:header的referer记录了来源地址，检测到referer不是本网站的请求，则拒绝
        * 令牌:请求信息带token，验证身份

### js函数柯里化

1. 参考链接：

    [详解JS函数柯里化](https://www.jianshu.com/p/2975c25e4d71)

    [前端柯里化的三种作用](https://blog.csdn.net/qq_39674542/article/details/82657109)

2. 详解：

    Currying是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

    * 柯里化:高阶函数
        ```js
        function add(x, y) {
            return x + y
        }
        function curryingAdd(x) {
            return function (y) {
                return x + y
            }
        }
        add(1, 2)           // 3
        curryingAdd(1)(2)   // 3
        ```

    * 好处：

        * 参数复用

            ```js
            function check(reg, txt) {
                return reg.test(txt)
            }

            check(/\d+/g, 'test')       //false
            check(/[a-z]+/g, 'test')    //true

            function curryingCheck(reg) {
                return function(txt) {
                    return reg.test(txt)
                }
            }
            var hasNumber = curryingCheck(/\d+/g)
            var hasLetter = curryingCheck(/[a-z]+/g)

            hasNumber('test1')      // true
            hasNumber('testtest')   // false
            hasLetter('21212')      // false
            ```

        * 延迟执行：累积传入的参数，最后执行
        * 固定易变因素：传参固定下来，生成一个更明确的应用函数。如bind函数用以固定this这个易变对象。

    * 封装
    ```js
    // 支持多参数传递
    function progressCurrying(fn, args) {

        var _this = this
        var len = fn.length;
        var args = args || [];

        return function() {
            var _args = Array.prototype.slice.call(arguments);
            Array.prototype.push.apply(args, _args);

            // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
            if (_args.length < len) {
                return progressCurrying.call(_this, fn, _args);
            }

            // 参数收集完毕，则执行fn
            return fn.apply(this, _args);
        }
    }
    ```

    * 反柯里化：把原来已经固定的参数或者this上下文等当作参数延迟到未来传递

    * 题目
    ```js
    function add() {
        // 第一次执行时，定义一个数组专门用来存储所有的参数
        var _args = Array.prototype.slice.call(arguments);
        console.log(1,arguments,_args)
        // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
        var _adder = function() {
            _args.push(...arguments);
            console.log(2,arguments,_args)
            return _adder;
        };

        // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
        _adder.toString = function () {
            console.log(3,_args)
            return _args.reduce(function (a, b) {
                console.log(4,_args,a,b)
                return a + b;
            });
        }
        console.log(5,_args)
        return _adder;
    }

    add(1)(2)(3) = 6;
    add(1, 2, 3)(4) = 10;
    add(1)(2)(3)(4)(5) = 15;
    add(1, 2, 3)(4, 5)(6) = 21;
    /*
    1 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ] (3) [1, 2, 3]
    5 (3) [1, 2, 3]
    2 Arguments(2) [4, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ] (5) [1, 2, 3, 4, 5]
    2 Arguments [6, callee: ƒ, Symbol(Symbol.iterator): ƒ] (6) [1, 2, 3, 4, 5, 6]
    3 (6) [1, 2, 3, 4, 5, 6]
    4 (6) [1, 2, 3, 4, 5, 6] 1 2
    4 (6) [1, 2, 3, 4, 5, 6] 3 3
    4 (6) [1, 2, 3, 4, 5, 6] 6 4
    4 (6) [1, 2, 3, 4, 5, 6] 10 5
    4 (6) [1, 2, 3, 4, 5, 6] 15 6
    ƒ 21
    */
    ```
    ```js
    const curry = (fn, ...args) =>
        args.length < fn.length
        ? (...arguments) => curry(fn,...args,...arguments)
        : fn(...args)

    function sumFn(a,b,c) {
        return a + b + c;
    }
    var sum = curry(sumFn);
    sum(1,2,3);
    sum(1)(2,3);
    sum(1)(2)(3);
    ```

### js依赖注入与控制反转

1. 参考链接：

    [细数Javascript技术栈中的四种依赖注入](https://www.cnblogs.com/front-end-ralph/p/5208045.html)

2. 详解：

    * 场景

        A想调用B的某些方法，于是A里面就要new一个B，后来A不用B了，想用C，于是就需要改A的代码，new B变为new C，代码耦合性高。

        因此，如果有一个容器能给到A，A就能用到B、C、D...的方法，而且没经调用的方法，不实例化对象，同样B也能通过容器用到其它方法，于是就用到依赖注入与控制反转。

    * 依赖注入与控制反转

        依赖注入与控制反转描述的是同一件事情，A靠注入的容器获取外部资源，容器反过来控制了A想获得的资源。

    * 实现


        ```js
        //es5
        function injector(){
            this.hadinstance = true;
            console.log('实例化injector,只有hadinstance:',this.hadinstance);
        }
        injector.prototype.A = function(){
            console.log('实例化A');
            return new A();
        };
        injector.prototype.B = function(){
            console.log('实例化B');
            return new B();
        };
        function myClass1(injector){
            this.myInjector = injector;
        }
        function A(){
            this.a = 'a';
            this.say=function(){
                alert('A');
            }
        }
        function B(){
            this.b = 'b';
            this.say=function(){
                alert('B');
            }
        }

        let test = new myClass1(new injector());//实例化injector,只有hadinstance: true
        Object.getOwnPropertyNames(test);//["myContainer"]
        Object.getOwnPropertyNames(injector.prototype);//(3) ["constructor", "A", "B"]
        Object.getOwnPropertyNames(new injector());//["hadinstance"]
        Object.getOwnPropertyNames(new A());//(2) ["a", "say"]
        test.myInjector.A().say();//实例化A
        test.myInjector.B().b;//实例化B

        //es6
        class injector{
            constructor(){
                this.hadinstance = true;
                console.log('实例化injector,只有hadinstance:',this.hadinstance);
            }
            A(){
                console.log('实例化A');
                return new A();
            }
            B(){
                console.log('实例化B');
                return new B();
            }
        }
        class myClass1{
            constructor(injector){
                this.myInjector = injector;
            }
        }
        class A{
            constructor(){
                this.a = 'a';
                this.say=function(){
                    alert('A');
                }
            }
        }
        class B{
            constructor(){
                this.b = 'b';
                this.say=function(){
                    alert('B');
                }
            }
        }
        let test = new myClass1(new injector());//实例化injector,只有hadinstance: true
        Object.getOwnPropertyNames(test);//["myContainer"]
        Object.getOwnPropertyNames(injector.prototype);//(3) ["constructor", "A", "B"]
        Object.getOwnPropertyNames(new injector());//["hadinstance"]
        Object.getOwnPropertyNames(new A());//(2) ["a", "say"]
        test.myInjector.A().say();//实例化A
        test.myInjector.B().b;//实例化B
        ```

### gulp和webpack

1. 参考链接：

    [gulp官方文档](https://www.gulpjs.com.cn/docs/getting-started/quick-start/)

    [webpack4.x配置详解，多页面，拆分代码，多入口，多出口，新特性新坑](https://www.cnblogs.com/pomelott/p/8977092.html)

    [webpack官网](https://www.webpackjs.com/concepts/)

    [Webpack 之 treeShaking](https://blog.csdn.net/VhWfR2u02Q/article/details/81916786)

    [webpack-js tree shaking](https://segmentfault.com/a/1190000020789501)

    [webpack 如何优雅的使用tree-shaking](https://blog.csdn.net/Mo_Luffy/article/details/99552314)

    [webpack的loader和plugin的区别](https://blog.csdn.net/qq_42375089/article/details/88072681)

    [超详细的webpack原理解读](https://segmentfault.com/a/1190000017890529?utm_source=tag-newest)

2. 详解：

    gulp
    ```txt
    //.babelrc
    {
        "presets": [
            "es2015"
        ]
    }
    ```
    ```js
    //3.9.0
    var gulp = require('gulp'),
        sass = require('gulp-sass'),
        autoprefixer = require('gulp-autoprefixer'),
        minifycss = require('gulp-minify-css'),
        imagemin = require('gulp-imagemin'),
        babel = require('gulp-babel'),
        jshint = require('gulp-jshint'),
        concat = require('gulp-concat'),
        uglify = require('gulp-uglify'),
        livereload = require('gulp-livereload'),
        notify = require('gulp-notify'),
        cache = require('gulp-cache'),
        rename = require('gulp-rename'),
        del = require('del');


    gulp.task('scripts', function() {
        gulp.src('src/js/Home/*.js')
            .pipe(babel())//转译es5，需配置.babelrc
            .pipe(uglify())//压缩
            .pipe(rename({ suffix: '.min' }))//重命名为*.min.js
            .pipe(gulp.dest('Content/themes/base/minjs/Home'))//输出文件到指定位置
            .pipe(notify({
                message: 'Home js task complete'//控制台输出任务完成
            }));
        gulp.src('src/js/Shared/*.js')
            .pipe(babel())
            .pipe(uglify())
            .pipe(rename({ suffix: '.min' }))
            .pipe(gulp.dest('Content/themes/base/minjs/Shared'))
            .pipe(notify({
                message: 'Shared js task complete'
            }));
    });

    gulp.task('styles', function() {
        gulp.src('src/scss/Home/*.scss')
            .pipe(sass())//编译sass
            .pipe(autoprefixer('last 2 version', 'safari 8', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))//自动添加prefix适配
            .pipe(minifycss())//压缩
            .pipe(rename({ suffix: '.min' }))//重命名为*.min.css
            .pipe(gulp.dest('Content/themes/base/css/Home'))//输出文件到指定位置
            .pipe(notify({
                message: 'Home css task complete'//控制台输出任务完成
            }));
        gulp.src('src/scss/Shared/*.scss')
            .pipe(sass())
            .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))
            .pipe(minifycss())
            .pipe(rename({ suffix: '.min' }))
            .pipe(gulp.dest('Content/themes/base/css/Shared'))
            .pipe(notify({
                message: 'Shared css task complete'
            }));
    });

    gulp.task('auto', function() {
        gulp.watch(['src/js/*/*.js'], ['scripts']);//监听文件变化
        gulp.watch(['src/scss/*/*.scss'], ['styles']);
    });

    gulp.task('default', ['styles', 'scripts', 'auto']);
    ```
    webpack
    ```js
    const webpack = require("webpack");
    const path = require('path');
    //返回匹配指定模式的文件名或目录
    const glob = require("glob");
    //消除冗余的css
    const purifyCssWebpack = require("purifycss-webpack");
    // html模板
    const htmlWebpackPlugin = require("html-webpack-plugin");
    // 清除目录等
    const cleanWebpackPlugin = require("clean-webpack-plugin");
    //4.x之前用以压缩
    const uglifyjsWebpackPlugin = require("uglifyjs-webpack-plugin");
    //ES压缩
    const UglifyESPlugin = require('uglify-webpack-plugin');
    // 分离css
    const extractTextPlugin = require("extract-text-webpack-plugin");
    //静态资源输出
    const copyWebpackPlugin = require("copy-webpack-plugin");

    module.exports = {
        entry: {
            // 多入口文件
            a: './src/js/index.js',
            b: './src/js/index2.js',
            jquery: 'jquery'
        },
        output: {
            path:path.resolve(__dirname, 'dist'),
            // 打包多出口文件
            // 生成 a.bundle.js  b.bundle.js  jquery.bundle.js
            filename: './js/[name].bundle.js'
        },
        // devtool: "source-map",  // 开启调试模式
        module:{
            rules: [
                {
                    test: /\.css$/,
                    // 不分离的写法
                    // use: ["style-loader", "css-loader"]
                    // 使用postcss不分离的写法
                    // use: ["style-loader", "css-loader", "postcss-loader"]
                    // 此处为分离css的写法
                    /*use: extractTextPlugin.extract({
                        fallback: "style-loader",
                        use: "css-loader",
                        // css中的基础路径
                        publicPath: "../"

                    })*/
                    // 此处为使用postcss分离css的写法
                    // use: extractTextPlugin.extract({
                    //     fallback: "style-loader",
                    //     use: ["css-loader", "postcss-loader"],
                    //     // css中的基础路径
                    //     publicPath: "../"
                    // })
                    //此处可配置压缩css
                    use: [
                        {
                            loader: 'style-loader'
                        },
                        {
                            loader: 'css-loader',
                            options: {
                                root: '/', //修改css中url指向的根目录, 默认值为/, 对于绝对路径, css-loader默认是不会对它进行处理的
                                modules: false, //开启css-modules模式, 默认值为flase
                                localIdentName: '[name]-[local]-[hash:base64:5]', //设置css-modules模式下local类名的命名
                                minimize: false, //压缩css代码, 默认false
                                camelCase: false, //导出以驼峰化命名的类名, 默认false
                                import: true, //禁止或启用@import, 默认true
                                url: true, //禁止或启用url, 默认true
                                sourceMap: false, //禁止或启用sourceMap, 默认false
                                importLoaders: 0, //在css-loader前应用的loader的数目, 默认为0
                                alias: {} //起别名, 默认{}
                            }
                        }
                    ]
                },
                {
                    test: /\.js$/,
                    use: ["babel-loader"],
                    // 不检查node_modules下的js文件
                    exclude: "/node_modules/"
                },
                {
                    test: /\.(png|jpg|gif)$/,
                    use: [{
                            // 需要下载file-loader和url-loader
                            loader: "url-loader",
                            options: {
                                limit: 50,
                                // 图片文件输出的文件夹
                                outputPath: "images"
                            }
                        }
                    ]
                },
                {
                    test: /\.(png|jpg|gif|svg)$/,
                    use: [
                    'file-loader',
                    {
                        loader: 'image-webpack-loader',
                        options: {
                            bypassOnDebug: true,
                            mozjpeg: {
                                progressive: true,
                                quality: 65
                            },
                            optipng: {
                                enabled: false,
                            },
                            pngquant: {
                                quality: '65-90',
                                speed: 4
                            },
                            gifsicle: {
                                interlaced: false,
                            },
                            // the webp option will enable WEBP
                            webp: {
                                enabled: false,
                            },
                            limit: 1,
                            name: '[name].[ext]?[hash]'
                        }
                    }]
                },
                {
                    test: /\.html$/,
                    // html中的img标签
                    use: ["html-withimg-loader"]
                },
                {
                    test: /\.less$/,
                    // 三个loader的顺序不能变
                    // 不分离的写法
                    // use: ["style-loader", "css-loader", "less-loader"]
                    // 分离的写法
                    use: extractTextPlugin.extract({
                        fallback:"style-loader",
                        use: ["css-loader", "less-loader"]
                    })
                },
                {
                    test: /\.(scss|sass)$/,
                    // sass不分离的写法，顺序不能变
                    // use: ["style-loader", "css-loader", "sass-loader"]
                    // 分离的写法
                    use: extractTextPlugin.extract({
                        fallback:"style-loader",
                        use: ["css-loader", "sass-loader"]
                    })
                }
            ]
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin(),
            // 调用之前先清除
            new cleanWebpackPlugin(["dist"]),
            // 4.x之前可用uglifyjs-webpack-plugin用以压缩文件，4.x可用--mode更改模式为production来压缩文件
            new UglifyJSPlugin({
                compress: {
                    warnings: false,  //删除无用代码时不输出警告
                    drop_console: true,  //删除所有console语句，可以兼容IE
                    collapse_vars: true,  //内嵌已定义但只使用一次的变量
                    reduce_vars: true,  //提取使用多次但没定义的静态值到变量
                },
                output: {
                    beautify: false, //最紧凑的输出，不保留空格和制表符
                    comments: false, //删除所有注释
                }
            }),
            //ES压缩插件
            new UglifyESPlugin({
                uglifyOptions: {  //比UglifyJS多嵌套一层
                    compress: {
                        warnings: false,
                        drop_console: true,
                        collapse_vars: true,
                        reduce_vars: true
                    },
                    output: {
                        beautify: false,
                        comments: false
                    }
                }
            }),
            new copyWebpackPlugin([{
                from: path.resolve(__dirname,"src/assets"),
                to: './public'
            }]),
            // 分离css插件参数为提取出去的路径
            new extractTextPlugin("css/index.css"),
            // 消除冗余的css代码
            new purifyCssWebpack({
                // glob为扫描模块，使用其同步方法
                paths: glob.sync(path.join(__dirname, "src/*.html"))
            }),
            // 全局暴露统一入口
            new webpack.ProvidePlugin({
                $: "jquery"
            }),
            // 自动生成html模板
            new htmlWebpackPlugin({
                minify:{
                    removeAttributeQuotes:true//去掉双引号
                },
                hash:true,//加入哈希来禁止缓存  
                filename: "index.html",// 编译后的文件及路径 
                title: "xxxx",
                chunks: ['a',"jquery"],  // 按需引入对应名字的js文件
                template: "./src/index.html"//  源模板
            }),
            new htmlWebpackPlugin({
                chunks: ['b'],
                filename: "index2.html",
                title: "page2",
                template: "./src/index2.html"
            })
        ],
        devServer: {
            contentBase: path.resolve(__dirname, "dist"),
            host: "localhost",
            port: "8090",
            open: true, // 开启浏览器
            hot: true   // 开启热更新
        },
        // 提取js，lib1名字可改
        optimization: {
            splitChunks: {
                cacheGroups: {
                    lib1: {
                        chunks: "initial",
                        name: "jquery",
                        enforce: true
                    }
                }
            }
        }

    }
    ```
    treeShaking

    * 描述

        解析js代码得出语法树，在保持代码运行结果不变的前提下，去除无用的代码(没有执行的代码，如不可能进入的if分支，return后的代码，声明后没用的变量)，使用的是编译原理中提到的DCE(dead code eliminnation)

        Tree-shaking是依赖ES6模块静态分析的，因为ES6 module只能作为模块顶层的语句出现，import 的模块名只能是字符串常量，import 绑定是不可改变的，依赖关系确定，与运行时无关

    * 使用

        使用插件压缩代码即可new webpack.optimize.UglifyJsPlugin()

    webpack文件的构建

    * entry: 入口文件
    * resolve: 文件路径指向(可加快打包过程)
    * output: 输出文件
    * module: 在webpack中一个模块对应一个文件。webpack会从entry开始，递归找出所有依赖的模块
        * rules
            * test: 匹配的文件名正则
            * use
                * loader: 模块转换器，用于将模块的原内容按照需求转换成新内容
                * option: 选项
    * plugins: 拓展插件解决loader无法完成的事，如压缩

    webpack执行

    1. 初始化参数

        1. 从配置文件(默认webpack.config.js)和shell语句中读取与合并参数，得出最终的参数
        2. 实例化Compiler
        3. 依次调用插件的apply方法，让插件可以监听后续的所有事件节点。同时向插件中传入compiler实例的引用，以方便插件通过compiler调用webpack的api
        4. 应用文件系统到compiler对象
        5. 读取配置的Entrys,为每个Entry实例化一个对应的EntryPlugin
        6. 调用完所有内置的和配置的插件的apply方法
        7. 根据配置初始化resolver,resolver负责在文件系统中寻找指定路径的文件

    2. 开始编译

        用上一步得到的参数初始化Comiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译

    3. 确定入口

        根据配置中的entry找出所有的入口文件

    4. 编译模块

        1. 启动一次编译
        2. 在监听模式下启动编译，文件发生变化会重新编译
        3. 告诉插件一次新的编译将要启动，同时会给插件带上compiler对象
        4. 检测到文件变化，便有一次新的compilation被创建，对象包含了当前的模块资源、编译生成资源、变化的文件等，提供事件回调给插件进行拓展
        5. 新的compilation对象创建完毕后，从entry开始读取文件,根据文件类型和编译的loader对文件进行编译,编译完后再找出该文件依赖的文件,递归地编译和解析
            1. 使用相应的Loader去转换一个模块
            2. 使用acorn解析转换后的内容，输出对应的抽象语法树
            3. 分析其AST,当遇到require等导入其他模块的语句时，便将其加入依赖的模块列表中，同时对于新找出来的模块递归分析，最终弄清楚所有模块的依赖关系
            4. 	所有模块及依赖的模块都通过Loader转换完成，根据依赖关系生成Chunk
        6. 一次compilation执行完成
        7. 当遇到错误会触发改事件,该事件不会导致webpack退出

    5. 完成编译模块

        经过第四步之后，得到了每个模块被翻译之后的最终内容以及他们之间的依赖关系

    6. 输出资源

        1. 所有需要输出的文件已经生成,询问插件有哪些文件需要输出,有哪些不需要输出
        2. 确定好要输出哪些文件后,执行文件输出
        3. 文件输出完毕
        4. 成功完成一次完整的编译和输出流程
        5. 如果在编译和输出中出现错误,导致webpack退出,就会直接跳转到本步骤,插件可以在本事件中获取具体的错误原因

    7. 输出完成

        在确定好输出内容后，根据配置(webpack.config.js && shell)确定输出的路径和文件名，将文件的内容写入文件系统中(fs)

    webpack会在特定的时间点广播特定的事件，插件监听事件并执行相应的逻辑，并且插件可以调用webpack提供的api改变webpack的运行结果


### 用户查找、光标、右键功能行为

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * 浏览器搜索功能(ctrl F或js window.find),无需遍历json或后台处理
    ```js
    //有bug，未来可能废弃
    window.find(要搜索的字符串, true区分大小写, true向上搜索, true循环搜索,true全字匹配搜索(该参数无效), true会搜索框架内的文本, true弹出一个搜索对话框);
    ```

    * 用户选择的文本范围或光标的当前位置(window.getSelection或Document.getSelection())
    ```js
    const selection = window.getSelection()
    const selection2 = document.getSelection()
    //属性
    //Selection {anchorNode: text, anchorOffset: 37, focusNode: text, focusOffset: 41, isCollapsed: false, …}
    //>anchorNode: text 选区开始位置所属的节点
    //>anchorOffset: 37 选区开始位置
    //>baseNode: text
    //>baseOffset: 37
    //>extentNode: text
    //>extentOffset: 41
    //>focusNode: text 选区结束位置所属的节点
    //>focusOffset: 41 选区结束位置
    //>isCollapsed: false 选区的起始点和终止点是否位于一个位置
    //>rangeCount: 1 选区中range对象数量(跨越多少个标签)
    //>type: "Range" 选区类型
    //方法
    //containsNode()判断指定的节点是否包含在Selection中
    //更多方法查看mdn
    ```

    * 禁用右键功能
    ```js
    window.oncontextmenu = function () {return false;}
    ```

    * 禁止选中文本
    ```js
    window.onselectstart = function () {return false;}
    ```

    * 禁止复制
    ```js
    document.oncopy = function () {return false;}
    ```

### 表单输入重置与hover提示文字

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * 表单重置

        Form.reset()或点击input type=reset

    * 提交按钮使用图片

        input type=image src

    * hover显示提示文字

        title属性

### 特殊事件与自定义事件

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * 浏览器失去/正常网络连接,navigator.onLine为false/true时，触发事件offline/online
    * 设备的纵横方向改变事件:orientationchange
    * 存储区域（localStorage 或 sessionStorage）被修改,触发 storage 事件
    * Promise 被 reject 且没有 reject 处理,触发 unhandledrejection,值兼容chrome，edge，firefox
    * 自定义事件 CustomEvent
    ```js
    obj.addEventListener("cat", function(e) { process(e.detail)});

    //事件名称：cat，配置项：bubbles默认false不冒泡，cancelable默认false事件不可取消，detail事件初始化时传递的数据.
    var event = new CustomEvent("cat", {
        detail: {
            hazcheeseburger: true
        }
    });
    //继承event所有属性和方法
    //bubbles: false
    //cancelBubble: false
    //cancelable: false
    //composed: false
    //currentTarget: null
    //defaultPrevented: false
    //detail: {hazcheeseburger: true}
    //eventPhase: 0
    //isTrusted: false
    //path: []
    //returnValue: true
    //srcElement: null
    //target: null
    //timeStamp: 480928.11999982223
    //type: "cat"
    //Event.composedPath()
    //Event.preventDefault()
    //Event.stopImmediatePropagation()
    //Event.stopPropagation()
    obj.dispatchEvent(event);
    ```

### DOM树解析和更改与遍历

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * XML/HTML源代码解析为DOM Document：DOMParser.parseFromString，相反操作：XMLSerializer.serializeToString
    ```js
    let parser = new DOMParser(),
    doc = parser.parseFromString(XML/HTML源代码(可url), 指定类型字符串("application/xml","image/svg+xml","text/html","application/xml"));

    var s = new XMLSerializer();
    var d = document;
    var str = s.serializeToString(d);
    ```

    * 监视对DOM树所做更改
    ```js
    let targetNode = document.querySelector(`#id`);

    // 配置
    let config = {
        attributeFilter:[特定属性名称],//要监视的特定属性名称的数组
        attributeOldValue: true,//记录任何有改动的属性的上一个值,无默认值
        attributes: true,//监视元素属性值变更,默认false
        characterData: true,//监视目标节点子树节点所包含的字符数据的变化,无默认值
        characterDataOldValue: true,//记录节点文本的先前值.无默认值
        childList: true,//监视目标节点添加或删除新的子节点,默认false
        subtree: true//监视目标节点子树添加或删除新的子节点,默认false
    };

    // 更改被监测到时执行
    const mutationCallback = (mutationsList) => {
        for(let mutation of mutationsList) {
            let type = mutation.type;
            switch (type) {
                case "childList":
                    console.log("A child node has been added or removed.");
                    break;
                case "attributes":
                    console.log(`The ${mutation.attributeName} attribute was modified.`);
                    break;
                case "subtree":
                    console.log(`The subtree was modified.`);
                    break;
                default:
                    break;
            }
        }
    };

    let observer = new MutationObserver(mutationCallback);

    //开始监测
    observer.observe(targetNode, config);

    //停止监测
    observer.disconnect();
    ```

    * 遍历文档的子树中的所有节点及其位置 document.createTreeWalker()
    ```js
    treeWalker = document.createTreeWalker(根节点, 过滤某些内容节点[option], NodeFilter 对象, 标识符(已废弃));
    ```
    ```js
    var treeWalker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_ELEMENT,
        { acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
        false
    );

    var nodeList = [];

    while(treeWalker.nextNode()) nodeList.push(treeWalker.currentNode);
    ```
    1. option
        * NodeFilter.SHOW_ALL -1 显示所有节点
        * NodeFilter.SHOW_ATTRIBUTE 2 显示特性Attr节点 废弃
        * NodeFilter.SHOW_CDATA_SECTION 8 显示CDTA CDATASection 节点 废弃
        * NodeFilter.SHOW_COMMENT 128 显示注释Comment节点
        * NodeFilter.SHOW_DOCUMENT 256 显示文档Document节点
        * NodeFilter.SHOW_DOCUMENT_FRAGMENT 1024 显示文档片段DocumentFragment节点
        * NodeFilter.SHOW_DOCUMENT_TYPE 512 显示文档类型DocumentType节点
        * NodeFilter.SHOW_ELEMENT 1 显示元素Element节点
        * NodeFilter.SHOW_ENTITY 32 显示实体Entity节点 废弃
        * NodeFilter.SHOW_ENTITY_REFERENCE 16 显示实体引用 废弃
        * NodeFilter.SHOW_NOTATION 2048 显示符号Notation 节点 废弃
        * NodeFilter.SHOW_PROCESSING_INSTRUCTION 64 显示处理指令 ProcessingInstruction节点
        * NodeFilter.SHOW_TEXT 4 显示文字Text nodes节点
    2. NodeFilter
    ```js
    var nodeIterator = document.createNodeIterator(
        
        document.getElementById('someId'),

        NodeFilter.SHOW_TEXT,

        { 
            acceptNode: function(node) {
                if ( ! /^\s*$/.test(node.data) ) {
                    return NodeFilter.FILTER_ACCEPT;
                    //return NodeFilter.FILTER_REJECT;
                    //return NodeFilter.FILTER_SKIP;
                }
            }
        },
        false
    );

    var node;

    while ((node = nodeIterator.nextNode())) {
        alert(node.data);
    }
    ```


### js获取视频第一帧

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

    [JS获取HTML video标签视频第一帧](https://blog.csdn.net/weixin_33915554/article/details/92002316)

    [Dynamically using the first frame as poster in HTML5 video?](https://stackoverflow.com/questions/7323053/dynamically-using-the-first-frame-as-poster-in-html5-video)

2. 详解：

    * loadeddata事件:媒体资源的第一帧加载完成时被触发
    ```js
    //部分浏览器生效
    <video id="video" src="/1.MP4" controls></video>//资源不跨域
    <div id="output"></div>
    $(()=>{
        var output = document.getElementById("output");
        var video = document.getElementById("video");
        video.addEventListener('loadeddata', function () {
            var canvas = document.createElement("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);

            var img = document.createElement("img");
            img.src = canvas.toDataURL("image/png");
            output.appendChild(img);
        });
    })
    ```

    * [Popcorn.js](https://github.com/mozilla/popcorn-js/)
    ```js
    var video = Popcorn("#video-id");

    video.listen("canplayall", function() {
        this.currentTime(10).capture();
    });
    ```

### 浏览器性能数据

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * Window.performance
    ```js
    memory: MemoryInfo
        jsHeapSizeLimit: 2197815296
        totalJSHeapSize: 15563541
        usedJSHeapSize: 12592021
        __proto__: MemoryInfo
    navigation: PerformanceNavigation//网页导航的类型
        redirectCount: 0
        type: 1
        __proto__: PerformanceNavigation
    onresourcetimingbufferfull: null
    timeOrigin: 1571303991051.22
    timing: PerformanceTiming//包含延迟相关的性能信息
        connectEnd: 1571303991051
        connectStart: 1571303991051
        domComplete: 1571303992579
        domContentLoadedEventEnd: 1571303992574
        domContentLoadedEventStart: 1571303992569
        domInteractive: 1571303992569
        domLoading: 1571303992522
        domainLookupEnd: 1571303991051
        domainLookupStart: 1571303991051
        fetchStart: 1571303991051
        loadEventEnd: 1571303992582
        loadEventStart: 1571303992579
        navigationStart: 1571303991049
        redirectEnd: 0
        redirectStart: 0
        requestStart: 1571303991068
        responseEnd: 1571303992519
        responseStart: 1571303992515
        secureConnectionStart: 0
        unloadEventEnd: 1571303992518
        unloadEventStart: 1571303992518
        __proto__: PerformanceTiming
    __proto__: Performance
    //方法
    performance.mark(time)//某一时刻，单位：ms，最高精确到5us
    performance.now()//从某一时刻到调用该方法时刻的毫秒数
    //页面加载时间
    var perfData = window.performance.timing; 
    var pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
    //请求响应时间
    var connectTime = perfData.responseEnd - perfData.requestStart;
    //页面渲染时间
    var renderTime = perfData.domComplete - perfData.domLoading;
    ```

### 媒体查询匹配

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    ```js
    window.matchMedia("(min-width: 400px)")
    //matches: true
    //media: "(min-width: 400px)"
    //onchange: null
    //__proto__: MediaQueryList
    ```

### 浏览器对话与打印

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

2. 详解：

    * window.prompt对话框

    ```js
    用户输入文字 = window.prompt(提示用户输入文字, 文本输入框默认值);
    ```

    * console.assert()断言

    ```js
    const errorMsg = 'the # is not even';
    for (let number = 2; number <= 5; number += 1) {
        console.log('the # is ' + number);
        console.assert(number % 2 === 0, {number: number, errorMsg: errorMsg});
        // 或者使用 ES2015 对象简写:
        // console.assert(number % 2 === 0, {number, errorMsg});
    }
    // 输出:
    // the # is 2
    // the # is 3
    // Assertion failed: {number: 3, errorMsg: "the # is not even"}
    // the # is 4
    // the # is 5
    // Assertion failed: {number: 5, errorMsg: "the # is not even"}
    ```

    * Console.count() Console.countReset() 输出计数

    ```js
    var user = "";

    function greet() {
    console.count();
    return "hi " + user;
    }

    user = "bob";
    greet();
    user = "alice";
    greet();
    greet();
    console.count();
    console.countReset();
    // 输出:
    // "default: 1"
    // "default: 2"
    // "default: 3"
    // "default: 1"
    // "default: 0"
    var user = "";

    function greet() {
    console.count(user);
    return "hi " + user;
    }

    user = "bob";
    greet();
    user = "alice";
    greet();
    greet();
    console.countReset("bob");
    console.count("alice");
    // 输出:
    // "bob: 1"
    // "alice: 1"
    // "alice: 2"
    // "bob: 0"
    // "alice: 3"
    ```

    * console.dir打印对象树

    ```js
    console.dir(object)
    ```

    * Console.dirxml()显示xml/html交互树(可折叠拉伸的标签)

    ```js
    console.dir(object)
    ```

    * console.log console.info console.warn console.error console.debug 输出不同级别信息

    ```js
    console.log(obj1,obj2...)
    console.info(obj1,obj2...)
    console.warn(obj1,obj2...)
    console.error(obj1,obj2...)
    console.debug(obj1,obj2...)
    console.log('String: %s, Int: %d,Float: %f, Object: %o, Style: %c', "字符串", "整数", "浮点数", "对象", "样式")
    console.log('the word is %s try number %d', 'foo', 123)
    console.log(`temp的值为: ${temp}`)
    console.log("%c3D Text"," text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em")
    ```

    * console.group console.groupCollapsed console.groupEnd()输出分组

        * console.group创建新的分组.内容输出当前分组,直到调用console.groupEnd()之后,结束分组
        * console.groupCollapsed与group的区别是输出内容不折叠
        * console.groupEnd结束分组

    * Console.table打印表格

    ```js
    //可点击列名排序
    console.table([["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]])
    //可隐藏指定列
    console.table([["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]],["1"])
    ```

    * console.time console.timeEnd console.timeLog 打印占用时长

        * console.time(timerName)计时开始
        * console.timeEnd(timerName)计时结束，打印经过的时间
        * console.timeLog(timerName)计时结束，打印经过的时间,并带上timer名

    * console.trace()输出堆栈跟踪

### 人工标注文档Range

1. 参考链接：

    [Window](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)

    [JS Range 对象的使用](https://blog.csdn.net/m0_37885651/article/details/88353305)

    [JavaScript之Range--或许会有点用](https://segmentfault.com/a/1190000015142374)

2. 详解：

    * 应用场景：文档标注

    * range储存网页选中文字位置

        * window.getSelection().getRangeAt(0) Selection转Range
        ```js
        collapsed: false//是否起始点和结束点是同一个位置
        commonAncestorContainer: text//返回目标节点的共有祖先节点
        endContainer: text//返回结束的Node
        endOffset: 96//返回结束位置在目标节点起始的偏移值
        startContainer: text//返回开始的Node
        startOffset: 19//返回开始位置在目标节点起始的偏移值
        __proto__: Range
        //方法
        Range.cloneContents()//返回DocumentFragment，可用于插入节点
        Range.cloneRange()//返回被克隆range
        Range.selectNode()//设置range包含整个节点
        Range.selectNodeContents()//设置Range包含节点的内容
        Range.collapse(bool)//设置起始点和结束点是否折叠
        Range.compareBoundaryPoints(how, sourceRange)//返回边界节点与指定范围对比
        //how:
        //Range.END_TO_END尾与尾对比
        //Range.END_TO_START尾与始对比
        //Range.START_TO_END始与尾对比
        //Range.START_TO_START始与始对比
        //返回值：-1,0,1表示前于，相同，后于
        Range.comparePoint(新节点，偏移量)//节点与新节点的偏移量比较，返回值：-1,0,1表示前于，相同，后于
        Range.createContextualFragment(string)//字符串转DocumentFragment
        Range.deleteContents()//移除内容
        Range.detach()//使range锁定或解锁
        documentFragment = range.extractContents()//range转documentFragment
        boundingRect = range.getBoundingClientRect()//返回矩形
        rectList = range.getClientRects()//返回矩形列表
        Range.insertNode(新节点)//在Range的起始位置插入节点
        bool = range.intersectsNode(节点)//判断节点与范围是否相交
        bool = range.isPointInRange(新节点，偏移量)//判断节点的偏移量与范围是否相交
        Range.setEnd(新节点，偏移量)//设置Range结束位置
        Range.setEndAfter(节点)//设置Range结束位置在指定节点之后
        Range.setEndBefore(节点)//设置Range结束位置在指定节点之前
        Range.setStart(新节点，偏移量)//设置Range起始位置
        Range.setStartAfter(节点)//设置Range起始位置在指定节点之后
        Range.setStartBefore(节点)//设置Range起始位置在指定节点之前
        Range.surroundContents(新节点)//将Range内容移动到新节点
        text = range.toString()//Range序列化字符串
        ```

        * 手动创建Range

        ```js
        var range = document.createRange();
        range.setStart(startContainer, startOffset);
        range.setEnd(endContainer, endOffset);
        ```

        * xpath(xml路径语言)和range互转
        ```js
        function getElementXPath (element) {
            if (!element) return null

            if (element.id) {
                return `//*[@id=${element.id}]`
            } else if (element.tagName === 'BODY') {
                return '/html/body'
            } else {
                const sameTagSiblings = Array.from(element.parentNode.childNodes)
                .filter(e => e.nodeName === element.nodeName)
                const idx = sameTagSiblings.indexOf(element)

                return getElementXPath(element.parentNode) +
                '/' +
                element.tagName.toLowerCase() +
                (sameTagSiblings.length > 1 ? `[${idx + 1}]` : '')
            }
        }
        function createRangeFromXPathRange (xpathRange) {
            var startContainer,
            endContainer,
            endOffset,
            evaluator = new XPathEvaluator()

            // must have legal start and end container nodes
            startContainer = evaluator.evaluate(
                xpathRange.startContainerPath,
                document.documentElement,
                null,
                XPathResult.FIRST_ORDERED_NODE_TYPE,
                null
            )
            if (!startContainer.singleNodeValue) {
                return null
            }

            if (xpathRange.collapsed || !xpathRange.endContainerPath) {
                endContainer = startContainer
                endOffset = xpathRange.startOffset
            }
            else {
                endContainer = evaluator.evaluate(
                    xpathRange.endContainerPath,
                    document.documentElement,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                )
                if (!endContainer.singleNodeValue) {
                    return null
                }

                endOffset = xpathRange.endOffset
            }

            // map to range object
            var range = document.createRange()
            range.setStart(startContainer.singleNodeValue, xpathRange.startOffset)
            range.setEnd(endContainer.singleNodeValue, endOffset)
            return range
        }
        ```


### height和top与y
1. 参考链接：

    [Measuring Element Dimension and Location with CSSOM in Windows Internet Explorer 9](https://docs.microsoft.com/en-us/previous-versions/hh781509(v=vs.85))

    [getBoundingClientRect的用法](https://www.cnblogs.com/Songyc/p/4458570.html)

    [js窗口尺寸获取常用属性](https://blog.csdn.net/csdnxcn/article/details/77886499)

2. 详解：

    外层蓝色父元素与包裹内层红色子元素，虚线与实线间为margin，深色区为border-width，内虚线到深色区为padding，内层灰色区为滚动区。

    ![position1](./position1.png)
    ![position2](./position2.png)
    ![position3](./position3.png)

    * object.getBoundingClientRect()

        获取元素相对于视窗的位置集合，集合中有top, right, bottom, left等属性。

        ![getBoundingClientRect](./getBoundingClientRect.jpg)

    * height相关

        * box-sizing:border-box怪异模式

            totalHeight=contentHeight(padding向内收)+margin

        * box-sizing:content-box标准模式

            totalHeight=contentHeight+padding(padding向外张)+border+margin

    * scroll相关

        * scrollTop:距离滚动区顶部距离
        * scrollHeight:滚动区高度

    * offset相关

        * offsetTop:距离父元素顶部距离(不包含边线)
        * offsetHeight:距离父元素顶部距离(包含边线)
        * offsetY:指针距离元素顶部距离(不含border，旋转不变)

    * layer相关

        * layerY:指针距离元素顶部距离(含border，旋转不变)

    * client相关

        * clientTop:边框厚度，相当于borderTopWidth
        * clientHeight:包含padding的内容高度，不包括滚动
        * clientY:指针距离可视区顶部距离

    * page相关

        * pageY:指针距离文档顶部距离

    * screen相关

        * screenY:指针距离屏幕顶部距离

    * y:指针相对于当前文档y坐标

### 页面复制文字时自动加版权
1. 参考链接：

    [JS实现页面复制文字时自动加版权](https://blog.csdn.net/lzuacm/article/details/88197591)

2. 详解：

    利用chrome查看网站触发某事件(如copy)时的代码:

        F12-source-Event Listener Breakpoints-选择事件打勾-触发事件

        可以看到csdn使用copyright.js，百度即可，或搜索“js加版权”

    ```js
    $(document).on('copy', function(e)
    {
        var selected = window.getSelection();
        var selectedText = selected.toString().replace(/\n/g, '<br>');
        var copyFooter = '<br>---------------------<br>著作权归作者所有。<br>' 
                                + '商业转载请联系作者获得授权，非商业转载请注明出处。<br>'
                                + '作者：Bravo Yeung<br> 源地址：' + document.location.href
                                + '<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！';
        var copyHolder = $('<div>', {id: 'temp', html: selectedText + copyFooter, style: {position: 'absolute', left: '-99999px'}});
        //创建div，内容为选中的文字+附加的内容，位置设为不可见
        $('body').append(copyHolder);
        selected.selectAllChildren(copyHolder[0]);//把指定元素的所有子元素设为选中区域，并取消之前的选中区域
        window.setTimeout(function() {
            copyHolder.remove();
        },0);
    });
    ```
    ```js
    var ua = navigator.userAgent.toLowerCase();
    if (window.ActiveXObject) {  /* 兼容IE */
        document.body.oncopy = function () {
            event.returnValue = false;
            var selectedText = document.selection.createRange().text;
            var pageInfo = '<br>---------------------<br>著作权归作者所有。<br>'
                + '商业转载请联系作者获得授权，非商业转载请注明出处。<br>'
                + '作者：Bravo Yeung<br> 源地址：' + document.location.href
                + '<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！';
            clipboardData.setData('Text', selectedText.replace(/\n/g, '<br>') + pageInfo);
        }
    }
    else {
        function addCopyRight() {
            var body_element = document.getElementsByTagName('body')[0];
            var selection = window.getSelection();
            var pageInfo = '<br>---------------------<br>著作权归作者所有。<br>'
                + '商业转载请联系作者获得授权，非商业转载请注明出处。<br>'
                + '作者：Bravo Yeung<br> 源地址：' + document.location.href
                + '<br>来源：博客园cnblogs<br>© 版权声明：本文为博主原创文章，转载请附上博文链接！';
            var copyText = selection.toString().replace(/\n/g, '<br>') + pageInfo;
            var newDiv = document.createElement('div');
            newDiv.style.position = 'absolute';
            newDiv.style.left = '-99999px';
            body_element.appendChild(newDiv);
            newDiv.innerHTML = copyText;
            selection.selectAllChildren(newDiv);
            window.setTimeout(function () {
                body_element.removeChild(newDiv);
            }, 0);
        }
        document.oncopy = addCopyRight;
    }
    ```

### delete操作符

1. 参考链接：

    [delete 操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete)

2. 详解：

    ```js
    //delete 操作符用于删除对象的某个属性；如果没有指向这个属性的引用，那它最终会被释放。
    //delete object.property 
    //delete object['property']
    //对于所有情况都是true，除非属性是一个自己不可配置的属性，在这种情况下，非严格模式返回 false。
    //不可设置的(Non-configurable)属性不能被移除。Math, Array, Object内置对象的属性以及使用Object.defineProperty()方法设置为不可设置的属性不能被删除,返回false。
    //非对象类型，使用delete会返回false。
    const Employee = {
        firstname: 'John',
        lastname: 'Doe'
    }

    console.log(Employee.firstname);
    // expected output: "John"

    delete Employee.firstname;

    console.log(Employee.firstname);
    // expected output: undefined
    ```

### 数组模拟dictionary与二重排序

1. 参考链接：

    [js字典排序](https://blog.csdn.net/juyuyh/article/details/89948380)
    [JS sort()排序及JS sort()双重排序](https://blog.csdn.net/qq416761940/article/details/79632018)
    [前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/submissions/)

2. 详解：

    * 关于sort

        * sort([function(a,b){return ±num}])

        * 不传function则按照字典序升序排序，传function则按数字大小排序，负数为升序排序，正数为降序排序

        * sort按照字典序降序排序方法，通过比较if(a>b)，返回正数还是负数，控制排序顺序

        * 多重排序也可通过if判断，返回正负数控制排序顺序，其中if里面的参数可以与原数组array1无关，如array2[a]>array2[b]

    * 样例

        统计词频，按照词频降序排序，词频相同按照字典序升序排序
        ```js
            let words = ["plpaboutit","jnoqzdute","sfvkdqf","mjc","nkpllqzjzp","foqqenbey","ssnanizsav","nkpllqzjzp","sfvkdqf","isnjmy","pnqsz","hhqpvvt","fvvdtpnzx","jkqonvenhx","cyxwlef","hhqpvvt","fvvdtpnzx","plpaboutit","sfvkdqf","mjc","fvvdtpnzx","bwumsj","foqqenbey","isnjmy","nkpllqzjzp","hhqpvvt","foqqenbey","fvvdtpnzx","bwumsj","hhqpvvt","fvvdtpnzx","jkqonvenhx","jnoqzdute","foqqenbey","jnoqzdute","foqqenbey","hhqpvvt","ssnanizsav","mjc","foqqenbey","bwumsj","ssnanizsav","fvvdtpnzx","nkpllqzjzp","jkqonvenhx","hhqpvvt","mjc","isnjmy","bwumsj","pnqsz","hhqpvvt","nkpllqzjzp","jnoqzdute","pnqsz","nkpllqzjzp","jnoqzdute","foqqenbey","nkpllqzjzp","hhqpvvt","fvvdtpnzx","plpaboutit","jnoqzdute","sfvkdqf","fvvdtpnzx","jkqonvenhx","jnoqzdute","nkpllqzjzp","jnoqzdute","fvvdtpnzx","jkqonvenhx","hhqpvvt","isnjmy","jkqonvenhx","ssnanizsav","jnoqzdute","jkqonvenhx","fvvdtpnzx","hhqpvvt","bwumsj","nkpllqzjzp","bwumsj","jkqonvenhx","jnoqzdute","pnqsz","foqqenbey","sfvkdqf","sfvkdqf"];
            let dictionary = new Array();
            for(let i = 0;i < words.length;i++){
                if(!dictionary[words[i]]){
                    dictionary[words[i]] = 1;
                }
                else{
                    dictionary[words[i]]++;
                }
            }
            let result = Object.keys(dictionary).sort((a,b)=>{
                if(dictionary[a] == dictionary[b]){
                    if(a > b){
                        return 1;
                    }
                    else{
                        return -1;
                    }
                }
		        return dictionary[b] - dictionary[a];
            });
            for(let value of result){
                console.log(value,dictionary[value])
            }
        ```

### 已知或者未知宽度的垂直水平居中

1. 参考链接：

    [一年半经验，百度，有赞，阿里前端面试总结](https://zhuanlan.zhihu.com/p/83803079)

2. 详解：

    ```scss
    // 1
    .wrapper {
        position: relative;
        .box {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100px;
            height: 100px;
            margin: -50px 0 0 -50px;
        }
    }

    // 2
    .wrapper {
        position: relative;
        .box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    }
    // 3
    .wrapper {
        .box {
            display: flex;
            justify-content:center;
            align-items: center;
            height: 100px;
        }
    }

    // 4
    .wrapper {
        display: table;
        .box {
            display: table-cell;
            vertical-align: middle;
        }
    }
    ```

### 简单实现双向数据绑定mvvm

1. 参考链接：

    [一年半经验，百度，有赞，阿里前端面试总结](https://zhuanlan.zhihu.com/p/83803079)

2. 详解：

    ```js
    <input id="input"/>
    const data = {};
    const input = document.getElementById('input');
    Object.defineProperty(data, 'text', {
        set(value) {
            input.value = value;
            this.value = value;
        }
    });
    input.onchange = function(e) {
        data.text = e.target.value;
    }
    ```

### 三角形

1. 参考链接：

    * [CSS绘制三角形和箭头](http://www.divcss5.com/rumen/r50847.shtml)
    * [CSS实现带阴影效果的三角形](https://blog.csdn.net/foreversober/article/details/74361402)

2. 详解：

    * 三角形原理

        ```css
        /*<div class="box"></div>*/
        .box{
            width: 0; 
            height: 0;
            border-width: 100px;
            border-style: solid;
            border-color: red green blue yellow;
        }
        ```

        1. 可以看到div呈现的正方形由4个三角形组成，上右下左分别为红绿蓝黄。
        2. border-color控制上右下左4个三角形颜色。
        3. 调节border-width可控制三角形斜边长度。
        4. 调节width和height可使4个三角形变为梯形，中间多出宽为width，高为height的正方形。

    * 普通三角形

        border-color三个方向设置为透明，即可得到一个方向的三角形。
        ```css
        /*<div class="box"></div>*/
        .box{
            width: 0; 
            height: 0;
            border-width: 100px;
            border-style: solid;
            border-color: red transparent transparent transparent;
        }
        ```

    * 不同角度的三角形

        ```css
        /*<div class="box"></div>*/
        .box{
            width: 0; 
            height: 0;
            border-width: 100px;
            border-style: solid;
            border-color: red transparent transparent transparent;
            transform: rotate(45deg); /*顺时针旋转45°*/
        }
        ```

    * 箭头

        ```css
        /*<div class="left"></div>*/
        .left{
            position: relative;
        }
        .left:before,.left:after{
            position: absolute;
            content: '';
            border-width: 10px;
            border-color:transparent #fff transparent transparent;
            border-style: solid;
        }
        .left:before{
            border-right-color: #0099CC;
        }
        .left:after{
            left: 1px; /*覆盖并错开1px*/
            border-right-color: #fff;/*当前body背景色*/
        }
        ```

        1. 通过before和after制造2个三角形
        2. 伪元素通过设置content占有空间
        3. 通过after借助背景色和位置偏移，部分覆盖before，产生箭头

    * 带阴影三角形的对话框

        ```css
        /*<div class="box"></div>*/
        .box {
            position: relative;
            width: 600px;
            height: 400px;
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 2px #ccc;
        }
        .box:after {
            position: absolute;
            top: 380px;
            left: 300px;
            content: '';
            border-style: solid;
            border-width: 20px;
            border-color: #fff #fff transparent transparent;
            transform: rotate(135deg);
            box-shadow: 2px -2px 2px #ccc;
        }
        ```

        1. 先建造带阴影的矩形对话框
        2. 设置border-color建造半个正方形大小的三角形，使三角形能覆盖住对话框的阴影
        3. 定位、旋转、设置三角形阴影

        box-shadow相关：

            box-shadow: 水平阴影的位置(必需,允许负值) 垂直阴影的位置(必需,允许负值) [模糊距离] [阴影尺寸] [阴影颜色] [阴影向内(设置inset，外部为outset)];

### webWorker与serviceWorker

1. 参考链接：

    * [Web Worker 使用教程](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)
    * [Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker)
    * [serviceWorker 入门](https://www.jianshu.com/p/4f9e3b66bb69)
    * [Service Worker ——这应该是一个挺全面的整理](https://blog.csdn.net/huangpb123/article/details/89498418)

2. 详解：

    * web worker

        * js单线程使多核CPU产生性能浪费，主线程(UI)可以创建Worker线程，复杂高延时的计算任务让Worker在后台负责，互不影响并返回结果。
        * Worker创建成功后会始终运行，为免耗费资源，应在使用完后关闭。

        * 注意：
            1. Worker的js需与主线程js同源
            2. 不能使用DOM(document,window)，可以使用(navigator,location)
            3. Worker与主线程需借助“消息”通信
            4. 不能使用alert和console，能使用xhr
            5. 不能读取file://开头的本地文件，但能读取网络文件

        * 基本用法：

            index.html
            ```html
            <!DOCTYPE html>
            <html>
            <head>
                <title>Web Workers basic example</title>
            </head>

            <body>
                <h1>Web Workers basic example</h1>

                <div class="controls" tabindex="0">

                    <form>
                        <div>
                            <label for="number1">Multiply number 1: </label>
                            <input type="text" id="number1" value="0">
                        </div>
                        <div>
                            <label for="number2">Multiply number 2: </label>
                            <input type="text" id="number2" value="0">
                        </div>
                    </form>

                <p class="result">Result: 0</p>

                </div>
                <script src="main.js"></script>
            </body>
            </html>
            ```

            main.js
            ```js
            const first = document.querySelector('#number1');
            const second = document.querySelector('#number2');

            const result = document.querySelector('.result');

            if (window.Worker) {
                //调用Worker()构造函数，新建一个 Worker 线程,worker.js需位于网络位置，如localhost
                const myWorker = new Worker("worker.js");

                first.onchange = function() {
                    //主线程调用worker.postMessage()方法，向 Worker 发消息
                    myWorker.postMessage([first.value, second.value]);
                    console.log('Message posted to worker');
                }

                second.onchange = function() {
                    myWorker.postMessage([first.value, second.value]);
                    console.log('Message posted to worker');
                }

                myWorker.onmessage = function(e) {
                    //主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息
                    result.textContent = e.data;
                    console.log('Message received from worker');
                }
                //Worker 完成任务以后，主线程就可以把它关掉。
                //worker.terminate();//由于这里onchange调用，需要一直运行worker
                //监听 Worker 是否发生错误
                worker.onerror(function (event) {
                    console.log([
                        'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message
                    ].join(''));
                });

                // 或者
                worker.addEventListener('error', function (event) {
                    // ...
                });
            }
            else {
                console.log('Your browser doesn\'t support web workers.')
            }
            ```

            worker.js
            ```js
            //Worker 线程内部需要有一个监听函数，监听message事件。
            //4种等价写法：
            //1. this.addEventListener('message', function (e)...
            //2. self.addEventListener('message', function (e)...
            //3. addEventListener('message', function (e)...
            //4. onmessage = function(e)...
            onmessage = function(e) {
                console.log('Worker: Message received from main script');
                let result = e.data[0] * e.data[1];
                if (isNaN(result)) {
                    postMessage('Please write two numbers');
                } else {
                    let workerResult = 'Result: ' + result;
                    console.log('Worker: Posting message back to main script');
                    postMessage(workerResult);
                }
            }
            //加载其它worker脚本
            //importScripts('script1.js', 'script2.js');
            //关闭 Worker
            //self.close();
            ```
        
    * service worker

        * Service Worker 可理解为一个介于客户端和服务器之间的一个代理服务器，可以拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存。
        * 兼容性：chrome，firefox，edge17+，safari11.1+
        * 不能访问DOM
        * postMessage传递数据
        * 不阻塞主线程
        * Service Worker 是一个浏览器中的进程而不是浏览器内核下的线程，注册后可在多个页面使用

        * 生命周期
            ![serviceWorker](./serviceWorker.png)
            * register:client端发起register，注册serviceWorker。
            * install:注册成功后立即触发install事件。
            * activate:安装后要等待激活activated事件，install后不会立即触发activated事件。
            * idle:activate后对client的请求进行拦截处理，使用fetch api。
                * 默认不会带上cookie，若想带上，需设置{ credential: 'include' }
                * 跨域资源需设置 { mode: 'cors' }
            * terminate:长时间闲置，浏览器会暂停。
            * caches:只能缓存 GET & HEAD 的请求,POST 等类型请求，返回数据可以保存在 indexDB 中

        * 基本用法：
            index.js
            ```js
            if ('serviceWorker' in window.navigator) {
                //register(文件路径(相对于Origin,非当前js文件的目录),scope属性(控制内容子目录))
                navigator.serviceWorker.register('/sw1/serviceWorker1.js', { scope: './sw1' })
                .then(function (reg) {
                    console.log('success', reg);
                    //发送信息
                    navigator.serviceWorker.controller.postMessage("this message is from page");//如果使用的 scope 不是 Origin,会为null，此时可使用下面的方法
                    reg.active.postMessage("this message is from page, to sw");//reg.active 就是被注册后激活 Serivce Worker 实例,由于 Service Worker 的激活是异步的，因此第一次注册 Service Worker 的时候，Service Worker 不会被立刻激活，reg.active 为 null，需要用到Promise，参考下方sw2

                    //MessageChannel指定端口，双向通信
                    const messageChannel = new MessageChannel();
                    messageChannel.port1.onmessage = e => {
                        console.log(e.data);
                    }
                    reg.active.postMessage("this message is from page, to sw", [messageChannel.por2]);
                })
                .catch(function (err) {
                    console.log('fail', err);
                });
                //可注册多个serviceWorker，只需scope不同
                navigator.serviceWorker.register('/sw2/serviceWorker2.js', { scope: './sw2' })
                .then(function (reg) {
                    //reg.active 为 null的Promise参考此处
                    return new Promise((resolve, reject) => {
                        const interval = setInterval(function () {
                            if (reg.active) {
                                clearInterval(interval);
                                resolve(reg.active);
                            }
                        }, 100)
                    })
                })
                .then(sw => {
                    sw.postMessage("this message is from page, to sw2");
                })
                .catch(function (err) {
                    console.log('fail', err);
                });

                //接收信息
                navigator.serviceWorker.addEventListener('message', function (e){
                    console.log(e.data);
                });
            }
            ```

            serviceWorker.js(可在chrome-调试-application中调试)
            ```js
            //接收信息
            this.addEventListener('message', function (event) {
                console.log(event.data);
                //向消息的来源页面发送信息
                event.source.postMessage('this message is from sw.js, to page');
                //MessageChannel指定端口，双向通信
                event.ports[0].onmessage = e => {
                    console.log('sw:', e.data); // sw: this message is from sw2.js
                }
                event.ports[0].postMessage('this message is from sw.js');
            });
            //获取其他的页面，并发送消息
            this.clients.matchAll().then(client => {
                client[0].postMessage('this message is from sw.js, to page');
            })

            //缓存指定静态资源
            this.addEventListener('install', function (event) {
                console.log('Service Worker install');
                //缓存是异步行为event.waitUntil保证资源被缓存完成前 Service Worker 不会被安装完成，避免发生错误
                event.waitUntil(
                    //CacheStroage 在浏览器中的接口名是 caches
                    //caches.open 方法新建或打开一个已存在的缓存
                    caches.open('sw_demo').then(function (cache) {
                        //cache.addAll请求指定链接的资源并把它们存储到之前打开的缓存中
                        return cache.addAll([
                            '/style.css',
                            '/panda.jpg',
                            './main.js'
                        ])
                    }
                ));
            });

            //动态缓存静态资源
            //监听 fetch 事件，每当用户向服务器发起请求的时候这个事件就会被触发
            //页面的路径不能大于 Service Worker 的 scope，不然 fetch 事件是无法被触发的
            this.addEventListener('fetch', function (event) {
                console.log(event.request.url);
                //respondWith可以劫持用户发出的 http 请求，并把一个 Promise 作为响应结果返回给用户
                event.respondWith(
                    //使用用户的请求对 Cache Stroage 进行匹配
                    caches.match(event.request).then(res => {
                    return res ||//匹配失败，则向服务器请求资源res返回给用户
                        fetch(event.request)
                        .then(responese => {
                            //匹配成功，则返回存储在缓存中的资源
                            const responeseClone = responese.clone();
                            caches.open('sw_demo').then(cache => {
                                //cache.put 把新的资源存储在缓存中
                                cache.put(event.request, responeseClone);
                            })
                            return responese;
                        })
                        .catch(err => {
                            console.log(err);
                        });
                    })
                )
                //注意：
                //1. 第一次访问页面，资源的请求早于 Service Worker 的安装，所以静态资源是无法缓存的；只有当 Service Worker 安装完毕，第二次访问页面的时候，这些资源才会被缓存起来
                //2. Cache Stroage 只能缓存静态资源，所以它只能缓存用户的 GET 请求
                //3. Cache Stroage 中的缓存不会过期，但是浏览器对它的大小是有限制的，所以需要定期进行清理
                
                //POST请求也可以在拦截后，通过判断请求中携带的 body 的内容来进行有选择的返回
                if(event.request.method === 'POST') {
                    event.respondWith(
                        new Promise(resolve => {
                            event.request.json().then(body => {
                                console.log(body); // 用户请求携带的内容
                            })
                            resolve(new Response({ a: 2 })); // 返回的响应
                        })
                    )}
                }
                //对于静态资源的缓存，Cache Stroage 是个不错的选择；而对于数据，我们可以使用 IndexedDB 来存储，同样是拦截用户请求后，使用缓存在 IndexDB 中的数据作为响应返回
            });

            //更新 Cache Stroage
            //当有新的 service worker 文件存在的时候，他会被注册和安装，等待使用旧版本的页面全部被关闭后，才会被激活。这时候，我们就需要清理下我们的 Cache Stroage 了，删除旧版本的 Cache Stroage 。
            this.addEventListener('install', function (event) {
                console.log('install');
                event.waitUntil(
                    caches.open('sw_demo_v2').then(function (cache) { // 更换 Cache Stroage
                        return cache.addAll([
                            '/style.css',
                            '/panda.jpg',
                            './main.js'
                        ])
                    }
                ))
            });
            const cacheNames = ['sw_demo_v2']; // Cahce Stroage 白名单
            this.addEventListener('activate', function (event) {
                event.waitUntil(
                    caches.keys().then(keys => {
                        return Promise.all[keys.map(key => {
                            if (!cacheNames.includes(key)) {
                                console.log(key);
                                return caches.delete(key); // 删除不在白名单中的 Cache Stroage
                            }
                        })]
                    })
                )
            });
            //首先在安装 Service Worker 的时候，要换一个 Cache Stroage 来存储，然后设置一个白名单，当 Service Worker 被激活的时候，将不在白名单中的 Cache Stroage 删除，释放存储空间。同样使用 event.waitUntil ，在 Service Worker 被激活前执行完删除操作。
            ```

### js设计模式

1. 参考链接：

    * [Java设计模式：23种设计模式全面解析（超级详细）](http://c.biancheng.net/design_pattern/)
    * [JS设计模式](https://www.cnblogs.com/panrui1994/p/9402831.html)
    * [23种JavaScript设计模式](https://www.cnblogs.com/qiu-freedom/p/9135129.html)
    * [js继承的6种方式](https://www.cnblogs.com/ranyonsue/p/11201730.html)

2. 详解：

    * 继承的实现

        1. 原型链

            ```js
            a.prototype = new A()
            ```

            缺点：无法向父构造函数传参，共享父类属性

        2. 借用构造函数
        
            ```js
            function a(){
                A.call(this,参数)
            }
            ```
            缺点：只继承构造函数属性，没继承构造父类原型属性，没法复用，新实例都调用父构造函数。

        3. 最佳：寄生组合继承

            ```js
            function inheritPrototype(sub,sup) {
                var pro = new Object(sup.prototype);
                pro.constructor = sub;
                sub.prototype = pro;
            }
            function A(arg) {
                this.arg = arg;
                this.arg2 = [1,2,3];
            }
            function a(x1,x2) {
                A.call(this,x1);
                this.x2 = x2;
            }
            a.prototype = new A();
            inheritPrototype(a,A);
            ```

        4. 更多组合参考文章[js继承的6种方式](https://www.cnblogs.com/ranyonsue/p/11201730.html)

    * 设计模式总览
        1. 创建型模式
            * 抽象工厂模式
            * 生成器模式
            * 工厂方法模式
            * 单例模式
            * 原型模式
        2. 结构型模式
            * 适配器模式
            * 桥接模式
            * 组合模式
            * 装饰者模式
            * 外观模式
            * 享元模式
            * 代理模式
        3. 行为型模式
            * 责任链模式
            * 命令模式
            * 解释器模式
            * 迭代器模式
            * 中介者模式
            * 备忘录模式
            * 观察者模式
            * 状态模式
            * 策略模式
            * 模板方法模式
            * 访问者模式

    * 抽象工厂模式(接口)

        不需要建具体类，就可以对一堆类建模
        ```js
        class IHeroFactory {
            createAbilities() {}
            createEquipment() {}
            createSkills() {}
        }

        class SwordsmanFactory extends IHeroFactory {
            createAbilities() {
                return new SwordsmanAbility();
            }
            createEquipment() {
                return new SwordsmanEquipment();
            }
            createSkills() {
                return new SwordsmanSkill();
            }
        }
        //es5
        //function SwordsmanFactory(){}
        //SwordsmanFactory.prototype = new IHeroFactory();
        //SwordsmanFactory.prototype.createAbilities = function(){return new SwordsmanAbility();}
        ```

    * 生成器模式(构造函数)

        用于创建由其他对象组合构成的对象的模式，生成器知道所有的细节，且创建细节完全对其他相关类屏蔽。
        ```js
        class Person{
            constructor(name,age,job){
                this.name = name;
                this.age = age;
                this.job = "job:" + job;
                this.speak = function(){
                    console.log(this.name);
                };
            }
        }
        function Person(name,age,job){
            this.name = name;
            this.age = age;
            this.job = "job:" + job;
            this.speak = function(){
                console.log(this.name);
            };
        }
        var person1 = new Person("Alice", 23, "a");
        var person2 = new Person("Bruce", 22, "b");
        ```

    * 工厂模式

        把相同代码放到一个函数中，每次使用相同的功能或类，不需要重新编写代码
        ```js
        function createPerson(name, age) {
            var obj = {};
            obj.name = name;
            obj.age = age;
            obj.say = function () {
                console.log('hello' + this.name);
            }
            return obj;
        }
        var p1 = createPerson('aaa' , 26);
        p1.say();
        ```

    * 单例模式

        避免实例化多个对象
        ```js
        class People {
            constructor(name) {
                if (typeof People.instance === 'object') {
                    return People.instance;
                }
                People.instance = this;
                this.name = name;
                return this;
            }
        }
        var a = new People('a');//People {name: "a"}
        var b = new People('b');//People {name: "a"}
        console.log(a===b);//true
        //es5
        function People(name) {
            this.name = name;
        }

        People.getInstance = function(name) {
            if (!this.instance) {
                this.instance = new People(name);
            }
            return this.instance;
        }

        var a = People.getInstance('a');//People{name: "a"}
        var b = People.getInstance('b');//People{name: "a"}
        console.log(a===b);//true
        ```

    * 原型模式

        通过克隆或拷贝对象来生成对象,所有实例就共用了同一些方法或属性。
        ```js
        //写法1
        function Person(){
            Person.prototype.name = "aaa";
            Person.prototype.sayName = function(){
                alert(this.name);
            }
        };
        var person1 = new Person();
        person1.sayName();//"aaa"
        var person2 = new Person();
        person2.sayName();//"aaa"

        person1.name = "bbb";  
        alert(person1.name);//bbb
        alert(person2.name);//aaa来自原型
        delete person1.name;
        alert(person1.name);//aaa来自原型

        //写法2
        var Person = {
            name: 'aaa',
            sayName: function(){
                alert(this.name);
            }
        };
        var person1 = Object.create(Person);
        person1.sayName();//"aaa"
        var person2 = Object.create(Person);
        person2.sayName();//"aaa"

        person1.name = "bbb";  
        alert(person1.name);//bbb
        alert(person2.name);//aaa来自原型
        delete person1.name;
        alert(person1.name);//aaa来自原型
        ```

    * 适配器模式

        允许使用任何现有接口适配为目标接口
        ```js
        //方法适配
        var a = {
            say1: function(){
                console.log('a');
            }
        };
        var b = {
            say2: function(){
                console.log('b');
            }
        };
        var bAdapter = {
            say1: function(){
                return a.say1();
            }
        };
        var c = function(letter){
            if (letter.say1 instanceof Function){
                letter.say1();
            }
        };
        c(a);
        c(bAdapter);

        //数据适配
        let arr = ['a', 'b', 'c', 'd']
        function arr2objAdapter(arr) {
            return {
                e: arr[0],
                f: arr[1],
                g: arr[2],
                h: arr[3]
            }
        }
        let adapterData = arr2objAdapter(arr)；
        ```

    * 桥接模式

        提取多个底层功能模块，将抽象部分与它的实现部分分离
        ```js
        class Speed {
            constructor(x, y) {
                this.x = x
                this.y = y
            }
            run() {
                console.log(`运动起来 ${this.x} + ${this.y}`)  
            }
        }

        class Color {
            constructor(cl) {
                this.color = cl
            }
            draw() {
                console.log(`绘制颜色 ${this.color}`)
            }
        }

        class Speak {
            constructor(wd) {
                this.word = wd
            }
            say() {
                console.log(`说话 ${this.word}`)
            }
        }

        class Ball {
            constructor(x, y, cl) {
                this.speed = new Speed(x, y)
                this.color = new Color(cl)
            }
            init() {
                this.speed.run()
                this.color.draw()
            }
        }

        class Man {
            constructor(x, y, wd) {
                this.speed = new Speed(x, y)
                this.speak = new Speak(wd)
            }
            init() {
                this.speed.run()
                this.speak.say()
            }
        }

        const man = new Man(1, 2, 'hehe?')
        man.init()  
        ```

    * 组合模式

        用小的子对象来构建更大的对象，以表示“部分-整体”的层次结构
        ```js
        //DOM树的整体与节点对象的部分，jquery的addClass是个例子
        var addClass = function (eles, className) {
            if (eles instanceof NodeList) {
                for (var i = 0, length = eles.length; i < length; i++) {
                    eles[i].nodeType === 1 && (eles[i].className += (' ' + className + ' '));
                }
            }
            else if (eles instanceof Node) {
                eles.nodeType === 1 && (eles.className += (' ' + className + ' '));
            }
            else {
                throw "eles is not a html node";
            }
        }
        addClass(document.getElementById("div3"), "test");
        addClass(document.querySelectorAll(".div"), "test");
        ```

    * 装饰模式

        不使用继承且在不改变对象现有结构的情况下添加附加功能
        ```js
        var decorator = function(input,fn){
            var button = document.getElementById('button1');
            if(typeof button.onclick === 'function'){
                var oldClickFn = button.onclick;
                button.onclick = function(){
                    oldClickFn();
                    fn();//不改变对象现有结构的情况下添加附加功能
                }
            }else{
                button.onclick = fn;
            }
        }
        ```

    * 外观模式 

        为子系统的接口提供更高层次的接口
        ```js
        //高层次接口解决浏览器兼容性问题
        function addEvent(dom, type, fn) {
            if (dom.addEventListener) {
                dom.addEventListener(type, fn, false);
            }
            else if (dom.attachEvent) {
                dom.attachEvent('on' + type, fn);
            }
            else {
                dom['on' + type] = fn;
            }
        }
        const myInput = document.getElementById('myinput')
        addEvent(myInput, 'click', function() {console.log('绑定 click 事件')})
        ```

    * 享元模式

        主要用于减少创建对象的数量，以减少内存占用和提高性能
        ```js
        const Model = function(gender,underwear){
            this.gender = gender
            this.underwear = underwear
        }
        Model.prototype.takephoto = function(){
            console.log(`${this.gender}穿着${this.underwear}`);
        }
        for(let i=1;i<51;i++){
            const maleModel = new Model('male',`第${i}款衣服`)
            maleModel.takephoto()
        }
        for(let i =1;i<51;i++){
            const female = new Model('female',`第${i}款衣服`)
            female.takephoto()
        }
        //↓享元模式：只new了2个对象
        const Model = function(gender){
            this.gender = gender
        }
        Model.prototype.takephoto = function(){
            console.log(`${this.gender}穿着${this.underwear}`)
        }
        const maleModel = new Model('male')
        const femaleModel = new Model('female')
        for(let i =1;i<51;i++){
            maleModel.underwear = `第${i}款衣服`
            maleModel.takephoto()
        }
        for(let i =1; i<51;i++){
            femaleModel.underwear = `第${i}款衣服`
            femaleModel.takephoto()
        }
        //↓享元模式改进：引入工厂模式，但缺少了可读性
        const Model = function (gender) {
            this.gender = gender
        }
        Model.prototype.takephoto = function () {
            console.log(`${this.gender}穿着${this.underwear}`)
        }
        const modelFactory = (function () {
            const modelGender = {}
            return {
                createModel: function (gender) {
                    if (modelGender[gender]) {
                        return modelGender[gender]
                    }
                    return modelGender[gender] = new Model(gender)
                }
            }
        }())
        const modelManager = (function () {
            const modelObj = {}
            return {
                add: function (gender, i) {
                    modelObj[i] = {
                        underwear: `第${i}款衣服`
                    }
                    return modelFactory.createModel(gender)
                },
                copy: function (model, i) {
                    model.underwear = modelObj[i].underwear
                }
            }
        }())
        for (let i = 1; i < 51; i++) {
            const maleModel = modelManager.add('male', i) 
            modelManager.copy(maleModel, i)
            maleModel.takephoto()
            console.log(maleModel,modelManager)
        }
        for (let i = 1; i < 51; i++) {
            const femaleModel = modelManager.add('female', i)
            modelManager.copy(femaleModel, i)
            femaleModel.takephoto()
            console.log(femaleModel,modelManager)
        }
        ```

    * 代理模式

        为一个对象找一个替代对象，以便对原对象进行访问限制
        ```js
        //虚拟代理是把一些开销很大的对象，延迟到真正需要它的时候才去创建执行
        // 图片懒加载
        var myImage = (function(){
            var imgNode = document.createElement('img')
            document.body.appendChild(imgNode)
            return {
                setSrc: function(src) {
                    imgNode.src = src
                }
            }
        })();
        var proxyImage = (function() {
            var img = new Image();
            img.onload = function() {
                myImage.setSrc(this.src)
            }
            return {
                setSrc: function(src) {
                    myImage.setSrc('blank.gif');//设置等待时的图片
                    img.src = src;//onload时才设置图片路径，实现懒加载
                }
            }
        })();
        proxyImage.setSrc('http://seopic.699pic.com/photo/40006/7735.jpg_wh1200.jpg')

        //缓存代理可以为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递进来参数跟之前一致，则可以直接返回前面存储的运算结果。
        const getFib = (number) => {
            if (number <= 2) {
                return 1;
            }
            else {
                return getFib(number - 1) + getFib(number - 2);
            }
        }
        const getCacheProxy = (fn, cache = new Map()) => {
            //
            return new Proxy(fn, {
                apply(target, context, args) {
                    console.log(target, context, args)
                    //target为fn函数
                    //fn内没有属性，context为undefined
                    //args为传入的参数
                    const argsString = args.join(' ');
                    if (cache.has(argsString)) {
                        // 如果有缓存,直接返回缓存数据
                        return cache.get(argsString);
                    }
                    const result = fn(...args);
                    cache.set(argsString, result);

                    return result;
                }
            })
        }
        const getFibProxy = getCacheProxy(getFib);
        getFibProxy(40);
        ```

        附Proxy使用方法：
        * Proxy(代理对象，对象(属性为自定义代理函数))
        * 代理函数：(target为要代理的对象,propKey为对象属性值,value为值,receiver为Proxy或继承Proxy的对象)
            * get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
            * set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
            * has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
            * deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
            * ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
            * getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
            * defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
            * preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
            * getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
            * isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
            * setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
            * apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
            * construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
        * 样例
            ```js
            var obj = new Proxy({}, {
                get: function (target, propKey, receiver) {
                    console.log(`getting ${propKey}!`);
                    //让Object操作都变成函数行为
                    //Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法。
                    return Reflect.get(target, propKey, receiver);
                },
                set: function (target, propKey, value, receiver) {
                    console.log(`setting ${propKey}!`);
                    return Reflect.set(target, propKey, value, receiver);
                }
            });
            obj.count = 1
            //  setting count!
            ++obj.count
            //  getting count!
            //  setting count!
            //  2
            ```

    * 责任链模式

        多个对象递进处理数据，处理完成则返回结果，不能处理则传递到下一层。可用于优化多重嵌套的if-else
        ```js
        var order = function(orderType, isPaid, stock) {
            if(orderType === 1) {
                if(isPaid) {
                    console.log("500元定金预购，得到100优惠券");
                }
                else {
                    if(stock > 0) {
                        console.log("普通购买，无优惠券");
                    }
                    else {
                        console.log("库存不足");
                    }
                }
            }
            else if(orderType === 2) {
                if(isPaid) {
                    console.log("200元定金预购，得到50优惠券");
                }
                else {
                    if(stock > 0) {
                        console.log("普通购买，无优惠券");
                    }
                    else {
                        console.log("库存不足");
                    }
                }
            }
            else {
                if(stock > 0) {
                    console.log("普通购买，无优惠券");
                }
                else {
                    console.log("库存不足");
                }
            }
        }
        order(1, true, 500);
        //↓责任链模式
        var order500 = function(orderType, isPaid, stock) {
            if(orderType === 1 && isPaid === true) {
                console.log("500元定金预购，得到100优惠券");
            }
            else {
                return "next";
            }
        };
        var order200 = function(orderType, isPaid, stock) {
            if(orderType === 2 && isPaid === true) {
                console.log("200元定金预购，得到50优惠券");
            }
            else {
                return "next";
            }
        };
        var orderNormal = function(orderType, isPaid, stock) {
            if(stock > 0) {
                console.log("普通购买，无优惠券");
            }
            else {
                console.log("库存不足");
            }
        };
        Function.prototype.after = function(fn) {
            var self = this;
            return function() {
                var result = self.apply(this, arguments);
                if(result === "next") {
                    return fn.apply(this, arguments);
                }
                return result;
            };
        }
        var order = order500.after(order200).after(orderNormal);
        order(1, true, 500);
        ```

    * 命令模式

        客户方需要向接收方发送一系列指令，此时希望用一种松耦合的方式来设计程序，使得指令列表形成一个队列，可以方便地实现指令记入日志、指令撤销重做以及接收方决定是否执行指令。
        ```js
        var up = {
            execute: function(){
                console.log('up');
            }
        };
        var down = {
            execute: function(){
                console.log('down');
            }
        };
        var left = {
            execute: function(){
                console.log('left');
            }
        };
        var right = {
            execute: function(){
                console.log('right');
            }
        };
        var command = function(){
            return {
                commandsList: [],
                add: function(command){
                    this.commandsList.push(command);
                },
                execute: function(){
                    let command;
                    while(command = this.commandsList.shift()){
                        command.execute();
                    }
                }
            }
        };
        var c = command();
        c.add(up);
        c.add(down);
        c.add(left);
        c.execute();
        ```

    * 解释器模式

        将数据的一种表示转换为另一种表示
        ```js
        function Context() {
            this.sum = 0;
            this.list = [];
            this.getSum = function() {
                return this.sum;
            }
            this.setSum = function(sum) {
                this.sum = sum;
            }
            this.add = function(eps) {
                this.list.push(eps);
            }
            this.getList = function() {
                return this.list;
            }
        }

        function PlusExpression() {
            this.interpret = function(context) {
                let sum = context.getSum();
                sum++;
                context.setSum(sum);
            }
        }

        function MinusExpression() {
            this.interpret = function(context) {
                let sum = context.getSum();
                sum--;
                context.setSum(sum);
            }
        }

        let context = new Context();
        context.setSum(20);
        context.add(new PlusExpression());
        context.add(new PlusExpression());
        context.add(new MinusExpression());
        let list = context.getList();
        for (let i = 0; i < list.length; i++)
        {
            let expression = list[i];
            expression.interpret(context);
        }
        console.log(context.getSum());
        ```

    * 迭代器模式

        提供统一的方式来循环遍历这些不同类型的集合(Array，ArrayList和HashTable)
        ```js
        class Iterator {
            constructor(container) {
                this.list = container.list;
                this.index = 0;
            }
            next() {
                if (this.hasNext()) {
                    return this.list[this.index++];
                }
                return null;
            }
            hasNext() {
                if (this.index >= this.list.length) {
                    return false;
                }
                return true;
            }
        }
        
        class Container {
            constructor(list) {
                this.list = list;
            }
            getIterator() {
                return new Iterator(this);
            }
        }
        
        let arr = [1, 2, 3, 4, 5, 6];
        let container = new Container(arr);
        let iterator = container.getIterator()
        while(iterator.hasNext()){
            console.log(iterator.next())
        }
        ```

    * 中介者模式

        通信由中介者完成，通信双方不需要了解对方的任何信息。
        ```js
        function A(mediator) {
            this.mediator = mediator;
        }
        A.prototype = {
            send: function(msg,receiver) {
                this.mediator.send(msg,'A',receiver);
            },
            receiveMsg: function(msg,sender) {
                console.log(sender+" say:"+msg)
            }
        }

        function B(mediator) {
            this.mediator = mediator;
        }
        B.prototype = {
            send: function(msg,receiver) {
                this.mediator.send(msg,'B',receiver);
            },
            receiveMsg: function(msg,sender) {
                console.log(sender+" say:"+msg)
            }
        }
        function Mediator() {
            this.A = new A(this);
            this.B = new B(this);
        }
        Mediator.prototype = {
            send: function(msg,sender,receiver) {
                try {
                    this[receiver].receiveMsg(msg,sender);
                }
                catch(err) {
                    console.log('receiver '+receiver+' is not exsit');
                    this[sender].receiveMsg('receiver '+ receiver +' is not exsit','mediator');
                }
            }
        }

        var _mediator = new Mediator();
        var _a = new A(_mediator);
        var _b = new B(_mediator);
        _a.send('hello i am A','B');
        _b.send('hello i am B','A');
        ```

    * 备忘录模式

        在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态
        ```js
        // 分页缓存伪代码
        var Page = function () {
            // 通过cache对象缓存数据
            var cache = {}
            return function (page, fn) {
                if (cache[page]) {
                    showPage(page, cache[page])
                }
                else {
                    $.post('/url', function (data) {
                        showPage(page, data)
                        cache[page] = data
                    })
                }
                fn && fn()
            }
        }
        ```

    * 观察者模式

        当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态
        ```js
        class PubSub {
            constructor() {
                this.handles = {};
            }

            // 订阅事件
            on(eventType, handle) {
                if (!this.handles.hasOwnProperty(eventType)) {
                    this.handles[eventType] = [];
                }
                if (typeof handle == 'function') {
                    this.handles[eventType].push(handle);
                }
                else {
                    throw new Error('缺少回调函数');
                }
                return this;
            }

            // 发布事件
            emit(eventType, ...args) {
                if (this.handles.hasOwnProperty(eventType)) {
                    this.handles[eventType].forEach((item, key, arr) => {
                        item.apply(null, args);
                    })
                }
                else {
                    throw new Error(`"${eventType}"事件未注册`);
                }
                return this;
            }

            // 删除事件
            off(eventType, handle) {
                if (!this.handles.hasOwnProperty(eventType)) {
                    throw new Error(`"${eventType}"事件未注册`);
                }
                else if (typeof handle != 'function') {
                    throw new Error('缺少回调函数');
                }
                else {
                    this.handles[eventType].forEach((item, key, arr) => {
                        if (item == handle) {
                            arr.splice(key, 1);
                        }
                    })
                }
                return this; // 实现链式操作
            }
        }

        let callback = function () {
            console.log('you are so nice');
        }

        let pubsub = new PubSub();
        pubsub.on('completed', (...args) => {
            console.log(args.join(' '));
        }).on('completed', callback);

        pubsub.emit('completed', '1', '2', '3');
        pubsub.off('completed', callback);
        pubsub.emit('completed', '4', '5');
        ```

    * 状态模式

        对象可以通过管理其状态从而使得应用程序作出相应的变化
        ```js
        class SuperMarry {
            constructor() {
                this._currentState = []
                this.states = {
                    jump() {console.log('跳跃!')},
                    move() {console.log('移动!')},
                    shoot() {console.log('射击!')},
                    squat() {console.log('蹲下!')}
                }
            }
            
            change(arr) {  // 更改当前动作
                this._currentState = arr
                return this
            }
            
            go() {
                console.log('触发动作')
                this._currentState.forEach(T => this.states[T] && this.states[T]())
                return this
            }
        }

        new SuperMarry()
            .change(['jump', 'shoot'])
            .go()                    // 触发动作  跳跃!  射击!
            .go()                    // 触发动作  跳跃!  射击!
            .change(['squat'])
            .go()                    // 触发动作  蹲下!
        ```

    * 策略模式

        将算法的使用和实现分离出来
        ```js
        var calculateBouns = function(salary,level) {
            if(level === 'A') {
                return salary * 4;
            }
            if(level === 'B') {
                return salary * 3;
            }
            if(level === 'C') {
                return salary * 2;
            }
        };
        console.log(calculateBouns(4000,'A')); // 16000
        console.log(calculateBouns(2500,'B')); // 7500
        //↓改为策略模式
        var obj = {
            "A": function(salary) {
                return salary * 4;
            },
            "B" : function(salary) {
                return salary * 3;
            },
            "C" : function(salary) {
                return salary * 2;
            } 
        };
        var calculateBouns =function(level,salary) {
            return obj[level](salary);
        };
        console.log(calculateBouns('A',10000)); // 40000
        ```

    * 模板方法模式

        抽取共同点作为抽象父类，再具体实现一系列子类
        ```js
        var Interview = function(){};
        Interview.prototype.writtenTest = function(){
            console.log("笔试");
        };
        Interview.prototype.technicalInterview = function(){
            console.log("技术面试");
        };
        Interview.prototype.leader = function(){
            console.log("leader面试");
        };
        Interview.prototype.waitNotice = function(){
            console.log("等待通知");
        };
        Interview.prototype.init = function(){
            this.writtenTest();
            this.technicalInterview();
            this.leader();
            this.waitNotice();
        };
        var AInterview = function(){};
        AInterview.prototype = new Interview();
        AInterview.prototype.writtenTest = function(){
            console.log("笔试a");
        }
        AInterview.prototype.technicalInterview = function(){
            console.log("技术面试a");
        }
        AInterview.prototype.leader = function(){
            console.log("leader面试a");
        }
        AInterview.prototype.waitNotice = function(){
            console.log("等待通知a");
        }
        var aInterview = new BaiDuInterview();
        AInterview.init();
        ```

    * 访问者模式

        在不改变该对象的前提下访问其结构中元素的新方法
        ```js
        var Visitor = (function() {
            return {
                splice: function(){
                    var args = Array.prototype.splice.call(arguments, 1)
                    return Array.prototype.splice.apply(arguments[0], args)
                },
                push: function(){
                    var len = arguments[0].length || 0
                    var args = this.splice(arguments, 1)
                    arguments[0].length = len + arguments.length - 1
                    return Array.prototype.push.apply(arguments[0], args)
                },
                pop: function(){
                    return Array.prototype.pop.apply(arguments[0])
                }
            }
        })()
        
        var a = new Object()
        console.log(a.length)
        Visitor.push(a, 1, 2, 3, 4)
        console.log(a.length)
        Visitor.push(a, 4, 5, 6)
        console.log(a.length)
        Visitor.pop(a)
        console.log(a)
        console.log(a.length)
        Visitor.splice(a, 2)
        console.log(a)
        ```

### 运算符优先级
1. 参考链接：

    * [('b' + 'a' + + 'a' + 'a').toLowerCase()输出banana的剖析](https://juejin.im/post/5d537c71e51d4561c94b0faa)

2. 详解：

    ```txt
    ('b' + 'a' + + 'a' + 'a').toLowerCase()
    =('b' + 'a' + (+ 'a') + 'a').toLowerCase()//正号优先级大于加号
    =('b' + 'a' + Number('a') + 'a').toLowerCase()//隐式转换
    =('ba' + NaN + 'a').toLowerCase()
    =('ba' + 'NaN' + 'a').toLowerCase()
    =('baNaNa').toLowerCase()
    ='banana'
    ```

### 作用域与变量

1. 参考链接

    * [8个问题看你是否真的懂 JS](https://juejin.im/post/5d2d146bf265da1b9163c5c9)
    * [七个简单但棘手的 JS 面试问题](https://segmentfault.com/a/1190000020722239)
    * [前端常见20道高频面试题深入解析](https://mp.weixin.qq.com/s/jx-4p32EA9cHkDzll3BoYQ)

2. 详解

    * 意外的全局变量
        ```js
        function foo() {
            let a = b = 0;//声明了全局变量b=0与局部变量a
            a++;
            return a;
        }

        foo();
        typeof a; // undefined
        typeof b; // number
        ```

    * 数组长度属性
        ```js
        const clothes = ['jacket', 't-shirt'];
        clothes.length = 0;//改变数组长度相当于删除项
        clothes[0]; // undefined
        clothes.length = 2;//改回来，数据也丢失了
        clothes[0]; // undefined
        ```

    * 自动插入分号
        ```js
        function arrayFromValue(item) {
            return//js不写分号也能自成一行
                [items];
        }

        arrayFromValue(10); //undefined
        ```

    * 事件循环机制
        ```js
        let i;
        for (i = 0; i < 3; i++) {
            //先执行完循环，再调用时钟宏任务
            const log = () => {
                console.log(i);
            }
            setTimeout(log, 100);
        }
        //3 3 3
        ```

    * 精度丢失
        ```js
        0.1 + 0.2 === 0.3//false 
        ```

    * js变量生命周期
        ```js
        a;// undefined 变量提升
        b;// ReferenceError 临时死区 const
        c;// ReferenceError 临时死区 let

        var a = 'value';
        const b = 3.14;
        let c = true;

        a;//'value'
        b;//3.14
        c;//true
        ```

        ```js
        var a = 10;
        function foo() {
            console.log(a); // undefined
            var a = 20; // 使上面的a变成局部作用域
        }
        foo();
        ```

        ```js
        var a = 10;
        function foo() {
            console.log(a); // ReferenceError
            let a = 20; // 使上面的a变成局部作用域
        }
        foo();
        ```

        ```js
        var a = 10;
        function foo() {
            console.log(a); // 全局作用域10
        }
        foo();
        ```

        ```js
        var a = 10;
        function foo() {
            console.log(a); // undefined
            var a = 20; // 使上面的a变成局部作用域
            console.log(a);//20
        }
        console.log(a);//10
        foo();
        ```

    * this的指向
        ```js
        var x = 10; // global scope
        var foo = {
            x: 90,
            getX: function() {
                return this.x;
            }
        };
        foo.getX(); // 90,函数里的this指向foo
        let xGetter = foo.getX;
        xGetter(); // 10,函数里的this指向window
        let getFooX = foo.getX.bind(foo);//使用call和apply同理
        getFooX(); // 90
        ```

    * 执行上下文

        代码被解析和执行时所在环境的抽象概念，类型分为全局和函数，创建过程：

        * 创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。

        * 创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。

        * 确定this的值，即 ResolveThisBinding

    * 执行栈

        具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。

        执行规则：

        * 首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。

        * 当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。

    * 作用域链

        从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。

    * 闭包

        闭包是指有权访问另一个函数作用域中的变量的函数

        作用：

        * 能够访问函数定义时所在的作用域(阻止其被回收)

        * 私有化变量(函数里声明变量)

        * 模拟块级作用域(for var let的问题)

        * 创建模块(函数中的函数)

        模块模式具有两个必备的条件：

        * 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)

        * 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

### virtualDOM_Diff

1. 参考链接：

    * [虚拟DOM](https://www.jianshu.com/p/580157c93c53)
    * [Diff算法](https://www.jianshu.com/p/cdb4ad82df20)

2. 详解
    * 产生虚拟DOM的原因：由原本事件驱动变为数据驱动，jquery频繁操作DOM可能会造成不必要的浪费
        ```js
        $('li').on('click', function () {
            $(this).show().siblings().hide();
        });
        var li = $('li');
        //优化
        li.on('click', function () {
            li.hide();
            $(this).show();
        });
        ```
    * diff三大策略:
        1. Tree Diff:层次遍历找出不同
        2. Component Diff:组件脏检查，看组件实例是否改变，没改变，继续步骤1，改变，到步骤3
        3. Element Diff:发现与真实DOM不同，当节点处于同一层级时，Diff提供三种DOM操作：删除、移动、插入。(removeChild/removeChildren/createElement/insertBefore/setTextContent/appendChild/replaceChild(new,old))

    * diff示例
        1. 先标记新老DOM元素如下
            ```txt
                   oldS        oldE
            old:    a   b   c   d
            new:    a   f   d   e   c
                   newS            newE
            ```
        2. 比较oldS和newS发现一样，oldS++，newS++，发现b和f不一致，在oldS前插入f，oldS++，newS++
            ```txt
                           oldS    oldE
            old:    a   f   b   c   d
            new:    a   f   d   e   c
                           newS    newE
            ```
        3. 此时oldE和newS相同，oldE移动到oldS前，oldS++,newS++
            ```txt
                              oldS oldE
            old:    a   f   d   b   c
            new:    a   f   d   e   c
                              newS newE
            ```
        4. newE与oldE相同,oldE--,newE--,此时新老都不同，oldS前插入newE，删除oldS，oldS++，newS++，newE--，oldE--
            ```txt
                              oldE oldS
            old:    a   f   d   e   c
            new:    a   f   d   e   c
                              newE newS
            ```
        5. oldS > oldE，Diff结束

### 实现instanceof
1. 参考链接

    * [js实现instanceof](https://www.cnblogs.com/wjgoblin/p/11317978.html)

2. 详解

    instanceof 是通过原型链判断的，A instanceof B, 在A的原型链中层层查找，是否有原型等于B.prototype，如果一直找到A的原型链的顶端null,仍然不等于B.prototype，那么返回false，否则返回true.

    ```js
    function instance(left,right){
        left=left.__proto__
        right=right.prototype
        while(true){
            if(left==null)
                return false;
            if(left===right)
                return true;
            left=left.__proto__;
        }
    }
    ```


### 抽象语法树AST与babel

1. 参考链接：

    * [一看就懂的JS抽象语法树](https://segmentfault.com/a/1190000012943992)
    * [中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)](https://juejin.im/post/5c64d15d6fb9a049d37f9c20)

2. 详解

    抽象语法树：将代码逐字母解析成树状对象的形式，是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础

    * 样例
        ```js
        var a = 1;
        var b = a + 1;
        {
            "type": "Program",
            "body": [
                {
                    "type": "VariableDeclaration",
                    "declarations": [
                        {
                            "type": "VariableDeclarator",
                            "id": {
                                "type": "Identifier",
                                "name": "a"
                            },
                            "init": {
                                "type": "Literal",
                                "value": 1,
                                "raw": "1"
                            }
                        }
                    ],
                    "kind": "var"
                },
                {
                    "type": "VariableDeclaration",
                    "declarations": [
                        {
                            "type": "VariableDeclarator",
                            "id": {
                                "type": "Identifier",
                                "name": "b"
                            },
                            "init": {
                                "type": "BinaryExpression",
                                "operator": "+",
                                "left": {
                                    "type": "Identifier",
                                    "name": "a"
                                },
                                "right": {
                                    "type": "Literal",
                                    "value": 1,
                                    "raw": "1"
                                }
                            }
                        }
                    ],
                    "kind": "var"
                }
            ],
            "sourceType": "script"
        }
        ```

        * 常用引擎
            * esprima
            * acron
            * Traceur
            * UglifyJS2
            * shift

        * 使用示例
            ```js
            //npm i esprima estraverse escodegen --save
            const esprima = require('esprima');
            let code = 'const a = 1';
            const ast = esprima.parseScript(code);
            console.log(ast);
            //Script {
            //type: 'Program',
            //body:
            //[ VariableDeclaration {
            //    type: 'VariableDeclaration',
            //    declarations: [Array],
            //    kind: 'const' } ],
            //sourceType: 'script' }
            const estraverse = require('estraverse');
            estraverse.traverse(ast, {
                enter: function (node) {
                    node.kind = "var";
                }
            });
            console.log(ast);
            //Script {
            //type: 'Program',
            //body:
            //[ VariableDeclaration {
            //    type: 'VariableDeclaration',
            //    declarations: [Array],
            //    kind: 'var' } ],
            //sourceType: 'script' }
            const escodegen = require("escodegen");
            const transformCode = escodegen.generate(ast)
            console.log(transformCode);
            //var a = 1;//把const a = 1编译成这个
            ```

        * babel

            1. babylon 将 ES6/ES7 代码解析成 AST
            2. babel-traverse 对 AST 进行遍历转译，得到新的 AST
            3. 新 AST 通过 babel-generator 转换成 ES5



### 前端SEO与踩过的坑

1. 参考链接：

    * [前端开发需要注意的seo设置](https://jingyan.baidu.com/article/3f16e0034e66822590c10341.html)
    * [Web前端开发过程踩过的坑以及一些小方法技巧](https://segmentfault.com/a/1190000018163184)

2. 详解

    * 可优化的地方

        1. 图片加alt标签，除了在图片加载不出来能显示文字，还能有机会使搜索引擎索引到网站
        2. 避免使用iframe，搜索引擎不会抓取到iframe里的内容，还要处理iframe滚动条问题
        3. 设置title可使鼠标悬停时出现提示文字
        4. 如果hover不触发动作，只改变样式，一般写在css里，如控制显示和隐藏，合理利用+(第一个兄弟元素)、~(后面所有兄弟元素)会有更好的效果
        5. cdn与负载均衡
        6. 404、500等页面自定义
        7. 事件委托，通常用于ul-li，事件绑定在父元素，通过判断event.target.nodeName再执行动作，优于每个子元素都绑定事件，因为增删子元素会影响事件绑定
        8. 图片懒加载
        9. font-spider按需打包字体
        10. gulp/webpack打包压缩
        11. 合理利用localstorage，避免重复请求
        12. service worker执行高耗时任务
        13. 带动画的下拉标签和提交按钮防抖，参考章节[节流和防抖](#节流和防抖)
        14. form添加随机串配合session防csrf
        15. 父元素overflow:hidden清除浮动

    * 兼容性问题

        1. IE/safari解析日期格式，2020-1-3无效，但2020/1/3 2020-01-03有效
        2. IE不兼容flex
        3. ios移动端视频播放总是全屏，试试playsinline
        4. iOS浏览器在设置overflow: scroll;后滑动不流畅，试试-webkit-overflow-scrolling: touch;
        5. document.documentElement与document.body各浏览器获取有差异，赋值使用：var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;

    * 踩过的坑

        1. 高度百分比对响应式轮播无效，要使用border-box和padding-bottom
        2. 行内元素(如img，canvas)下方有白边，要加display:block消除
        3. position:relative可以调节子元素全部位于父元素内，但如果所有子元素相加的高度大于父元素高度，会使父元素变高，固定父元素高度和溢出隐藏无效
        4. 视频不能autoplay，试试muted
        5. 移动端视频一般使用默认controls，因为适配起来太麻烦了
        6. 元素在设置为display:inline-block;后元素之间会产生间距，试试父元素添加font-size: 0;
        7. vue在beforeRouteEnter获取不到this，
            ```js
            beforeRouteEnter(to, from, next){ 
                next((vm)=>{
                    console.log(vm);
                    if(from.path == '/'){
                        vm.isShowAppr = false;
                    }
                });
            },
            ```
        8. vue中this.$route与this.$router的区别:route与url相关，router与跳转相关
        9. angular修改数据后页面没变化，试试ChangeDetectorRef中的detectChanges方法
        10. date.getMonth()是从0开始的
        11. 移动端字体最小12px,再小只能通过scale
        12. table的td悬停设置border出现抖动问题，试试td和tr定高，如果不定高试试outline，如果浏览器不兼容，只能改为div
        13. 文本溢出显示省略号：
            ```css
            单行
            p{
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            多行(webkit)
            p{
                dispaly: -webkit-box;
                -webkit-box-orient: vertical;
                text-overflow: ellipsis;
                -webkit-line-clamp: 2; //显示几行
                overflow: hidden;
            }
            多行(兼容)
            p {
                position:relative;
                line-height:1.4em; //要显示三行的话那么元素的高度就是行高的3倍，其它情况以此类推。
                /* 3 times the line-height to show 3 lines */
                height:4.2em;
                overflow:hidden;
            }
            p::after {
                content:"...";
                font-weight:bold;
                position:absolute;
                bottom:0;
                right:0;
                padding:0 20px 1px 45px;
            }
            ```
        14. 子元素绝对定位跟随父元素overflow：scroll滚动问题:出现这样的问题就是因为父元素设置了position: relative;, 父元素相对定位会导致,滚动条在滚动的同时,将父元素的位置也移动了。解决办法：固定区与滚动区分离，滚动区用div包裹。

    * 常用文档网站

        1. w3cschool
        2. caniuse
        3. mdn

### websocket

1. 参考链接：

    * [WebSocket 教程](http://www.ruanyifeng.com/blog/2017/05/websocket.html)
    * [WebSocket](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)

2. 详解

    * 概念

        HTTP协议通信只能由客户端发起，做不到服务器主动向客户端推送信息，而轮询的效率低，浪费资源，因为必须不停连接，或者 HTTP 连接始终打开，所以产生websocket，使客户端和服务器能平等对话。

    * 特点

        1. 建立在tcp协议上
        2. 兼容http协议，默认端口80和443
        3. 可发送文本和二进制数据
        4. 没同源限制，标识符是ws，加密则为wss
        5. 各浏览器基本支持

    * js使用方法

        ```js
        var ws = new WebSocket("wss://echo.websocket.org");

        switch (ws.readyState) {
            case WebSocket.CONNECTING:
                // 值为0，表示正在连接
                break;
            case WebSocket.OPEN:
                // 值为1，表示连接成功，可以通信了
                break;
            case WebSocket.CLOSING:
                // 值为2，表示连接正在关闭
                break;
            case WebSocket.CLOSED:
                // 值为3，表示连接已经关闭，或者打开连接失败
                break;
            default:
                // this never happens
                break;
        }

        //连接成功后的回调函数
        ws.onopen = function(event) {
            console.log("Connection open ...");
            ws.send("Hello WebSockets!");//向服务器发送数据
            //发送blob
            var file = document.querySelector('input[type="file"]').files[0];
            ws.send(file);
            //发送binary
            var img = canvas_context.getImageData(0, 0, 400, 320);
            var binary = new Uint8Array(img.data.length);
            for (var i = 0; i < img.data.length; i++) {
                binary[i] = img.data[i];
            }
            ws.send(binary.buffer);

            //webSocket.bufferedAmount未发送至服务器的字节数
            var data = new ArrayBuffer(10000000);
            socket.send(data);
            if (socket.bufferedAmount === 0) {
                // 发送完毕
            } else {
                // 发送还没结束
            }
        };
        //同上
        ws.addEventListener('open', function (event) {
            ws.send('Hello Server!');
        });

        //从服务器接受到信息时的回调函数
        ws.onmessage = function(event) {
            console.log( "Received Message: " + event.data);
            //判断收到的文本类型
            if(typeof event.data === String) {
                console.log("Received data string");
            }
            if(event.data instanceof ArrayBuffer){
                var buffer = event.data;
                console.log("Received arraybuffer");
            }
            ws.close();//关闭当前链接
        };

        ws.onerror = function(event) {
            // handle error event
        };

        //连接关闭后的回调函数
        ws.onclose = function(event) {
            console.log("Connection closed.");
            var code = event.code;
            var reason = event.reason;
            var wasClean = event.wasClean;
        }
        ```

    * nodejs使用方法

        ```js
        var express = require('express');
        var app = express();
        var http = require('http').Server(app);
        var io = require('socket.io')(http);

        io.on('connection', function (socket) {
            socket.on('disconnect', function () {
                //监听用户退出
            });
            socket.on('message', function (clientMessage) {
                //监听用户发布聊天内容
            });
            socket.on('join', function (userName) {
                //用户加入房间
            });
            socket.on('disconnect', function () {
                //用户离开房间
            });
        });
        ```

### 变量的解构赋值

1. 参考链接：

    * [变量的解构赋值](http://es6.ruanyifeng.com/#docs/destructuring)

2. 详解

    ES6 允许等号双方按照相同格式，从数组和对象中提取值，对变量进行赋值，这被称为解构

    ```js
    //数组
    let [a, b, c] = [1, 2, 3];
    a;//1
    let [foo, [[bar], baz]] = [1, [[2], 3]];
    baz;//3
    let [ , , third] = ["foo", "bar", "baz"];
    third;//"baz"
    let [x, y, ...z] = ['a'];
    x;//"a"
    y;//undefined 解构不成功为undefined
    z;//[]
    let [foo] = 1;//报错
    let [x, y, z] = new Set(['a', 'b', 'c']);
    x;//"a"
    let [foo = true] = [];
    foo;//true 因为使用了默认值
    let [x = 1] = [undefined];
    x；//1
    let [x = 1] = [null];
    x；//null 对null不生效

    //对象
    let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
    foo；//"aaa"
    let x;
    {x} = {x: 1};// SyntaxError: syntax error
    let x;
    ({x} = {x: 1});
    x;//1

    //字符串
    const [a, b, c, d, e] = 'hello';
    a；//"h"
    let {length : len} = 'hello';
    len；//5

    //数值和布尔值
    let {toString: s} = 123;
    s === Number.prototype.toString;//true
    let {toString: s} = true;
    s === Boolean.prototype.toString;//true
    let { prop: x } = undefined;//TypeError 右边无法转换为对象
    let { prop: y } = null;//TypeError 右边无法转换为对象

    //函数参数
    function add([x = 0, y = 1]){
        return x + y;
    }
    add([1, 2]);//3

    //圆括号报错
    let [(a)] = [1];//error
    let {x: (c)} = {};//error
    let ({x: c}) = {};//error
    let {(x: c)} = {};//error
    let {(x): c} = {};//error
    let { o: ({ p: p }) } = { o: { p: 2 } };//error
    function f([(z)]) { return z; }//error
    function f([z,(x)]) { return x; }//error
    ({ p: a }) = { p: 42 };//error
    ([a]) = [5];//error
    [({ p: a }), { x: c }] = [{}, {}];//error

    //圆括号正确
    [(b)] = [3];
    b;//3
    ({ p: (d) } = {});
    d;//undefined
    [(parseInt.prop)] = [3];
    parseInt.prop;//3

    //用途
    //（1）交换变量的值
    let x = 1;
    let y = 2;
    [x, y] = [y, x];
    //（2）从函数返回多个值
    function example() {
        return [1, 2, 3];
    }
    let [a, b, c] = example();
    //（3）函数参数的定义和默认值
    function f({x=0, y=0, z=0}) { ... }
    f({z: 3, y: 2, x: 1});//可无序
    //（4）提取 JSON 数据
    let jsonData = {
        id: 42,
        status: "OK",
        data: [867, 5309]
    };
    let { id, status, data: number } = jsonData;
    //（5）遍历 特殊 结构
    const map = new Map();
    map.set('first', 'hello');
    map.set('second', 'world');
    for (let [key, value] of map) {
        console.log(key + " is " + value);
    }
    //（6）输入模块的指定方法
    const { SourceMapConsumer, SourceNode } = require("source-map");
    ```


### 文件内容读取

1. 参考链接：

    * [使用JS读取本地文本文件](https://www.cnblogs.com/yaotome/p/9002172.html)
    * [JS前端new FileReader获取文件后显示乱码](https://www.jianshu.com/p/a8e57e51520a)
    * [UTF8 GB2312之间的区别和关系](http://www.divcss5.com/html/h53.shtml)

2. 详解

    需要在input手动选择文件，GB2312编码支持简体中文字，UTF-8支持简体中文字、繁体中文字、英文、日文、韩文等语言，如出现中文乱码，可切换编码。
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Document</title>
        <script type="text/javascript">
            function upload(input) {  
                //支持chrome IE10  
                if (window.FileReader) {  
                    var file = input.files[0];  
                    filename = file.name.split(".")[0];  
                    var reader = new FileReader();  
                    reader.onload = function() {  
                        console.log(this.result,this);  
                    }  
                    reader.readAsText(file,"gb2312");  
                }   
                //支持IE 7 8 9 10  
                else if (typeof window.ActiveXObject != 'undefined'){  
                    var xmlDoc;   
                    xmlDoc = new ActiveXObject("Microsoft.XMLDOM");   
                    xmlDoc.async = false;   
                    xmlDoc.load(input.value);   
                    console.log(xmlDoc.xml);   
                }   
                //支持FF  
                else if (document.implementation && document.implementation.createDocument) {   
                    var xmlDoc;   
                    xmlDoc = document.implementation.createDocument("", "", null);   
                    xmlDoc.async = false;   
                    xmlDoc.load(input.value);   
                    console.log(xmlDoc.xml);  
                } else {   
                    alert('error');   
                }   
            }  
        </script>
    </head>
    <body>
    <input type="file" onchange="upload(this)" />  
    </body>
    </html>
    ```

### js异步加载

1. 参考链接：

    * [前端常见20道高频面试题深入解析](https://mp.weixin.qq.com/s/jx-4p32EA9cHkDzll3BoYQ)

2. 详解

    \<script> 标签中增加 async(html5) 或者 defer(html4) 属性,脚本就会异步加载。

    \<script src="../XXX.js"defer></script>

    动态创建 script 标签,并且添加到文档中，JS文件才会开始下载。

    defer 和 async 的区别在于：

    * defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），在window.onload 之前执行；

    * async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。

    * 如果有多个 defer 脚本，会按照它们在页面出现的顺序加载

    * 多个 async 脚本不能保证加载顺序


### #promise.all实现
1. 参考链接：

    * [前端常见20道高频面试题深入解析](https://mp.weixin.qq.com/s/jx-4p32EA9cHkDzll3BoYQ)

    * [实现Promise.all、Promise.race、Promise.finally](https://blog.csdn.net/zl13015214442/article/details/96744447)

2. 详解

    * promise.all
        * 功能

            * Promise.all(iterable) 返回新Promise
            * iterable中存在参数不为promise，视此参数resolve
            * 所有promise都resolve，返回resolve
            * 存在promise reject，返回第一个reject

        * 特点

            * 如果传入的参数为空的可迭代对象， Promise.all 会 同步 返回一个已完成状态的 promise
            * 如果传入的参数中不包含任何 promise, Promise.all 会 异步 返回一个已完成状态的 promise
            * 其它情况下， Promise.all 返回一个 处理中（pending） 状态的 promise

        * 状态

            * 如果传入的参数中的 promise 都变成完成状态， Promise.all 返回的 promise 异步变为完成
            * 如果传入的参数中，有一个 promise 失败， Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成
            * 在任何情况下， Promise.all 返回的 promise 的完成状态的结果都是一个数组

        * 实现

            ```js
            Promise.all = function(promises) {
                //省略参数合法性检查
                return new Promise((resolve,reject) => {
                    promises = Array.from(promises);
                    if(promises.length === 0){
                        resolve([]);
                    }
                    else{
                        let result = [];
                        let index = 0;
                        for(let i = 0;i < promises.length;i++){
                            Promise.resolve(promises[i]).then(
                                data => {
                                    result[i] = data;
                                    if(++index === promises.length){
                                        resolve(result);
                                    }
                                },
                                err => {
                                    reject(err);
                                    return;
                                }
                            );
                        }
                    }
                });
            }
            var p = Promise.all([1,2,3]);
            // Promise {<resolved>: Array(3)}
            // __proto__: Promise
            // [[PromiseStatus]]: "resolved"
            // [[PromiseValue]]: Array(3)
            // 0: 1
            // 1: 2
            // 2: 3
            // length: 3
            // __proto__: Array(0)
            var p2 = Promise.all([1,2,3, Promise.resolve(444)]);
            // Promise {<resolved>: Array(4)}
            // __proto__: Promise
            // [[PromiseStatus]]: "resolved"
            // [[PromiseValue]]: Array(4)
            var p3 = Promise.all([1,2,3, Promise.reject(555)]);
            // Promise {<rejected>: 555}
            // __proto__: Promise
            // [[PromiseStatus]]: "rejected"
            // [[PromiseValue]]: 555
            ```

    * promise.race

        * 功能

            Promise.race返回的仍然是一个Promise，它的状态与第一个完成的Promise的状态相同；如果传入的参数是不可迭代的，那么将会抛出错误。

        * 实现
        ```js
        Promise.ra_ce = function(promises) {
            promises = Array.from(promises);
            return new Promise((resolve, reject) => {
                if(promises.length===0) {
                    return;
                } else {
                    for(let i=0; i<promises.length; i++) {
                        Promise.resolve(promises[i]).then(data => {
                            resolve(data);
                            return;
                        }, err => {
                            reject(err);
                            return;
                        })
                    }
                }
            })
        }
        ```

        * 提示

            Promsie.all和Promise.race都只接受可迭代的数据结构，否则会报错，所以在不确定传入的promises是否为可迭代数据结构的情况下可以通过以下加以判断：
            ```js
            if(typeof promises[Symbol.iterator] !== 'function') {
                Promise.reject("args is not iteratable!");
            }
            ```
            一个数据结构只要具有 Symbol.iterator 属性(Symbol.iterator 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。

    * promise.finally

        * 功能

            不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then。

        * 实现

            ```js
            Promise.prototype.finally = function (callback) {
                return this.then((value) => {
                    return Promise.resolve(callback()).then(() => {
                        return value;
                    });
                }, (err) => {
                    return Promise.resolve(callback()).then(() => {
                        throw err;
                    });
                });
            }
            ```

### 便捷的函数与方法
1. 参考链接：

    * [前端常见20道高频面试题深入解析](https://mp.weixin.qq.com/s/jx-4p32EA9cHkDzll3BoYQ)
    * [Javascript实现嵌套数组扁平化](https://www.cnblogs.com/codejoker/p/10370262.html)

2. 详解

    * 嵌套数组扁平化

        es6 flat(扁平层数)
        ```js
        var testArr = [10, 2, [3, 4, [5, [55]]]]
        testArr.flat(Infinity)
        ```

        toString
        ```js
        var testArr = [10, 2, [3, 4, [5, [55]]]]
        [...testArr.toString().split(',')]
        ```

    * 数组去重

        set
        ```js
        var testArr = [1,2,2,3,4,4]
        [... new Set(testArr)]
        ```

### 可迭代对象
1. 参考链接：

    * [前端常见20道高频面试题深入解析](https://mp.weixin.qq.com/s/jx-4p32EA9cHkDzll3BoYQ)

2. 详解

    一个数据结构只要具有 Symbol.iterator 属性( Symbol.iterator 方法对应的是遍历器生成函数，返回的是一个遍历器对象)，那么就可以其认为是可迭代的。

    特点：

    * 具有 Symbol.iterator 属性， Symbol.iterator() 返回的是一个遍历器对象
    * 可以使用 for...of 进行循环
    * 通过被 Array.from 转换为数组

    数据结构：

    * Array
    * Map
    * Set
    * String
    * TypedArray
    * 函数的 arguments 对象
    * NodeList 对象


### url的含义

1. 参考链接

    百度百科

2. 详解

    http/https 连接协议

    .com/.cn/.net 一级域名

    .com.cn/baidu.com 二级域名

    baike.baidu.com 三级域名

    :8080 端口号

    /a/b/c 路由

    ?key=value&a=b 页面参数

    #tag 标签

### reflect

1. 参考链接

    [ES6之Reflect](https://www.jianshu.com/p/4a5eca0536c3)

    [ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs/reflect)

2. 详解

    * 描述

        Reflect是内置对象，而不是普通的function对象，因此不能使用new

    * 作用

        1. 同proxy，为操作对象而提供的新API，可以从Reflect对象上拿Object对象内部方法

        2. 老Object方法 报错的情况，改为返回false

            ```js
            try {
                Object.defineProperty(target, property, attributes);
                // success
            } catch (e) {
                // failure
            }
            //改为
            if (Reflect.defineProperty(target, property, attributes)) {
                // success
            } else {
                // failure
            }
            ```

        3. 让Object操作变成函数行为

            ```js
            'name' in Object //true
            delete obj.name;
            let person= new Person('chen')

            Reflect.has(Object,'name') //true
            Reflect.deleteProperty(obj, 'name');
            let person = Reflect.construct(Person, ['chen']);
            ```

        4. Reflect与Proxy是相辅相成的，在Proxy上有的方法，在Reflect就一定有

            ```js
            let target={}
                let handler={
                set(target,proName,proValue,receiver){
                    //确认对象的属性赋值成功
                    let isSuccess=Reflect.set(target,proName,proValue,receiver)
                    if(isSuccess){
                    console.log("成功")
                    }
                    return isSuccess
                }
            }
            let proxy=new Proxy(target,handler)
            ```

    * 使用

        ```js
        Reflect.apply(target, thisArg, args)
        Reflect.construct(target, args)
        Reflect.get(target, name, receiver)
        Reflect.set(target, name, value, receiver)
        Reflect.defineProperty(target, name, desc)
        Reflect.deleteProperty(target, name)
        Reflect.has(target, name)
        Reflect.ownKeys(target)
        Reflect.isExtensible(target)
        Reflect.preventExtensions(target)
        Reflect.getOwnPropertyDescriptor(target, name)
        Reflect.getPrototypeOf(target)
        Reflect.setPrototypeOf(target, prototype)
        ```

### 图片懒加载

1. 参考链接

    [js实现图片懒加载原理](https://blog.csdn.net/w1418899532/article/details/90515969)

    [图片懒加载原理及实现](https://www.jianshu.com/p/8e2a73638153)

2. 详解

    * 描述

        一个网页包含大量图片，并发加载会影响渲染速度和占用带宽，如果改为可视区域加载，则能优化性能。

    * 原理

        图片是否加载取决于img标签的src，先不给src赋值，等到进入可视区域再赋值，这时候才请求图片

    * 思路

        1. loading图片
        2. 判断可视区域：$img.offset().top <= $(window).height()+$(window).scrollTop() 元素距离顶部的距离<=可视区域高度+窗口滚动距离
        3. 替换图片

    * 实现

        ```html
        <div class="imgList">
            <img class="lazy" src="img/loading.gif" data-src="img/pic1" alt="pic" />
            <img class="lazy" src="img/loading.gif" data-src="img/pic2" alt="pic" />
            <img class="lazy" src="img/loading.gif" data-src="img/pic3" alt="pic" />
        </div>
        <script>
            $(()=>{
                let lazyload = () => {
                    for(let i = 0;i < $(".lazy").length;i++){
                        if($(".lazy").eq(i).offset().top <= $(window).height()+$(window).scrollTop()){
                            $(".lazy").eq(i).attr("src",$(".lazy").eq(i).data("src"));
                        }
                    }
                }
                lazyload();
                $(window).on("scroll",function(){lazyload();});
            })
        </script>
        ```

### jsonp

1. 参考链接

    [简单的jsonp实现promise](https://blog.csdn.net/weixin_34253126/article/details/92330465)

    [简单透彻理解JSONP原理及使用](https://blog.csdn.net/inite/article/details/80333130)

2. 详解

    * 描述

        jsonp是前端跨域手段，利用script可跨域性，请求异域js，带上回调函数名，异域服务器响应为 函数名(数据)，这样只要本地即可收到函数传入的数据。

    * 实现

        * ajax版

            ```js
            $.ajax({
                type : "get",
                async: false,
                url : "...",
                dataType: "jsonp",
                jsonp:"callback",
                jsonpCallback: "jsonhandle",//回调函数(参数值)
                success : function(data) {
                    
                }
            });
            ```

        * promise版

            ```js
            function p(url){
                let json;
                let script = '<script id="jsonp" src="'+url+?callback=fn+'"></script>';
                window.fn = function(data){
                    json = data;
                }
                //当script被插入文档中时，src中的资源就会开始加载
                $(body).append(script);
                
                return new Promise((resolve,reject)=>{
                    $("#jsonp").on("load",function(e){
                        resolve(json);
                    })
                    $("#jsonp").on("error",function(e){
                        reject(json);
                    })
                });
            }
            p('http://localhost:8082').then(data=>{
                console.log(data);
                throw('err before then');
            }).catch(err => {
                //可以捕捉到then里的err befor then也可以捕捉到new Promise里的err in promise。
                console.log(err)
            });
            ```

### ajax

1. 参考链接

    [Ajax工作原理及实现步骤](https://blog.csdn.net/qq_29055201/article/details/88798055)

    [总结 - Ajax工作原理和实现步骤](https://blog.csdn.net/weixin_37580235/article/details/81459282)

2. 详解

    * 描述

        ajax即为异步的js和xml，在用户和服务器之间加了一个中间层，用于组装信息发送http(s)请求和接收服务器响应

    * 实现

        ```js
        function ajax(url, data, method='POST', async=true) {
            return new Promise((resolve, reject) {
                // 第一步，创建xmlHttpRequest
                let xhr = new XMLHttpRequest()

                // 第二步，设置请求方式
                xhr.open(method, url, async)
                //设置需要返回的数据类型
                xhr.responseType = 'text';//json,blob,arrayBuffer

                // 第三步， 调用回调函数
                xhr.onreadyStateChange = function() {
                    //0初始化
                    //1请求已提出
                    //2请求已发送
                    //3请求处理中
                    //4请求已完成
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {//服务器状态码
                            resolve(xhr.responseText)//响应文本
                            //responseXML响应XML/DOM
                            //responseBody响应主题
                            //responseStream响应数据流
                        } else {
                            reject(xhr.statusText)//状态码对应文本
                        }
                    } else {
                        reject(xhr.statusText)
                    }
                }

                // 第四步， 发送请求
                xhr.send(data)
                //abort()停止当前请求
                //getAllResponseHeaders()所有响应请求头以键值形式返回
                //getResponseHeader("header")返回指定头部值
                //setRequestHeader("header","value")设置请求头一起发送
            })
        }
        ```

## 后端篇

### JSON_Web_Token

1. 参考链接：

    * [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)
    * [c#关于JWT跨域身份验证解决方案](https://www.cnblogs.com/dengbo/p/11672495.html)

2. 详解：

    * web api的用户用户角色验证中涉及用户身份识别的问题。
    
    * 以往后端保存数据到session后，把sessionID通过cookie传给前端，前端每次请求都通过cookie传回，后端在session找到前期保存的数据，校验相等，即可识别用户。这种方法的缺点是跨域服务session难共享(A和B网站关联服务,要求A登录后，到B处能自动登录)，如果采用数据库持久化，则较为麻烦。因此采用jwt的办法。

    * jwt的数据结构：“base64UrlEncode(Header).base64UrlEncode(Payload).Signature”

    * Header
        ```js
        {
            "alg": "HS256",//签名的算法,，默认是 HMAC SHA256（写成 HS256）
            "typ": "JWT"//令牌（token）的类型（type），JWT 令牌统一写为JWT
        }
        ```

    * Payload
        ```js
        {
            "iss": "(issuer)：签发人"
            "exp": "(expiration time)：过期时间"
            "sub": "(subject)：主题"
            "aud": "(audience)：受众"
            "nbf": "(Not Before)：生效时间"
            "iat": "(Issued At)：签发时间"
            "jti": "(JWT ID)：编号"
            //以上7个官方字段可供选用，下方可加自定义字段
            //因为jwt不加密，所以不能传递敏感信息
        }
        ```

    * Signature:需要先指定秘钥，写到网站配置
        ```txt
        HMACSHA256(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)
        base64UrlEncode是基于base64之上，把=忽略，把+替换为-，把/替换为_
        ```

    * 使用方式：把jwt放在请求头Header中的Authorization字段中

    * 注意：jwt包含认证信息，一旦被盗用，则可拥有所有权限，所以jwt有效期要设置得比较短，且用https传输

### 灰度发布

1. 参考链接：

    * [要进大厂？前端灰度发布必须要知道](https://juejin.im/post/5da88d795188252f051e2b47)

2. 详解

    * 概念

        灰度发布指某次新发布功能特性和旧功能特性之间能够以平滑过渡的方式呈现给用户

    * 实现原理

        后端判断用户是否在灰度测试名单内（查数据库，有点像游戏报名公测），决定渲染前端哪个版本的页面或数据

    * 样例
        * nginx
        * 5000端口：前端页面位于D:\ABtesting，version1为index1.html，version2为index2.html，访问http://localhost:5000/v1和http://localhost:5000/v2能访问到2个版本的页面(类似vue部署build文件)
        * 4000端口：给用户访问的url(http://localhost:4000)，代理转发到后端nodejs接口(http://localhost:3000)
        ```nginx
        server {
            listen       5000;
            server_name  localhost;
            root D:\ABtesting;

            location /v1 {
                try_files $uri $uri/ /index1.html;
            }

            location /v2 {
                try_files $uri $uri/ /index2.html;
            }
        }
        server {
            listen       4000;
            server_name  localhost;

            location / {
                proxy_pass http://localhost:3000;
            }
        }
        ```
        * nodejs
        * 访问http://localhost:3000/checkMVVM,然后访问：域名/版本(mvvm模式)
        * 访问http://localhost:3000/checkMVC,然后访问：域名/版本(mvc模式)
        * 访问http://localhost:3000/v1，返回版本1页面(mvc模式)
        * 访问http://localhost:3000/v2，返回版本2页面(mvc模式)
        * 访问http://localhost:3000/其它，返回404
        ```js
        var url = require("url"),
        fs = require("fs"),
        http=require("http");
        http.createServer(function (req, res) {
            var pathName = url.parse(req.url).pathname.replace(/\//, '')；
            console.log(pathName);
            if(pathName.indexOf('v1')>-1){
                res.setHeader("Content-Type","text/html;charset='utf-8'");
                fs.readFile("./index1.html","utf-8",function(err,data){
                    if(err) {
                        console.log("index1.html loading is failed :"+err);
                    }
                    else{
                        res.end(data);
                    }
                });
            }
            else if(pathName.indexOf('v2')>-1){
                res.setHeader("Content-Type","text/html;charset='utf-8'");
                fs.readFile("./index2.html","utf-8",function(err,data){
                    if(err) {
                        console.log("index2.html loading is failed :"+err);
                    }
                    else{
                        res.end(data);
                    }
                });
            }
            else if(pathName.indexOf('checkMVVM')>-1){
                //假装查询到应该返回哪个版本的页面
                if(new Date().getTime() % 2 == 0){
                    res.writeHead(302,{
                        'Location': 'http://localhost:5000/v1'
                    });
                    res.end();
                }
                else{
                    res.writeHead(302,{
                        'Location': 'http://localhost:5000/v2'
                    });
                    res.end();
                }
            }
            else if(pathName.indexOf('checkMVC')>-1){
                //假装查询到应该返回哪个版本的页面
                if(new Date().getTime() % 2 == 0){
                    res.writeHead(302,{
                        'Location': 'http://localhost:3000/v1'
                    });
                    res.end();
                }
                else{
                    res.writeHead(302,{
                        'Location': 'http://localhost:3000/v2'
                    });
                    res.end();
                }
            }
            else{
                res.write('404');
                res.end();
            }
        }).listen(3000);
        ```
        * 页面*：index*.html *表示1-4
        ```html
        <!DOCTYPE html>
        <html>
            <head>
                <title>v*</title>
            </head>
            <body>
                <input type="text" value="v*" />
            </body>
        </html>
        ```
        * 流程：
            1. 运行windows下的nginx.exe
            2. 运行nodejs:node index.js
            3. 访问浏览器：
                * mvc模式

                    访问http://localhost:4000/checkMVC,页面会代理转发到http://localhost:3000/v1或v2的页面，返回4000端口此域名下路由到的页面

                * mvvm模式

                    访问http://localhost:4000/checkMVVM,页面会代理转发到http://localhost:5000/v3或v4的页面，页面重定向到5000端口的前端页面

        * 样例文件见文件夹【灰度发布】

### 消息队列

1. 参考链接：

    [C#使用消息队列(MSMQ)](https://www.cnblogs.com/zhaotianff/p/8203619.html)

2. 详解：

    在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

    AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。

### 存储过程

1. 参考链接：

    [存储过程和函数](https://www.cnblogs.com/doudouxiaoye/p/5811836.html)

    [通过c#调用存储过程实现查询操作](https://blog.csdn.net/nc_star/article/details/82319886)

    [存储过程](https://www.jianshu.com/p/4f728a575cce)

    [SQL 存储过程入门](https://www.cnblogs.com/lideng/archive/2013/04/11/3013966.html)
    
    [MySQL 存储过程参数IN OUT INOUT区别](https://www.cnblogs.com/weibanggang/p/9664709.html)

    [MySQL 存储过程](https://www.runoob.com/w3cnote/mysql-stored-procedure.html)

2. 详解：

    * 概念
        
        存储过程就是一条或多条SQL语句的集合，可视为批文件，但是起作用不仅限于批处理。

    * 优点

        * 可封装，可传参
        * 减少应用与数据库服务器之间通讯流量及时间
        * 相对批量有更高的执行效率

    * 缺点

        * 不同数据库切换，需要重写

    * 使用

        * 声明与调用
        ```sql
        DROP PROCEDURE IF EXISTS `过程名`;
        CREATE PROCEDURE  过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) 过程体--创建存储过程
        --in只能当做传入参数
        --out只能当做转出参数
        --inout可当做传入转出参数
        DELIMITER ;;--声明语句结束符
        CREATE PROCEDURE fun(IN s int,OUT p_out int,INOUT p_out2 int)
            BEGIN
                SELECT p_out;
                SET p_out=2;
                SELECT p_out;

                SELECT p_out2;
                SET p_out2=2;
                SELECT p_out2;
            END
        DELIMITER ;

        SET @p=1;
        CALL fun(@p) ;--调用存储过程
        SET @p_out2=1;
        CALL funa(@p_out2);
        SELECT @p_out2;
        ```

        * 程序逻辑
        ```sql
        DROP PROCEDURE IF EXISTS proc;
        DELIMITER ;;
        CREATE PROCEDURE proc(IN parameter int)
        BEGIN--嵌套块使用begin和end
            DECLARE var int;--声明变量
            SET var=parameter+1;--变量赋值
            IF var=0 THEN
                SELECT 0;
            END IF ;
            IF parameter=0 THEN
                select "=0";
            ELSE
                select ">0";
            END IF ;

            CASE param
                WHEN 0 THEN
                    SELECT 0;
                WHEN 1 THEN
                    SELECT 1;
                ELSE
                    SELECT 1;
            END CASE ;

            SET var=0;
            WHILE var<6 DO
                SELECT var;
                SET var=var+1;
            END WHILE ;

            DECLARE v INT;
            SET v=0;
            REPEAT
                SELECT v;
                SET v=v+1;
                UNTIL v>=5
            END REPEAT;

            SET v=0;
            LOOP_LABLE:LOOP--语句块贴标签
                SELECT v;
                SET v=v+1;
                IF v >=5 THEN
                    LEAVE LOOP_LABLE;
                END IF;
            END LOOP;
        END ;
        ;;
        DELIMITER ;

        call proc(-1);
        ```

        * 样例1
        ```sql
        DROP TABLE IF EXISTS `tbl_job`;
        CREATE TABLE `tbl_job` (
            `ID` int(11) NOT NULL AUTO_INCREMENT,
            `JOB_NAME` varchar(32) NOT NULL COMMENT '职位名称',
            `OCCUPANT_ID` int(11) NOT NULL COMMENT '任职者',
            `AGE` int(11) NOT NULL COMMENT '年龄',
            PRIMARY KEY (`ID`)
        );
        -- ----------------------------
        -- Records of tbl_job
        -- ----------------------------
        INSERT INTO `tbl_job` VALUES ('1', '经理', '1', '21'),
        ('2', '董事长', '2', '21'),
        ('3', '项目组长', '3', '22'),
        ('4', 'SE', '4', '24'),
        ('5', 'MDE', '5', '24');

        DROP PROCEDURE IF EXISTS proc_tbl_job;
        DELIMITER ;;
        CREATE PROCEDURE proc_tbl_job(IN inId INT)
        BEGIN
            DECLARE id INT;
            DECLARE jobName VARCHAR(32);
            DECLARE occupantId INT;
            DECLARE age INT;
            
            DECLARE done INT DEFAULT FALSE;
            DECLARE curJob CURSOR FOR ( -- 定义
                SELECT ID,JOB_NAME,OCCUPANT_ID,AGE FROM tbl_job -- WHERE ID = inId
            );
            DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; -- 监听器
            
            OPEN curJob; -- 打开游标
            label:LOOP
                FETCH curJob INTO id,jobName,occupantId,age;
                IF done THEN LEAVE label;END IF;
                SELECT id,jobName,occupantId,age;
            END LOOP label;
            
            CLOSE curJob; -- 关闭游标
        END ;;
        delimiter;
        
        CALL proc_tbl_job(2)
        ```

        * 样例2
        ```sql
        DROP PROCEDURE IF EXISTS proc_syn_single_blacklist;
        DELIMITER ;;
        CREATE PROCEDURE proc_syn_single_blacklist(IN var_license VARCHAR(10))
        BEGIN
            DECLARE var_calc_amount_owed INT DEFAULT 0;  
            DECLARE var_calc_paid_in_money INT DEFAULT 0;
            DECLARE var_calc_arrears_count INT DEFAULT 0;
            
            SELECT License ,IFNULL(SUM(ReceivablesMoney),0),IFNULL(SUM(PaidInMoney),0),IFNULL(COUNT(*),0)
                into var_license, var_calc_amount_owed,var_calc_paid_in_money,var_calc_arrears_count
                    FROM  urpcs_evasion_arrears WHERE  license=var_license;
            SELECT var_license,var_calc_amount_owed,var_calc_paid_in_money,var_calc_arrears_count;
        END ;;
        DELIMITER;

        DROP PROCEDURE IF EXISTS proc_syn_blacklist;
        DELIMITER ;;
        CREATE PROCEDURE proc_syn_blacklist()
        BEGIN

            DECLARE var_license VARCHAR(10);
            DECLARE done INT DEFAULT FALSE;
            DECLARE curJob CURSOR FOR ( -- 定义
                SELECT DISTINCT license  FROM  urpcs_evasion_arrears ORDER BY EvasionID LIMIT 2 
            );
            DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; -- 监听器
            
            OPEN curJob; -- 打开游标
            label:LOOP
                FETCH curJob INTO var_license;
                IF done THEN LEAVE label;END IF;
                        call proc_syn_single_blacklist(var_license);
            END LOOP label;
            
            CLOSE curJob; -- 关闭游标
        END ;;
        DELIMITER;

        CALL proc_syn_blacklist();
        ```

### 数据库读写分离

1. 参考链接：

    [想用数据库“读写分离” 请先明白“读写分离”解决什么问题](https://baijiahao.baidu.com/s?id=1614304400276051465&wfr=spider&for=pc)

    [浅谈高性能数据库集群——读写分离](https://www.jianshu.com/p/eba38b1ff43c?utm_source=coffeephp.com)

2. 详解：

    将数据库分为主从库，一个主库用于写数据，多个从库完成读数据的操作，主从库之间通过某种机制进行数据的同步,提升数据库的读写性能

### SQL分页

1. 参考链接：

    [SQL server分页的四种方法](https://blog.csdn.net/weixin_37610397/article/details/80892426#max_43)

2. 详解：

    * 三重循环
    ```sql
    select * from 
    (select top pageSize * from 
    (select top (pageIndex*pageSize) * from Questions order by id asc ) as q1 
    order by id desc ) as q2
    order by id asc
    ```

    * 利用max（id）
    ```sql
    select top pageSize * from Questions where id >=
    (select max(id) from 
    (select top ((pageIndex-1)*pageSize+1) id from Questions order by id asc) as q1) 
    order by id;
    ```

    * 利用row_number
    ```sql
    select top pageSize * from 
    (select row_number() over(order by id asc) as rownumber,* from Questions) q1
    where rownumber>((pageIndex-1)*pageSize);
    ```

    * offset /fetch next（2012版本及以上才有）
    ```sql
    select * from Questions order by id 
    offset ((pageIndex-1)*pageSize) rows
    fetch next pageSize rows only;
    ```

    * 封装的存储过程
    ```sql
    create procedure paging_procedure
    (	@pageIndex int,
        @pageSize int
    )
    as
    begin 
        --实现方法
    end

    --调用
    exec paging_procedure @pageIndex=2,@pageSize=8;
    ```

### SQL索引原理

1. 参考链接：

    [深入浅出数据库索引原理](https://www.cnblogs.com/aspwebchh/p/6652855.html)

2. 详解：

    * 索引的生成

        把平铺堆叠的数据变为平衡树，查询时无需逐一查找，而是变为n分查找，提高了查询效率，但增删改导致数据变化，因此需要梳理平衡树，导致降低了增删改效率。

    * 聚集索引：主键
    * 非聚集索引：index

    * sql

        create index index_name on table_name(column_name);



## 服务器篇

### linux服务器定时执行任务

1. 参考链接：

    [Centos7 利用crontab定时执行任务及配置方法](https://www.cnblogs.com/p0st/p/9482167.html)

    [CentOs 7.0实现定时任务（定时访问网页）](https://blog.csdn.net/qq_16505093/article/details/51478064)

2. 详解：

    crond 和 crontab
    ```txt
    1、crontab -e，进入编辑界面 
    2、输入/2 * * * * curl http://www.baidu.com，表示每两分钟访问一次网页 
    3、保存退出，然后service crond start启动服务 
    4、chkconfig crond on设置开机自启动 
    5、 
    基本格式 : 
    *　　*　　*　　*　　*　　command 
    分　 时　 日　 月　 周　 命令 
    第1列表示分钟1～59 每分钟用或者 /1表示 
    第2列表示小时1～23（0表示0点） 
    第3列表示日期1～31 
    第4列表示月份1～12 
    第5列标识号星期0～6（0表示星期天）
    crond不支持精确到秒
    ```

### 高性能系统

1. 参考链接：

    * [高性能系统的常用开发手段](https://www.jianshu.com/p/b47e11b243ed)
    * [《解密腾讯海量服务之道》讲座笔记](https://www.cnblogs.com/xingzc/p/9023289.html)
    * [【TCP/IP】流量控制和拥塞控制](https://blog.csdn.net/bible_reader/article/details/90514729)

2. 详解：

    * 高性能方法

        1. 服务器硬件能力(但有瓶颈)
        2. 缓存(服务器缓存、浏览器缓存)(但不适用于提升并发量)
        3. 消息队列(解耦+削峰+异步)
        4. 负载均衡
        5. 数据库分库(读写分离)、分表(水平分表、垂直分表)
        6. CDN 加速(图片、视频)
        7. 合适的数据库连接池、线程池
        8. 多线程

    * 容灾方法

        1. 光纤断/机房停电-分布式部署
        2. 服务器硬件故障死机-数据热备份
        3. 程序崩溃-自动拉起(重启)
        4. 高并发崩溃-负载均衡、流量拥塞控制(参考链接3)、频率控制
        5. 系统指标异常-监控报警(流量、进程、cpu、IO、丢包、延时等)
        6. 不可预知的程序bug-灰度发布

    * 海量服务优化建议

        1. 大系统分布式解耦(微服务)
        2. 先运行正常再优化
        3. 架构重构




## 架构协同篇

### DevOps

1. 参考链接：

    [devops （过程、方法与系统的统称）](https://baike.baidu.com/item/devops/2613029?fr=aladdin)

    [为什么大公司一定要使用DevOps?](https://blog.csdn.net/g6U8W7p06dCO99fQ3/article/details/82056948)
    
    [Devops](https://www.jianshu.com/p/c5d002cf25b9)


2. 详解：

    * 概念

        DevOps是一种软件开发方法，为了让开发、运维和QA可以高效协作的流程。可以把DevOps看作开发（development）、技术运营（technology）和质量保障（quanlity assurance）三者的交集。

    * 演变

        DevOps从现有的软件开发策略/方法发展而来，以响应业务需求。

        * 阶段1：瀑布模型

            需要清晰固定的需求。

        * 阶段2：敏捷开发

            需求变化快，需要快速开发。

        * 阶段3：devops

            需求变化快，快速开发，尽可能自动化。

    * 对应用程序发布的影响

        * 频繁发布时每次程序变化少，程序能平滑生长。
        * 高效协调开发与运营，确保人员理解变更和充分合作。
        * 自动化部署，减少出错的可能性

    * 工具链

        * 代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion
        * 构建工具：Ant、Gradle、maven
        * 自动部署：Capistrano、CodeDeploy
        * 持续集成（CI）：Bamboo、Hudson、Jenkins
        * 配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail
        * 容器：Docker、LXC、第三方厂商如AWS
        * 编排：Kubernetes、Core、Apache Mesos、DC/OS
        * 服务注册与发现：Zookeeper、etcd、Consul
        * 脚本语言：python、ruby、shell
        * 日志管理：ELK、Logentries
        * 系统监控：Datadog、Graphite、Icinga、Nagios
        * 性能监控：AppDynamics、New Relic、Splunk
        * 压力测试：JMeter、Blaze Meter、loader.io
        * 预警：PagerDuty、pingdom、厂商自带如AWS SNS
        * HTTP加速器：Varnish
        * 消息总线：ActiveMQ、SQS
        * 应用服务器：Tomcat、JBoss
        * Web服务器：Apache、Nginx、IIS
        * 数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库
        * 项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker

