# 网站开发常见问题

* [前端篇](#前端篇)
* [后端篇](#后端篇)
* [服务器篇](#服务器篇)

## 前端篇

1. unicode和utf编解码的原理和不同

    * 参考链接：

        [Unicode和UTF-8字符串编码解码原理](https://blog.csdn.net/Enl0ve/article/details/82844484)

        [Unicode 和 UTF-8、UTF-16之间的区别](https://blog.csdn.net/zengchen__acmer/article/details/75332190)

        [【编码】ASCII、Unicode、GBK和UTF-8字符编码的区别联系](https://blog.csdn.net/u010262331/article/details/46013905)

        [各种常见编码的转换算法](https://blog.csdn.net/xiaolongwang2010/article/details/10311397)

    Unicode是字符集，而UTF-8是编码规则

    字符集为每一个字符分配一个唯一的ID(学名为码位/码点/Code Point)，而「编码规则」则是将「码位」转换为字节序列的规则。

    起初Unicode规定每个字符都是用 2个字节来表示，但是由于英文字符等只需要一个字节就可以表，那就造成了在保存英文文本时，就会浪费一倍的空间。

    UTF-8是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。

    ```txt
    例如「田」的码位是30000，记作U+7530(30000的16进制为0x7530)。
    U+ 0000 ~ U+ 007F: 0XXXXXXX
    U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX
    U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX
    U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
    
    根据上表中的编码规则，之前的「田」字的码位 U+7530 属于第三行的范围：
    
        7    5    3    0   
        0111 0101 0011 0000    二进制的 7530
    --------------------------
        0111   011111   100101 二进制的 77E5
    1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）
    11100111 10010100 10110000 代入模版
    E   7    9   4    B   0
    
    这就是将 U+7530 按照 UTF-8 编码为字节序列 E794B0 的过程。反之亦然。
    ```

    UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。

2. base64和二进制的不同

    * 参考链接：

        [让你完全理解base64是怎么回事](https://www.cnblogs.com/sweeeper/p/8462077.html)

        [一篇文章彻底弄懂Base64编码原理](https://blog.csdn.net/wo541075754/article/details/81734770)

        [JavaScript用btoa和atob来编码解码Base64](https://my.oschina.net/itblog/blog/1613977)

        [原生JS实现base64解码与编码](https://imweb.io/topic/5b8ea5327cd95ea86319358a)

    Base64编码可以将任意一组字节转换为较长的常见文本字符序列,将用户输入或二进制数据，打包成一种安全格式发送出去，无须担心其中包含冒号、换行符或二进制值等特殊字符。

    ```txt
    例子：输入Ow!

    (1) 字符串"Ow!"被拆分成3个8位的字节(0x4F、0x77、0x21)

    (2) 这3个字节构成了一个24为的二进制01001111 01110111 00100001

    (3) 这些为被划分为一些6位的序列010011、110111、011100、100001,(若不能正好平均分成每段6位，则按6和8的最小公倍数在末尾补0，位数为6和8的最小公倍数，000000用填充码=表示)

    (4) 每个6位值都表示了从0～63之间的数字，对应base64字母表中的64个字符之一。得到的base64编码字符串是4个字符的字符串“T3ch”。然后就可以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些移植性最好的字符(字母、数字等)。

    a:a -- 011000 010011 101001 100001 -- YTph

    a:aa -- 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx -- YTphYQ==

    a:aaa -- 011000 010011 101001 100001 011000 010110 0001xx xxxxxx -- YTphYWE=

    a:aaaa -- 011000 010011 101001 100001 011000 010110 000101 100001 -- YTphYWFh
    ```
    ```txt
    编码表：

    0　A　　17　R　　　34　i　　　51　z

    1　B　　18　S　　　35　j　　　52　0

    2　C　　19　T　　　36　k　　　53　1

    3　D　　20　U　　　37　l　　　54　2

    4　E　　21　V　　　38　m　　　55　3

    5　F　　22　W　　　39　n　　　56　4

    6　G　　23　X　　　40　o　　　57　5

    7　H　　24　Y　　　41　p　　　58　6

    8　I　　25　Z　　　42　q　　　59　7

    9　J　　26　a　　　43　r　　　60　8

    10　K　　27　b　　　44　s　　　61　9

    11　L　　28　c　　　45　t　　　62　+

    12　M　　29　d　　　46　u　　　63　/

    13　N　　30　e　　　47　v

    14　O　　31　f　　　48　w　　　

    15　P　　32　g　　　49　x

    16　Q　　33　h　　　50　y
    ```
    btoa和atob是window对象的两个函数，其中btoa是binary to ascii，用于将binary的数据用ascii码表示，即Base64的编码过程，而atob则是ascii to binary，用于将ascii码解析成binary数据
    ```js
    //方法实现
    var a = 'Hello World!';
    var encodedString = btoa(string);
    console.log(encodedString); // Outputs: "SGVsbG8gV29ybGQh"
    var decodedString = atob(encodedString);
    console.log(decodedString); // Outputs: "Hello World!"
    //涉及中文时，需要encodeURIComponent
    var b = "Hello, 中国！";
    //"SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE="
    var encodedString2 = btoa(encodeURIComponent(b));
    var decodedString2 = decodeURIComponent(atob(encodedString2));
    console.log(decodedString2); //"Hello, 中国！"
    ```

3. 绑定事件的不同种方式，执行顺序，事件委托

    * 参考链接：

        [看懂此文，不再困惑于javascript中的事件绑定、事件冒泡、事件捕获和事件执行顺序](https://blog.csdn.net/aitangyong/article/details/43231111)

        [js中的事件委托或是事件代理详解](https://www.cnblogs.com/liugang-vip/p/5616484.html)

    3种方式：
    ```html
    <p id="btn" onclick="hello()"></p>
    <script>
        document.getElementById("btn").onclick = function(){}
        document.getElementById("btn").addEventListener("click",function(){})
    </script>
    ```
    其中addEventListener可重复绑定同一元素，先绑定先执行。

    对于层叠元素，则需要区分事件冒泡和事件捕获，冒泡：从底向面，捕获：从面向底。addEventListener((type, listener, useCapture)
    
    阻止冒泡：只执行当前元素事件，不执行层叠元素事件。event.stopPropagation()

    事件委托：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如ul下有很多li，逐一绑定事件很影响性能，且新li加入也要重新绑定事件，会十分麻烦，所以li事件需要委托其上一级ul代为执行事件。
    ```js
    window.onload = function(){
    　　var oUl = document.getElementById("ul1");
    　　oUl.onclick = function(ev){
    　　　　var ev = ev || window.event;
    　　　　var target = ev.target || ev.srcElement;
    　　　　if(target.nodeName.toLowerCase() == 'li'){
    　 　　　　　　	alert(123);
    　　　　　　　  alert(target.innerHTML);
    　　　　}
    　　}
    }
    ```

4. css旋转、拖拽、手势移动

    * 参考链接：

        [CSS3动画（360度旋转、旋转放大、放大、移动）](https://www.cnblogs.com/guozhe/p/5912664.html)

        [HTML5 CSS3 专题 : 拖放 （Drag and Drop）](https://www.cnblogs.com/wzjhoutai/p/6858022.html)

    关键词：transform,translate,scale,rotate,transition,animation,@keyframes,drag系列事件,cursor


5. http状态码和使用场景

    * 参考链接：

        [HTTP状态码（HTTP Status Code）及常用场景](https://www.cnblogs.com/QQParadise/p/5019860.html)

    ```txt
    常见状态码：
    HTTP: Status 200 – 服务器成功返回网页
    HTTP: Status 3xx - 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向
    HTTP: Status 404 – 请求的网页不存在
    HTTP: Status 503 – 服务不可用
    ```

6. 前端截图上传服务器实现

    * 参考链接：

        [浅析 js 实现网页截图的两种方式](https://juejin.im/entry/58b91491570c35006c4f7fdf)

    6.1 canvas思路:(html2canvas)
    ```txt
    将dom转换成canvas图片。

    递归取出目标模版的所有DOM节点，填充到一个rederList，并附加是否为顶层元素/包含内容的容器 等信息

    通过z-index postion float等css属性和元素的层级信息将rederList排序，计算出一个canvas的renderQueue

    遍历renderQueue，将css样式转为setFillStyle可识别的参数，依据nodeType调用相对应canvas方法，如文本则调用fillText，图片drawImage，设置背景色的div调用fillRect等

    将画好的canvas填充进页面
    ```
    优缺点:复杂度高，稳定性强。

    6.2 svg思路:(rasterizeHTML.js)
    ```txt
    svg的标签里有个foreignObject标签，可以加载其它命名空间的xml(xhtml)文档,只需要将要渲染的DOM扔进<foreignObject></foreignObject>，利用Blob构建svg图像。
    通过一系列的hack技巧替我们绕过了许多限制:
    1.将<img/>的url 转为 dataURI
    2.将background-color从style中取出，修改url后重新插入样式表
    3.将link的的样式通过ajax down下来然后注入<style></sytle>
    ```
    优缺点:简单，只能对已经存在的静态资源进行处理，而对js动态生成并不能实时处理。

    6.3 上传
    ```js
    var fd = new FormData();
    fd.append("img", imgBlob);
    $.ajax({
        type: "POST",
        url: "http://tmpfile.coding.io/img",
        dataType: 'json',
        data: fd,
        crossDomain: true,
        processData: false,
        contentType: false,
        success: function(data){
            if(data && data.path) {    
            console.log("http://tmpfile.coding.io/tmp" + data.path);
            }
        }
    });
    ```

7. 获取图片上传进度

    * 参考链接：

        [XHR简介](https://www.cnblogs.com/syfwhu/p/6116323.html)

        [深入理解ajax系列第一篇——XHR对象](https://www.cnblogs.com/yibutian/p/9456248.html)

        [XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)

        [使用原生JS 或jquery ajax 获取上传图片实时进度](https://segmentfault.com/a/1190000012871456)

        [JS、JQ实现图片上传，文件上传、带进度条上传的几种方法](https://blog.csdn.net/qq_38740171/article/details/82999793)

    * 常用只读属性：

        (1) XMLHttpRequest.readyState 返回unsigned short，状态码:
        * 0	UNSENT 代理被创建，但尚未调用 open() 方法。
        * 1	OPENED open() 方法已经被调用。
        * 2	HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。
        * 3	LOADING	下载中,responseText 属性已经包含部分数据。
        * 4	DONE 下载操作已完成。

        (2) XMLHttpRequest.response 返回ArrayBuffer、Blob、Document、DOMString，具体是哪种类型取决于XMLHttpRequest.responseType的值。其中包含响应体body。

        (3)XMLHttpRequest.responseText 返回string或null

        (4)XMLHttpRequest.responseURL 返回响应的序列化URL

        (5)XMLHttpRequest.responseXML 返回一个Document，其中包含该请求的响应
        * 如果响应的内容类型是'text/xml'或'application/xml'，这个属性中将保存着响应数据的XML DOM文档(document形式)

        (6)XMLHttpRequest.status 返回unsigned short，请求响应状态
        * UNSENT（未发送） 0
        * OPENED（已打开） 0
        * LOADING（载入中） 200
        * DONE（完成） 200

        (7)XMLHttpRequest.statusText 返回string，响应状态文本
        * UNSENT
        * OPENED
        * LOADING
        * DONE
        * OK
        * Not Found

    * 常用属性：

        (1) XMLHttpRequest.responseType 响应数据的类型：text、arraybuffer、blob、document、json

    * 常用方法：

        (1)XMLHttpRequest.abort() 中止请求

        (2)XMLHttpRequest.getAllResponseHeaders() 返回所有用CRLF分隔的响应头,string或null
        ```js
        var request = new XMLHttpRequest();
        request.open("GET", "foo.txt", true);
        request.send();

        request.onreadystatechange = function() {
        if(this.readyState == this.HEADERS_RECEIVED) {

            // Get the raw header string
            var headers = request.getAllResponseHeaders();

            // Convert the header string into an array
            // of individual headers
            var arr = headers.trim().split(/[\r\n]+/);

            // Create a map of header names to values
            var headerMap = {};
            arr.forEach(function (line) {
                var parts = line.split(': ');
                var header = parts.shift();
                var value = parts.join(': ');
                headerMap[header] = value;
            });

            var contentType = headerMap["content-type"];//text/html; charset=utf-8
        }

        /*
        date: Fri, 08 Dec 2017 21:04:30 GMT\r\n
        content-encoding: gzip\r\n
        x-content-type-options: nosniff\r\n
        server: meinheld/0.6.1\r\n
        x-frame-options: DENY\r\n
        content-type: text/html; charset=utf-8\r\n
        connection: keep-alive\r\n
        strict-transport-security: max-age=63072000\r\n
        vary: Cookie, Accept-Encoding\r\n
        content-length: 6502\r\n
        x-xss-protection: 1; mode=block\r\n
        */
        ```

        (3)XMLHttpRequest.getResponseHeader(name) 返回包含指定响应头的字符串,string或null，name如"Content-Type"

        (4)XMLHttpRequest.open(method, url, async, user, password) 初始化一个请求
        * method:get,post,put,delete
        * async:是否异步
        * user和password用于认证

        (5)XMLHttpRequest.overrideMimeType() 重写由服务器返回的MIME type,默认"text/xml"

        (6)XMLHttpRequest.send() 发送请求

        (7)XMLHttpRequest.setRequestHeader(header, value) 设置HTTP请求头的值

    * 事件：

        (1)onloadstart 开始

        (2)onprogress 数据传输进行中

        (3)onabort 终止

        (4)onerror 失败

        (5)onload 成功

        (6)ontimeout 超时

        (7)onloadend 完成（不论成功与否）

        (8)onreadystatechange readyState属性发生变化

    * 获取上传图片实时进度

    ```js
    $.ajax({
        url: 'URL',
        type: 'POST',
        data: data,
        processData: false, //用来回避jquery对formdata的默认序列化，XMLHttpRequest会对其进行正确处理  
        contentType: false, //设为false才会获得正确的conten-Type  
        xhr: function() { //用以显示上传进度  
            var xhr = $.ajaxSettings.xhr();
            if (xhr.upload) {
                xhr.upload.addEventListener('progress', function(event) {
                    var percent = Math.floor(event.loaded / event.total * 100);
                    $("#progress .progress-item").css("width",percent + "%");
                }, false);
            }
        },
        success: function(data) {

        }
    })

    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'url');
    // 上传完成后的回调函数
    xhr.onreadystatechange = function() {
        if (xhr.status === 200) {　　
            console.log(xhr.responseText);
        } else {　
            console.log('上传出错');
        }
    };
    // 获取上传进度
    xhr.upload.onprogress = function(event) {
        console.log(event.loaded)
        console.log(event.total)
        if (event.lengthComputable) {
            var percent = Math.floor(event.loaded / event.total * 100);
            document.querySelector("#progress .progress-item").style.width = percent + "%";
            // 设置进度显示
            console.log(percent)
        }
    };
    xhr.send(data);
    ```


8. 无限滚动
9. 持久化缓存
10. []==false !![]==true
11. setTimeOut和setInterval底层区别
12. c++和js区别
13. js继承
14. 闭包数据缓存
15. 事件循环机制 promise
16. 页面生成过程
17. es6
18. http请求方式：get/post/put/delete
19. CMD原理
20. vue响应式原理

## 后端篇

1. 消息队列

    在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

    AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。

2. 存储过程

    * 参考链接：

        [存储过程和函数](https://www.cnblogs.com/doudouxiaoye/p/5811836.html)

    存储过程就是一条或多条SQL语句的集合，可视为批文件，但是起作用不仅限于批处理。

3. 数据库读写分离




## 服务器篇

1. linux服务器定时执行任务

    * 参考链接：

        [Centos7 利用crontab定时执行任务及配置方法](https://www.cnblogs.com/p0st/p/9482167.html)

        [CentOs 7.0实现定时任务（定时访问网页）](https://blog.csdn.net/qq_16505093/article/details/51478064)

    crond 和 crontab
    ```txt
    1、crontab -e，进入编辑界面 
    2、输入/2 * * * * curl http://www.baidu.com，表示每两分钟访问一次网页 
    3、保存退出，然后service crond start启动服务 
    4、chkconfig crond on设置开机自启动 
    5、 
    基本格式 : 
    *　　*　　*　　*　　*　　command 
    分　 时　 日　 月　 周　 命令 
    第1列表示分钟1～59 每分钟用或者 /1表示 
    第2列表示小时1～23（0表示0点） 
    第3列表示日期1～31 
    第4列表示月份1～12 
    第5列标识号星期0～6（0表示星期天）
    crond不支持精确到秒
    ```






