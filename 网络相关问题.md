# 网络相关问题

- [http 状态码和使用场景](#http状态码和使用场景)
- [页面加载生成过程](#页面加载生成过程)
- [http 请求方式](#http请求方式)
- [网络协议与 7 层结构](#网络协议与7层结构)
- [强制缓存和协商缓存](#强制缓存和协商缓存)
- [xss 和 csrf](#xss和csrf)

---

### http 状态码和使用场景

1. 参考链接：

   [HTTP 状态码（HTTP Status Code）及常用场景](https://www.cnblogs.com/QQParadise/p/5019860.html)

   [HTTP 状态码](https://www.runoob.com/http/http-status-codes.html)

2. 详解：

```txt
常见状态码：
---------------信息，服务器收到请求，需要请求者继续执行操作------------------------
100	Continue	继续。客户端应继续其请求
101	Switching Protocols	切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
---------------成功，操作被成功接收并处理------------------------
200	OK	请求成功。一般用于GET与POST请求
201	Created	已创建。成功请求并创建了新的资源
202	Accepted	已接受。已经接受请求，但未处理完成
203	Non-Authoritative Information	非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
204	No Content	无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
205	Reset Content	重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
206	Partial Content	部分内容。服务器成功处理了部分GET请求
---------------重定向，需要进一步的操作以完成请求------------------------
300	Multiple Choices	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
303	See Other	查看其它地址。与301类似。使用GET和POST请求查看
304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
305	Use Proxy	使用代理。所请求的资源必须通过代理访问
306	Unused	已经被废弃的HTTP状态码
307	Temporary Redirect	临时重定向。与302类似。使用GET请求重定向
---------------客户端错误，请求包含语法错误或无法完成请求------------------------
400	Bad Request	客户端请求的语法错误，服务器无法理解
401	Unauthorized	请求要求用户的身份认证
402	Payment Required	保留，将来使用
403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求
404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
405	Method Not Allowed	客户端请求中的方法被禁止
406	Not Acceptable	服务器无法根据客户端请求的内容特性完成请求
407	Proxy Authentication Required	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
408	Request Time-out	服务器等待客户端发送的请求时间过长，超时
409	Conflict	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突
410	Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置
411	Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息
412	Precondition Failed	客户端请求信息的先决条件错误
413	Request Entity Too Large	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息
414	Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理
415	Unsupported Media Type	服务器无法处理请求附带的媒体格式
416	Requested range not satisfiable	客户端请求的范围无效
417	Expectation Failed	服务器无法满足Expect的请求头信息
---------------服务器错误，服务器在处理请求的过程中发生了错误------------------------
500	Internal Server Error	服务器内部错误，无法完成请求
501	Not Implemented	服务器不支持请求的功能，无法完成请求
502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
503	Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求
505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理
```


### 页面加载生成过程

1. 参考链接：

   [网页生成过程及重排和重绘](https://blog.csdn.net/qq_41635167/article/details/83932920)

   [web 页面加载、解析、渲染过程](https://www.cnblogs.com/CandyManPing/p/6635008.html)

   [从输入 URL 到页面加载的全过程](https://www.cnblogs.com/xiaohuochai/p/9193083.html)

   [详解 DNS 域名解析全过程](https://blog.csdn.net/m0_37812513/article/details/78775629)

   [一次完整的 HTTP 请求所经历的 7 个步骤](https://www.cnblogs.com/jiu0821/p/5641600.html)

   [HTTPS 的建立过程（SSL 建立安全会话的过程）](https://blog.csdn.net/u011779724/article/details/80776776)

   [你连 HTTPS 原理都不懂，还讲“中间人攻击”？](https://mp.weixin.qq.com/s/sHtZhRTNOihmxap5sDD6xQ)

2. 详解：

   浏览器：

   - 输入网址并确认
   - 检查浏览器缓存,见[强制缓存与协商缓存](#强制缓存与协商缓存)
     - 存在缓存，检查是否过期(expires(具体时间)和 cache-control(max-age 秒))
       - 未过期，直接返回页面
       - 过期，向服务器发起请求(请求过程见下方)验证资源是否未修改(附带 ETag 和 if-last-modify)
         - 未修改，返回 304
         - 修改，最新资源和返回 200
     - 不存在缓存，向服务器发起请求(请求过程见下方)
   - 域名解析(通过 DNS 找 IP)

     - 检查浏览器 DNS 缓存(TTL)，存在则返回上一次解析的 IP
     - 不存在则检查操作系统缓存(本地 hosts 文件)是否有相应域名配置
     - 没对应再向 LDNS(本地域名服务器)(城市中距离较近的域名服务器)发起查询
     - 不存在则向根域名.查询，根域名服务器返回 LDNS 一个所查询域的主域名服务器（gTLD Server，国际顶尖域名服务器，如.com .cn .org 等）地址
     - LDNS 再发送请求给上一步返回的 gTLD
     - 接受请求的 gTLD 查找并返回这个域名对应的 Name Server 的地址，这个 Name Server 就是网站注册的域名服务器
     - Name Server 根据映射关系表找到目标 ip，返回给 LDNS
     - LDNS 缓存这个域名和对应的 ip
     - LDNS 把解析的结果返回给用户，用户根据 TTL 值缓存到本地系统缓存中，域名解析过程至此结束

   - 建立 TCP 连接(三次握手)

     ```txt
     1.SYN包，SYN=1,Seq=X,进入 SYN_SENT 状态
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     2.SYN-ACK包,SYN=1,ACK=X+1,Seq=Y,进入 SYN_RECV 状态
     client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
     3.SYN包，SYN=2,ACK=Y+1
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     双方进入 ESTABLISHED 状态
     ```

   - http 请求

     ```txt
     请求报文(查看request headers)
     POST /search HTTP/1.1
     Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,
     application/msword, application/x-silverlight, application/x-shockwave-flash, */*
     Referer: <a href="http://www.google.cn/">http://www.google.cn/</a>
     Accept-Language: zh-cn
     Accept-Encoding: gzip, deflate
     User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)
     Host: <a href="http://www.google.cn">www.google.cn</a>
     Connection: Keep-Alive
     Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;
     NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-
     FxlRugatx63JLv7CWMD6UB_O_r

     hl=zh-CN&source=hp&q=domety
     ```

   - https 请求过程(TLS):

     - 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器
     - 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公钥的证书发送给客户端；该证书包含了数字签名和一个用作产生密钥的随机数
     - 客户端验证证书(用根证书的 C.pub 鉴定证书合法性)后(验证不通过，浏览器会警告)，抽取服务器公钥，再产生一个的随机密码串 pre_master_secret，并使用服务器公钥加密（RSA 非对称加解密），发送给服务器
     - 客户端与服务器端根据随机密码串 pre_master_secret 以及客户端与服务器的随机数值独立计算出 MAC 密钥(Diffie-Hellman 密钥交换算法)
     - 客户端将 MAC 值发送给服务器
     - 服务器将 MAC 值发送给客户端

     ```txt
     1.算法列表+随机数
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     2.加密算法(证书+公钥+随机数+数字签名(私钥加密))
     client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
     3.验证，公钥加密(随机密码串)
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     4.Diffie-Hellman密钥交换算法
     有两个全局公开的参数，一个素数q和一个整数a,a是q的一个原根(g^i mod p ≠ g^j mod p).
     用户A选择一个作为私有密钥的随机数XA(XA<q)，并计算公开密钥YA=a^XA mod q
     用户B选择一个私有的随机数XB<q，并计算公开密钥YB=a^XB mod q
     用户A产生共享秘密密钥的计算方式是K = (YB)^XA mod q
     用户B产生共享秘密密钥的计算是K = (YA)^XB mod q
     5.秘钥交换后得出对称秘钥，对内容加密后传输
     ```

     - 为什么数据传输是用对称加密？

       - 非对称加密的加解密效率是非常低，大量的交互无法接受低效率

       - 服务端保存了私钥，公钥公知，所以一对公私钥只能实现单向的加解密

     - 为什么需要 CA 认证机构颁发证书？

       - HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。

       - 假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题。

       - 中间人攻击：中间人分别和客户、正规网站通过 https 连接，因取得对称秘钥，可轻易窃取信息

       1. 本地请求被劫持（如 DNS 劫持等），所有请求均发送到中间人的服务器

       2. 中间人服务器返回中间人自己的证书

       3. 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输

       4. 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密

       5. 中间人以客户端的请求内容再向正规网站发起请求

       6. 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据

       7. 中间人凭借与正规网站建立的对称加密算法对内容进行解密

       8. 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输

       9. 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

     - 浏览器是如何确保 CA 证书的合法性？

       1. 证书包含信息

          - 颁发机构信息
          - 公钥
          - 公司信息
          - 域名
          - 有效期
          - 指纹

       2. 证书的合法性依据

          权威机构需要对其颁发的证书进行信用背书，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。

       3. 浏览器验证证书的合法性

          1. 验证域名、有效期等信息是否正确

          2. 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证

          3. 判断证书是否被篡改。需要与 CA 服务器进行校验

          4. 判断证书是否已吊销，通过 CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第 3 步中以减少与 CA 服务器的交互，提高验证效率

          5. 既然证书是公开的如何避免这种证书冒用的情况？

             非加密对称中，中间人可以得到证书，但私钥是无法获取，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。

       4. 只有认证机构可以生成证书吗？

          如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。

       5. 本地随机数被窃取怎么办？

          证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？

          其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。

       6. 用了 HTTPS 会被抓包吗？

          抓包后只能看到加密后数据，但用户与非机构证书网站连接，且主动授权连接，会有中间人攻击的可能

   - websocket

     websocket 是全双工通信,信息能够同时双向传送。通信方式还有单工(单向),半双工(双向不同时)

     ```txt
     1.发送连接请求
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     2.返回连接应答
     client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
     3.连接就绪
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     ```

   - 服务器处理请求，响应 HTML

     ```txt
     响应报文
     HTTP/1.1 200 OK
     Date: Sat, 31 Dec 2005 23:59:59 GMT
     Content-Type: text/html;charset=ISO-8859-1
     Content-Length: 122

     ＜html＞
     ＜head＞
     ＜title＞Wrox Homepage＜/title＞
     ＜/head＞
     ＜body＞
     ＜!-- body goes here --＞
     ＜/body＞
     ＜/html＞
     ```

   - 浏览器解析 HTML 页面

     - 解析 html：HTML 代码转化成 DOM
     - 页面加载时遇到 CSS/JS/图片等资源会发送请求获取
     - 解析 css/js：CSS 代码转化成 CSSOM（CSS Object Model）、js 处理后产生一棵节点带 CSS Style、会响应自定义事件的 Styled DOM 树
     - 构建 render 树：结合 DOM 和 CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
     - 渲染排列：生成布局（layout），即将所有渲染树的所有节点进行平面合成，主要影响性能的地方
     - 渲染绘制：将布局绘制（paint）在屏幕上，主要影响性能的地方

     重排：DOM 结构发生变化（js 操作：事件、增减移动元素）

     重绘：DOM、CSS 发生变化（js 操作：事件、增减移动元素、元素样式变化）

   - 关闭 TCP 连接(四次挥手)
     ```txt
     1.FIN包,FIN=1,ACK=Z,Seq=X,进入 FIN_WAIT_1 状态
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     2.ACK包,ACK=X+1,Seq=Y,服务器进入 CLOSE_WAIT 状态，浏览器端进入 FIN_WAIT_2 状态
     client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
     3.FIN包,FIN=1,ACK=X+1,Seq=Y,浏览器段进入 LAST_ACK 状态
     client<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<server
     4.ACK包,ACK=Y+1,Seq=X+1,浏览器状态变成 TIME_WAIT
     client>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>server
     服务器、浏览器关闭TCP连接
     ```

### http 请求方式

1. 参考链接：

   [HTTP 请求方法详解](https://www.cnblogs.com/foodoir/p/5911099.html)

   [HTTP 协议以及 HTTP 请求中 8 种请求方法](https://blog.csdn.net/qq_38191191/article/details/78671063)

   [RESTful 介绍和使用教程](https://blog.csdn.net/x541211190/article/details/81141459)

2. 详解：

   - 8 种请求方法

     - get

     获取资源:URL 提交数据，但是不同的浏览器对于 URL 是有限制的,IE 传输的数据量一般限制在 2KB

     - post

     传输实体文本:提交的数据放置在 HTTP 报文实体的主体里,安全性比 GET 方法要高,POST 数据大小无限制

     - head

     获得报文首部:用于确认 URI 的有效性及资源更新的日期时间

     - put

     传输文件:用来传输文件,保存在请求 URI 指定的位置,HTTP/1.1 的 PUT 方法自身不带验证机制,存在安全问题

     - delete

     删除文件:按 URI 删除指定资源

     - options

     询问支持的方法:查询针对请求 URI 指定资源支持的方法（客户端询问服务器可以提交哪些请求方法）

     - trace

     追踪路径:对请求消息的传输路径进行追踪，TRACE 方法是让 Web 服务器端将之前的请求通信还给客户端的方法

     - connect

     用隧道协议连接代理:主要使用 SSL（安全套接层）和 TLS（传输层安全）协议把通信内容加密后经网络隧道传输

   - restful

     基于 HTTP、URI、XML、JSON 等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是 Web 服务的一种新的架构风格。

     - 对网络上所有的资源都有一个 Url（通用资源标志符）

     - 对资源的操作不会改变 Url

     - 同一资源有多种表现形式

       xml、json

     - 所有操作都是无状态的

       基于接口：客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前的请求，不需了解请求的历史。可以更容易的释放资源，让服务器利用 Pool（连接池）技术来提高稳定性和性能。

     - 资源操作
       - get->select
       - post->insert
       - put->update
       - delete->delete

### 网络协议与 7 层结构

1.  参考链接：

    [网络七层协议](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/6056879?fr=aladdin)

    [TCP （传输控制协议）](https://baike.baidu.com/item/TCP/33012)

    [浅谈 ftp 和 sftp 的区别](https://blog.csdn.net/zdb292034/article/details/84531859)

    [Telnet](https://baike.baidu.com/item/TELNET/810597)

    [网络文件系统](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/9719420?fromtitle=NFS&fromid=812203)

    [SMTP](https://baike.baidu.com/item/SMTP/175887)

    [http](https://baike.baidu.com/item/http/243074?fr=aladdin)

    [HTTP1.0，HTTP1.1 和 HTTP2.0 的区别](https://www.jianshu.com/p/7bfec28236c3)

    [HTTP3.0(QUIC 的实现机制)](https://www.cnblogs.com/chenjinxinlove/p/10104854.html)

2.  详解：

    - 网络七层协议

      1. 物理层

         物理电流电路相关的传输介质

      2. 数据链路层

         定义了在单个链路上如何传输数据

      3. 网络层

         定义了能够标识所有结点的逻辑地址，IP 协议

      4. 传输层

         数据流输入、复用与重排序，TCP、UDP 协议

      5. 会话层

         会话开始、控制、结束，如使用 SQL

      6. 表示层

         定义数据格式及加密，如使用 ASCII 字符集

      7. 应用层

         与其它计算机进行通讯的一个应用，对应应用程序，如使用 TELNET，HTTP，FTP，NFS，SMTP

    - 协议

      - tcp

        1. 可靠连接，有状态连接，每个包会有序号，接收成功会返回 ack，三次握手和四次挥手具体见[页面加载生成过程](#页面加载生成过程)

        2. TCP 拥塞控制(AIMD)算法：

           - 慢启动

             每当建立一个 TCP 连接时或一个 TCP 连接发生超时重传后，该连接便进入慢启动阶段。

             拥塞窗口：避免拥塞的窗口。

             一开始拥塞窗口指数级增加，如果超过阈值，进入拥塞避免阶段，如果报文段丢失重传，重新慢启动

           - 拥塞避免

             每一次报文被完全接收后，拥塞窗口才加 1，拥塞窗口线性增加

           - 快速重传

             对超时重传的改进，当源端收到对同一个报文的三个重复确认时，就确定一个报文段已经丢失，因此立刻重传丢失的报文段，减少不必要的等待时间。

           - 快速恢复

             对丢失恢复机制的改进，快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段

      - udp

        不可靠连接，无状态连接，常用于多媒体数据流，强调传输性而不是完整性，包错漏不重传

      - ftp 与 sftp

        - ftp 文件传输协议，方便数据共享。FTP 客户端通过 FTP 协议在服务器上下载资源
        - sftp 是在 ftp 之上进行加密

      - Telnet

        - 是 Internet 远程登录服务的标准协议和主要方式

        - 过程

          1. 通过 ip 与远程建立连接(建立一个 TCP 连接)
          2. 输入用户名和密码，以 VNT 格式发送数据(从本地主机向远程主机发送一个 IP 数据包)
          3. 远程主机返回结果
          4. 撤销 TCP 连接

      - NFS

        基于 UDP/IP 协议,允许远程客户端以与本地文件系统类似的方式，来通过网络进行访问

      - SMTP

        电子邮件传输的协议,建立在 FTP 文件传输服务上的一种邮件服务

      - http/https

        - http 请求-响应协议,基于 tcp 协议

          版本：

                * 0.9:交换信息的无序协议，仅仅限于文字
                * 1.0:对每一次请求/响应建立并拆除一次连接,双方规定了连接方式和连接类型
                * 1.1:长连接;引入Entity tag，If-Unmodified-Since, If-Match, If-None-Match等新的请求头来控制缓存;请求头引入了range头域，支持断点续传功能;支持Host头域
                * 2.0:使用了多路复用的技术,做到同一个连接并发处理多个请求;允许服务端推送资源给浏览器;采用二进制格式传输数据,比文本传输更快;header压缩
                * 3.0:QUIC协议:自定义连接机制,自定义重传机制,无阻塞的多路复用,自定义流量控制(在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能)

          ![网络是怎样连接的](https://user-gold-cdn.xitu.io/2020/4/18/1718e036c7b23225?imageslim)


            * https在http之上进行加密
    
                连接过程见[页面加载生成过程](#页面加载生成过程)

### 强制缓存和协商缓存

1. 参考链接：

   [强制缓存（200）和协商缓存（304）整理](https://blog.csdn.net/zl399615007/article/details/84534884)

   [强制缓存和协商缓存有什么区别](https://www.jianshu.com/p/1a1536ab01f1)

   [彻底弄懂强缓存与协商缓存](https://www.jianshu.com/p/9c95db596df5)

2. 详解：

   - 强制缓存

     浏览器在请求某一资源时，会先获取该资源缓存的 header 信息，判断是否命中强缓存（cache-control 和 expires 信息），若命中，从缓存中获取资源信息，包括缓存 header 信息，本次请求不会与服务器通信。状态码：200（from cache）

     - 相关 header

       - expires:强制缓存过期时间
       - cache-control:更细致的 expires,优先级高于 expires，其值包含：
         - public(可被任何缓存区缓存),private(单个用户的响应消息，不共享缓存)
         - no-cache(请求或响应消息不能缓存),no-store(请求和响应消息都不使用缓存)
         - max-age(过期时间,用于普通缓存)
         - s-maxage(代理缓存,优先级高于 max-age/Expires,如 CDN 缓存)
         - min-fresh(可以接收响应时间小于当前时间加上指定时间的响应),max-stale(可以接收超时的响应)

   - 协商缓存

     如果没有命中强制缓存，浏览器会发送请求到服务器，请求会携带第一次返回的有关缓存的 header 字段信息（Last-Modifued/If-Modified-Since 和 Etag/If-None-Match），由服务器根据 header 信息来比对结果是否协商缓存命中。若命中，则服务器返回新的响应 header 信息更新缓存中的对应 header 信息，但是不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。状态码：304（not modified）

     - 相关 header

       - Last-Modified(响应资源的最后修改时间)
       - If-Modified-Since(资源过期时，如有 Last-Modified，请求服务器会带上此请求时间，如 Last-Modified 时间大于 if-modified-since，则返回最新资源，HTTP 200，否则响应 HTTP 304)
       - Etag(服务器响应时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache 中，ETag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行 Hash 后得到的。)
       - If-None-Match(资源过期时，如有 Etag，请求服务器会带上 if-none-match(值是 Etag 的值)，由服务器决定返回 200 或 304)
       - 优先级：ETag>Last-Modified

     - 为什么既有 Last-Modified 还有 Etag?Last-Modified 比较难解决的问题:

       - 文件周期性变化，文件仅仅改变的修改时间，而不改变内容，导致重新 get
       - 文件变化特别快，需要用到 If-Modified-Since，能检查到的粒度是秒级
       - 某些服务器不能精确的得到文件的最后修改时间

     - 用户的行为对缓存的影响

       - 对 Expires/Cache-Control 有效：地址栏回车/页面链接跳转/新开窗口/前进后退
       - 对 Expires/Cache-Control 有效：F5 刷新/Ctrl+F5 强制刷新
       - 对 Last-Modified/Etag 有效：地址栏回车/页面链接跳转/新开窗口/前进后退/F5 刷新
       - 对 Last-Modified/Etag 有效：Ctrl+F5 强制刷新

### xss 和 csrf

1. 参考链接：

   [XSS 和 CSRF 简述及预防措施](https://www.cnblogs.com/yangsg/p/10621496.html)

   [xss 注入方法及验证方法](https://blog.51cto.com/zhouanya/1909746)

   [XSS 及 CSRF 攻击防御](https://blog.csdn.net/zl834205311/article/details/81773511)

2. 详解：

   - xss(跨站脚本攻击)

     在网站写入恶意代码，当别人浏览网页时，导致恶意脚本被执行，获取用户隐私数据。

     - 反射型：发送带恶意脚本的 get、post 请求(如 websocket 对话)，后端没做过滤，就直接向其它用户展示
     - 持久型：提交恶意 input，后端没做过滤，保存到数据库，再向其它用户展示
     - DOM 型：将攻击脚本写在 URL 中，诱导用户点击该 URL，如果 URL 被解析，那么攻击脚本就会被运行。document.write(url 上的参数)

     预防方法：对输入进行检查、过滤和转义。

   - csrf(跨站请求伪造)

     用户带着 A 网站的 cookie，访问 B 网站时，被 B 网站窃取后，B 网站向 A 网站发送伪造请求，使 B 网站获得用户在 A 网站的权限。

     预防方法：

     - 验证码:图像识别，提高攻击难度
     - referer:header 的 referer 记录了来源地址，检测到 referer 不是本网站的请求，则拒绝
     - 令牌:请求头带 token，验证身份，如 jwt

   - 其它

     打开网页，自动生成危险文件下载到本地

     ```js
     var file = new File(["hack"], "hack.txt", { type: "text/plain" });
     var objectURL = URL.createObjectURL(file);
     var a = document.createElement("a");
     a.href = objectURL;
     a.download = "hack.txt";
     document.body.appendChild(a);
     a.click();
     ```

